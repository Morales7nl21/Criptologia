NUEVA YORK • SAN JUAN • SANTIAGO • SÃO PAULO • AUCKLAND • LONDRES • MILÁNMONTREAL • NUEVA DELHI • SAN FRANCISCO • SINGAPUR • ST. LOUIS • SIDNEY • TORONTO00Pressman(i-xxx)prelim.indd iii 2/2/10 11:40:14Director Higher Education: Miguel Ángel Toledo CastellanosEditor sponsor: Pablo Roig VázquezCoordinadora editorial: Marcela I. Rocha MartínezEditora de desarrollo: María Teresa Zapata TerrazasSupervisor de producción: Zeferino García GarcíaTraductores: Víctor Campos OlguínJavier Enríquez BritoRevisión técnica: Carlos Villegas QuezadaBárbaro Jorge Ferro CastroINGENIERÍA DEL SOFTWARE. UN ENFOQUE PRÁCTICOSéptima edición Prohibida la reproducción total o parcial de esta obra, por cualquier medio, sin la autorización escrita del editor.EducaciónDERECHOS RESERVADOS © 2010, 2005, 2002 respecto a la tercera edición en español porMcGRAW-HILL INTERAMERICANA EDITORES, S.A. DE C.V.A Subsidiary of The McGraw-Hill Companies, Inc. Prolongación Paseo de la Reforma 1015, Torre A Piso 17, Colonia Desarrollo Santa Fe, Delegación Álvaro Obregón C.P. 01376, México, D. F. Miembro de la Cámara Nacional de la Industria Editorial Mexicana, Reg. Núm. 736ISBN: 978-607-15-0314-5(ISBN edición anterior: 970-10-5473-3)Traducido de la séptima edición de SOFTWARE ENGINEERING. A PRACTITIONER’S APPROACH.Published by McGraw-Hill, a business unit of The McGraw-Hill Companies, Inc., 1221 Avenue of theAmericas, New York, NY 10020. Copyright © 2010 by The McGraw-Hill Companies, Inc. All rightsreserved.978-0-07-337597-71234567890 109876543210Impreso en México Printed in Mexico00Pressman(i-xxx)prelim.indd iv 2/2/10 11:40:14En recuerdo de mi querido padre,quien vivió 94 años y me enseñó,sobre todo, que la honestidady la integridad eran las mejoresguías para mi viaje por la vida.00Pressman(i-xxx)prelim.indd v 2/2/10 11:40:1400Pressman(i-xxx)prelim.indd vi 2/2/10 11:40:14ACERCA DEL AUTORRoger S. Pressman es una autoridad internacionalmente reconocida en el mejoramientodel proceso del software y en las tecnologías de la ingeniería del mismo. Durante casicuatro décadas ha trabajado como ingeniero de software, gestor, profesor, escritor yconsultor, especializado en temas de ingeniería del software.Como profesional y gestor industrial, el doctor Pressman trabajó en el desarrollo de sistemasCAD/CAM para aplicaciones de ingeniería y fabricación avanzadas. También ha tenido posiciones de responsabilidad en la programación científica y de sistemas.Después de recibir su doctorado en ingeniería por parte de la Universidad de Connecticut,Pressman se dedicó a la academia, donde se convirtió en profesor asociado de la cátedra Bullarden ingeniería de cómputo de la Universidad de Bridgeport, y en director del Centro de Diseño yFabricación Asistidos por Computadora de dicha universidad.En la actualidad, el doctor Pressman es presidente de R. S. Pressman & Associates, Inc., unaempresa de consultoría especializada en métodos y capacitación en ingeniería del software.Trabaja como consultor principal y diseñó y desarrolló Ingeniería del software esencial, un videocurricular completo acerca de ingeniería del software, y Consultor de procesos, un sistema autodirigido para el mejoramiento del proceso de software. Ambos productos los utilizan miles decompañías en todo el mundo. Más recientemente, trabajó en colaboración con EdistaLearning,en India, para desarrollar capacitación abarcadora basada en internet acerca de ingeniería delsoftware.El doctor Pressman ha escrito muchos artículos técnicos, es colaborador regular en revistasperiódicas industriales y autor de siete libros técnicos. Además de Ingeniería del software: unenfoque práctico, es coautor de Web Engineering (McGraw-Hill), uno de los primeros libros enaplicar un conjunto personalizado de principios y prácticas de la ingeniería del software al desarrollo de sistemas y aplicaciones basados en web. También escribió el premiado A Manager’sGuide to Software Engineering (McGraw-Hill); Making Software Engineering Happen (Prenticehall), el primer libro en abordar los problemas administrativos cruciales asociados con el mejoramiento del proceso de software; y Software Shock (Dorset House), un tratamiento que se enfoca en el software y su impacto en los negocios y la sociedad. Pressman ha formado parte delos consejos editoriales de varias publicaciones industriales y durante muchos años fue editorde la columna “Manager” en IEEE Software.Además, es un orador bien conocido, y ha sido el orador principal en muchas conferenciasindustriales importantes. Es miembro de IEEE, y de Tau Beta Pi, Phi Kappa Phi, Eta Kappa Nu yPi Tau Sigma.En el lado personal, Pressman vive en el sur de Florida con su esposa, Bárbara. Atleta de todala vida, sigue siendo un serio jugador de tenis (4.5 en el programa estadounidense de calificaciónde tenis, NTRP) y un golfista con un handicap de un solo dígito. En su tiempo libre escribió dosnovelas, Aymara Bridge y The Puppeteer, y tiene planes para escribir una más.vii00Pressman(i-xxx)prelim.indd vii 2/2/10 11:40:1400Pressman(i-xxx)prelim.indd viii 2/2/10 11:40:15CONTENIDO BREVECAPÍTULO 1 El software y la ingeniería de software 1PARTE UNO EL PROCESO DEL SOFTWARE 25CAPÍTULO 2 Modelos del proceso 26CAPÍTULO 3 Desarrollo ágil 55PARTE DOS MODELADO 81CAPÍTULO 4 Principios que guían la práctica 82CAPÍTULO 5 Comprensión de los requerimientos 101CAPÍTULO 6 Modelado de los requerimientos: escenarios, información y clases de análisis 126CAPÍTULO 7 Modelado de los requerimientos: flujo, comportamiento, patrones y webapps 158CAPÍTULO 8 Conceptos de diseño 183CAPÍTULO 9 Diseño de la arquitectura 206CAPÍTULO 10 Diseño en el nivel de componentes 234CAPÍTULO 11 Diseño de la interfaz de usuario 265CAPÍTULO 12 Diseño basado en patrones 295CAPÍTULO 13 Diseño de webapps 317PARTE TRES ADMINISTRACIÓN DE LA CALIDAD 337CAPÍTULO 14 Conceptos de calidad 338CAPÍTULO 15 Técnicas de revisión 354CAPÍTULO 16 Aseguramiento de la calidad del software 368CAPÍTULO 17 Estrategias de prueba de software 383CAPÍTULO 18 Prueba de aplicaciones convencionales 411CAPÍTULO 19 Prueba de aplicaciones orientadas a objetos 437CAPÍTULO 20 Prueba de aplicaciones web 453CAPÍTULO 21 Modelado y verificación formal 478CAPÍTULO 22 Administración de la configuración del software 501CAPÍTULO 23 Métricas de producto 526PARTE CUATRO ADMINISTRACIÓN DE PROYECTOS DE SOFTWARE 553CAPÍTULO 24 Conceptos de administración de proyecto 554CAPÍTULO 25 Métricas de proceso y de proyecto 571CAPÍTULO 26 Estimación para proyectos de software 593CAPÍTULO 27 Calendarización del proyecto 620CAPÍTULO 28 Administración del riesgo 640CAPÍTULO 29 Mantenimiento y reingeniería 655ix00Pressman(i-xxx)prelim.indd ix 2/2/10 11:40:15PARTE CINCO TEMAS AVANZADOS 675CAPÍTULO 30 Mejoramiento del proceso de software 676CAPÍTULO 31 Tendencias emergentes en ingeniería del software 695CAPÍTULO 32 Comentarios finales 717APÉNDICE 1 Introducción a UML 725APÉNDICE 2 Conceptos orientados a objeto 743REFERENCIAS 751ÍNDICE ANALÍTICO 767x CONTENIDO BREVE00Pressman(i-xxx)prelim.indd x 2/2/10 11:40:15CONTENIDOPrefacio xxvCAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 11.1 La naturaleza del software 21.1.1 Definición de software 31.1.2 Dominios de aplicación del software 61.1.3 Software heredado 81.2 La naturaleza única de las webapps 91.3 Ingeniería de software 101.4 El proceso del software 121.5 La práctica de la ingeniería de software 151.5.1 La esencia de la práctica 151.5.2 Principios generales 161.6 Mitos del software 181.7 Cómo comienza todo 201.8 Resumen 21PROBLEMAS Y PUNTOS POR EVALUAR 21LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 22PARTE UNO EL PROCESO DEL SOFTWARE 25CAPÍTULO 2 MODELOS DEL PROCESO 262.1 Un modelo general de proceso 272.1.1 Definición de actividad estructural 292.1.2 Identificación de un conjunto de tareas 292.1.3 Patrones del proceso 292.2 Evaluación y mejora del proceso 312.3 Modelos de proceso prescriptivo 332.3.1 Modelo de la cascada 332.3.2 Modelos de proceso incremental 352.3.3 Modelos de proceso evolutivo 362.3.4 Modelos concurrentes 402.3.5 Una última palabra acerca de los procesos evolutivos 422.4 Modelos de proceso especializado 432.4.1 Desarrollo basado en componentes 432.4.2 El modelo de métodos formales 442.4.3 Desarrollo de software orientado a aspectos 442.5 El proceso unificado 452.5.1 Breve historia 462.5.2 Fases del proceso unificado 462.6 Modelos del proceso personal y del equipo 482.6.1 Proceso personal del software (PPS) 482.6.2 Proceso del equipo de software (PES) 492.7 Tecnología del proceso 502.8 Producto y proceso 512.9 Resumen 52PROBLEMAS Y PUNTOS POR EVALUAR 53LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 54xi00Pressman(i-xxx)prelim.indd xi 2/2/10 11:40:15xii CONTENIDOCAPÍTULO 3 DESARROLLO ÁGIL 553.1 ¿Qué es la agilidad? 563.2 La agilidad y el costo del cambio 573.3 ¿Qué es un proceso ágil? 583.3.1 Principios de agilidad 583.3.2 La política del desarrollo ágil 593.3.3 Factores humanos 603.4 Programación extrema (XP) 613.4.1 Valores XP 613.4.2 El proceso XP 623.4.3 XP industrial 653.4.4 El debate XP 663.5 Otros modelos ágiles de proceso 673.5.1 Desarrollo adaptativo de software (DAS) 683.5.2 Scrum 693.5.3 Método de desarrollo de sistemas dinámicos (MDSD) 713.5.4 Cristal 723.5.5 Desarrollo impulsado por las características (DIC) 723.5.6 Desarrollo esbelto de software (DES) 733.5.7 Modelado ágil (MA) 743.5.8 El proceso unificado ágil (PUA) 753.6 Conjunto de herramientas para el proceso ágil 763.7 Resumen 77PROBLEMAS Y PUNTOS POR EVALUAR 78LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 79PARTE DOS MODELADO 81CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 824.1 Conocimiento de la ingeniería de software 834.2 Principios fundamentales 834.2.1 Principios que guían el proceso 844.2.2 Principios que guían la práctica 844.3 Principios que guían toda actividad estructural 864.3.1 Principios de comunicación 864.3.2 Principios de planeación 884.3.3 Principios de modelado 904.3.4 Principios de construcción 944.3.5 Principios de despliegue 964.4 Resumen 97PROBLEMAS Y PUNTOS POR EVALUAR 98LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 99CAPÍTULO 5 COMPRENSIÓN DE LOS REQUERIMIENTOS 1015.1 Ingeniería de requerimientos 1025.2 Establecer las bases 1065.2.1 Identificación de los participantes 1065.2.2 Reconocer los múltiples puntos de vista 1075.2.3 Trabajar hacia la colaboración 1075.2.4 Hacer las primeras preguntas 1085.3 Indagación de los requerimientos 1085.3.1 Recabación de los requerimientos en forma colaborativa 1095.3.2 Despliegue de la función de calidad 1115.3.3 Escenarios de uso 1125.3.4 Indagación de los productos del trabajo 11200Pressman(i-xxx)prelim.indd xii 2/2/10 11:40:15CONTENIDO xiii5.4 Desarrollo de casos de uso 1135.5 Elaboración del modelo de los requerimientos 1175.5.1 Elementos del modelo de requerimientos 1185.5.2 Patrones de análisis 1205.6 Requerimientos de las negociaciones 1215.7 Validación de los requerimientos 1225.8 Resumen 123PROBLEMAS Y PUNTOS POR EVALUAR 123LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 124CAPÍTULO 6 MODELADO DE LOS REQUERIMIENTOS: ESCENARIOS,INFORMACIÓN Y CLASES DE ANÁLISIS 1266.1 Análisis de los requerimientos 1276.1.1 Objetivos y filosofía general 1286.1.2 Reglas prácticas del análisis 1286.1.3 Análisis del dominio 1296.1.4 Enfoques del modelado de requerimientos 1306.2 Modelado basado en escenarios 1316.2.1 Creación de un caso preliminar de uso 1326.2.2 Mejora de un caso de uso preliminar 1346.2.3 Escritura de un caso de uso formal 1356.3 Modelos UML que proporcionan el caso de uso 1376.3.1 Desarrollo de un diagrama de actividades 1376.3.2 Diagramas de canal (swimlane) 1386.4 Conceptos de modelado de datos 1396.4.1 Objetos de datos 1396.4.2 Atributos de los datos 1406.4.3 Relaciones 1416.5 Modelado basado en clases 1426.5.1 Identificación de las clases de análisis 1436.5.2 Especificación de atributos 1456.5.3 Definición de las operaciones 1466.5.4 Modelado clase-responsabilidad-colaborador (CRC) 1486.5.5 Asociaciones y dependencias 1526.5.6 Paquetes de análisis 1546.6 Resumen 155PROBLEMAS Y PUNTOS POR EVALUAR 156LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 157CAPÍTULO 7 MODELADO DE LOS REQUERIMIENTOS: FLUJO,COMPORTAMIENTO, PATRONES Y WEBAPPS 1587.1 Requerimientos que modelan las estrategias 1587.2 Modelado orientado al flujo 1597.2.1 Creación de un modelo de flujo de datos 1597.2.2 Creación de un modelo de flujo de control 1627.2.3 La especificación de control 1627.2.4 La especificación del proceso 1637.3 Creación de un modelo de comportamiento 1657.3.1 Identificar los eventos con el caso de uso 1667.3.2 Representaciones de estado 1667.4 Patrones para el modelado de requerimientos 1697.4.1 Descubrimiento de patrones de análisis 1697.4.2 Ejemplo de patrón de requerimientos: Actuador-Sensor 1707.5 Modelado de requerimientos para webapps 1747.5.1 ¿Cuánto análisis es suficiente? 1747.5.2 Entrada del modelado de los requerimientos 17400Pressman(i-xxx)prelim.indd xiii 2/2/10 11:40:15xiv CONTENIDO7.5.3 Salida del modelado de los requerimientos 1757.5.4 Modelo del contenido de las webapps 1767.5.5 Modelo de la interacción para webapps 1777.5.6 Modelo funcional para las webapps 1787.5.7 Modelos de configuración para las webapps 1797.5.8 Modelado de la navegación 1807.6 Resumen 180PROBLEMAS Y PUNTOS POR EVALUAR 181LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 182CAPÍTULO 8 CONCEPTOS DE DISEÑO 1838.1 Diseño en el contexto de la ingeniería de software 1848.2 El proceso de diseño 1868.2.1 Lineamientos y atributos de la calidad del software 1868.2.2 La evolución del diseño del software 1888.3 Conceptos de diseño 1898.3.1 Abstracción 1898.3.2 Arquitectura 1908.3.3 Patrones 1918.3.4 División de problemas 1918.3.5 Modularidad 1918.3.6 Ocultamiento de información 1928.3.7 Independencia funcional 1938.3.8 Refinamiento 1948.3.9 Aspectos 1948.3.10 Rediseño 1958.3.11 Conceptos de diseño orientados a objeto 1958.3.12 Clases de diseño 1968.4 El modelo del diseño 1978.4.1 Elementos del diseño de datos 1998.4.2 Elementos del diseño arquitectónico 1998.4.3 Elementos de diseño de la interfaz 1998.4.4 Elementos del diseño en el nivel de los componentes 2018.4.5 Elementos del diseño del despliegue 2028.5 Resumen 203PROBLEMAS Y PUNTOS POR EVALUAR 203LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 204CAPÍTULO 9 DISEÑO DE LA ARQUITECTURA 2069.1 Arquitectura del software 2079.1.1 ¿Qué es la arquitectura? 2079.1.2 ¿Por qué es importante la arquitectura? 2089.1.3 Descripciones arquitectónicas 2089.1.4 Decisiones arquitectónicas 2099.2 Géneros arquitectónicos 2099.3 Estilos arquitectónicos 2119.3.1 Breve taxonomía de estilos de arquitectura 2139.3.2 Patrones arquitectónicos 2159.3.3 Organización y refinamiento 2169.4 Diseño arquitectónico 2179.4.1 Representación del sistema en contexto 2179.4.2 Definición de arquetipos 2189.4.3 Refinamiento de la arquitectura hacia los componentes 2199.4.4 Descripción de las instancias del sistema 22000Pressman(i-xxx)prelim.indd xiv 2/2/10 11:40:16CONTENIDO xv9.5 Evaluación de los diseños alternativos para la arquitectura 2219.5.1 Método de la negociación para analizar la arquitectura 2229.5.2 Complejidad arquitectónica 2249.5.3 Lenguajes de descripción arquitectónica 2249.6 Mapeo de la arquitectura con el uso del flujo de datos 2259.6.1 Mapeo de transformación 2259.6.2 Refinamiento del diseño arquitectónico 2319.7 Resumen 232PROBLEMAS Y PUNTOS POR EVALUAR 232LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 233CAPÍTULO 10 DISEÑO EN EL NIVEL DE COMPONENTES 23410.1 ¿Qué es un componente? 23510.1.1 Una visión orientada a objetos 23510.1.2 La visión tradicional 23610.1.3 Visión relacionada con el proceso 23910.2 Diseño de componentes basados en clase 23910.2.1 Principios básicos del diseño 23910.2.2 Lineamientos de diseño en el nivel de componentes 24210.2.3 Cohesión 24310.2.4 Acoplamiento 24410.3 Realización del diseño en el nivel de componentes 24610.4 Diseño en el nivel de componentes para webapps 25110.4.1 Diseño del contenido en el nivel de componente 25110.4.2 Diseño de las funciones en el nivel de componentes 25210.5 Diseño de componentes tradicionales 25210.5.1 Notación gráfica de diseño 25310.5.2 Notación del diseño tabular 25410.5.3 Lenguaje de diseño del programa 25510.6 Desarrollo basado en componentes 25610.6.1 Ingeniería del dominio 25710.6.2 Calificación, adaptación y combinación de los componentes 25710.6.3 Análisis y diseño para la reutilización 25910.6.4 Clasificación y recuperación de componentes 26010.7 Resumen 262PROBLEMAS Y PUNTOS POR EVALUAR 263LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 263CAPÍTULO 11 DISEÑO DE LA INTERFAZ DE USUARIO 26511.1 Las reglas doradas 26611.1.1 Dejar el control al usuario 26611.1.2 Reducir la necesidad de que el usuario memorice 26711.1.3 Hacer consistente la interfaz 26811.2 Análisis y diseño de la interfaz de usuario 26911.2.1 Análisis y modelos del diseño de la interfaz 26911.2.2 El proceso 27111.3 Análisis de la interfaz 27211.3.1 Análisis del usuario 27211.3.2 Análisis y modelado de la tarea 27311.3.3 Análisis del contenido de la pantalla 27711.3.4 Análisis del ambiente de trabajo 27811.4 Etapas del diseño de la interfaz 27811.4.1 Aplicación de las etapas de diseño de la interfaz 27911.4.2 Patrones de diseño de la interfaz de usuario 28011.4.3 Aspectos del diseño 28100Pressman(i-xxx)prelim.indd xv 2/2/10 11:40:16xvi CONTENIDO11.5 Diseño de una interfaz para webapps 28411.5.1 Principios y lineamientos del diseño de la interfaz 28511.5.2 Flujo de trabajos para el diseño de la interfaz de webapp 28911.6 Evaluación del diseño 29011.7 Resumen 292PROBLEMAS Y PUNTOS POR EVALUAR 293LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 293CAPÍTULO 12 DISEÑO BASADO EN PATRONES 29512.1 Patrones de diseño 29612.1.1 Clases de patrones 29712.1.2 Estructuras 29912.1.3 Descripción de un patrón 29912.1.4 Lenguajes y repositorios de patrones 30012.2 Diseño de software basado en patrones 30112.2.1 El diseño basado en patrones, en contexto 30112.2.2 Pensar en patrones 30212.2.3 Tareas de diseño 30312.2.4 Construcción de una tabla para organizar el patrón 30512.2.5 Errores comunes en el diseño 30512.3 Patrones arquitectónicos 30612.4 Patrones de diseño en el nivel de componentes 30812.5 Patrones de diseño de la interfaz de usuario 31012.6 Patrones de diseño de webapp 31312.6.1 Centrarse en el diseño 31312.6.2 Granularidad del diseño 31412.7 Resumen 315PROBLEMAS Y PUNTOS POR EVALUAR 315LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 316CAPÍTULO 13 DISEÑO DE WEBAPPS 31713.1 Calidad del diseño de webapps 31813.2 Metas del diseño 32013.3 Pirámide del diseño de webapps 32113.4 Diseño de la interfaz de la webapp 32113.5 Diseño de la estética 32313.5.1 Aspectos de la distribución 32313.5.2 Aspectos del diseño gráfico 32413.6 Diseño del contenido 32413.6.1 Objetos de contenido 32413.6.2 Aspectos de diseño del contenido 32513.7 Diseño arquitectónico 32613.7.1 Arquitectura del contenido 32613.7.2 Arquitectura de las webapps 32813.8 Diseño de la navegación 32913.8.1 Semántica de la navegación 32913.8.2 Sintaxis de navegación 33013.9 Diseño en el nivel de componentes 33113.10 Método de diseño de hipermedios orientado a objetos (MDHOO) 33213.10.1 Diseño conceptual del MDHOO 33213.10.2 Diseño de la navegación para el MDHOO 33313.10.3 Diseño abstracto de la interfaz y su implementación 33313.11 Resumen 334PROBLEMAS Y PUNTOS POR EVALUAR 335LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 33500Pressman(i-xxx)prelim.indd xvi 2/2/10 11:40:16CONTENIDO xviiPARTE TRES ADMINISTRACIÓN DE LA CALIDAD 337CAPÍTULO 14 CONCEPTOS DE CALIDAD 33814.1 ¿Qué es calidad? 33914.2 Calidad del software 34014.2.1 Dimensiones de la calidad de Garvin 34114.2.2 Factores de la calidad de McCall 34214.2.3 Factores de la calidad ISO 9126 34314.2.4 Factores de calidad que se persiguen 34314.2.5 Transición a un punto de vista cuantitativo 34414.3 El dilema de la calidad del software 34514.3.1 Software “suficientemente bueno” 34514.3.2 El costo de la calidad 34614.3.3 Riesgos 34814.3.4 Negligencia y responsabilidad 34814.3.5 Calidad y seguridad 34914.3.6 El efecto de las acciones de la administración 34914.4 Lograr la calidad del software 35014.4.1 Métodos de la ingeniería de software 35014.4.2 Técnicas de administración de proyectos 35014.4.3 Control de calidad 35114.4.4 Aseguramiento de la calidad 35114.5 Resumen 351PROBLEMAS Y PUNTOS POR EVALUAR 352LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 352CAPÍTULO 15 TÉCNICAS DE REVISIÓN 35415.1 Efecto de los defectos del software en el costo 35515.2 Amplificación y eliminación del defecto 35615.3 Métricas de revisión y su empleo 35715.3.1 Análisis de las métricas 35815.3.2 Eficacia del costo de las revisiones 35815.4 Revisiones: espectro de formalidad 35915.5 Revisiones informales 36115.6 Revisiones técnicas formales 36215.6.1 La reunión de revisión 36315.6.2 Reporte y registro de la revisión 36315.6.3 Lineamientos para la revisión 36415.6.4 Revisiones orientadas al muestreo 36515.7 Resumen 366PROBLEMAS Y PUNTOS POR EVALUAR 367LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 367CAPÍTULO 16 ASEGURAMIENTO DE LA CALIDAD DEL SOFTWARE 36816.1 Antecedentes 36916.2 Elementos de aseguramiento de la calidad del software 37016.3 Tareas, metas y métricas del ACS 37116.3.1 Tareas del ACS 37116.3.2 Metas, atributos y métricas 37216.4 Enfoques formales al ACS 37316.5 Aseguramiento estadístico de la calidad del software 37416.5.1 Ejemplo general 37416.5.2 Seis Sigma para la ingeniería de software 37516.6 Confiabilidad del software 37616.6.1 Mediciones de la confiabilidad y disponibilidad 37716.6.2 Seguridad del software 37800Pressman(i-xxx)prelim.indd xvii 2/2/10 11:40:16xviii CONTENIDO16.7 Las normas de calidad ISO 9000 37816.8 El plan de ACS 37916.9 Resumen 380PROBLEMAS Y PUNTOS POR EVALUAR 381LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 381CAPÍTULO 17 ESTRATEGIAS DE PRUEBA DE SOFTWARE 38317.1 Un enfoque estratégico para la prueba de software 38417.1.1 Verificación y validación 38417.1.2 Organización de las pruebas del software 38517.1.3 Estrategia de prueba del software. Visión general 38617.1.4 Criterios para completar las pruebas 38817.2 Aspectos estratégicos 38817.3 Estrategias de prueba para software convencional 38917.3.1 Prueba de unidad 38917.3.2 Pruebas de integración 39117.4 Estrategias de prueba para software orientado a objeto 39717.4.1 Prueba de unidad en el contexto OO 39717.4.2 Prueba de integración en el contexto OO 39817.5 Estrategias de prueba para webapps 39817.6 Pruebas de validación 39917.6.1 Criterios de pruebas de validación 39917.6.2 Revisión de la configuración 40017.6.3 Pruebas alfa y beta 40017.7 Pruebas del sistema 40117.7.1 Pruebas de recuperación 40117.7.2 Pruebas de seguridad 40217.7.3 Pruebas de esfuerzo 40217.7.4 Pruebas de rendimiento 40317.7.5 Pruebas de despliegue 40317.8 El arte de la depuración 40417.8.1 El proceso de depuración 40417.8.2 Consideraciones psicológicas 40517.8.3 Estrategias de depuración 40617.8.4 Corrección del error 40817.9 Resumen 408PROBLEMAS Y PUNTOS POR EVALUAR 409LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 409CAPÍTULO 18 PRUEBA DE APLICACIONES CONVENCIONALES 41118.1 Fundamentos de las pruebas del software 41218.2 Visiones interna y externa de las pruebas 41318.3 Prueba de caja blanca 41418.4 Prueba de ruta básica 41418.4.1 Notación de gráfico o grafo de flujo 41518.4.2 Rutas de programa independientes 41618.4.3 Derivación de casos de prueba 41818.4.4 Matrices de grafo 42018.5 Prueba de la estructura de control 42018.5.1 Prueba de condición 42118.5.2 Prueba de flujo de datos 42118.5.3 Prueba de bucle 42118.6 Pruebas de caja negra 42318.6.1 Métodos de prueba basados en gráficos 42318.6.2 Partición de equivalencia 42500Pressman(i-xxx)prelim.indd xviii 2/2/10 11:40:16CONTENIDO xix18.6.3 Análisis de valor de frontera 42518.6.4 Prueba de arreglo ortogonal 42618.7 Prueba basada en modelo 42918.8 Prueba para entornos, arquitecturas y aplicaciones especializados 42918.8.1 Pruebas de interfaces gráficas de usuario 43018.8.2 Prueba de arquitecturas cliente-servidor 43018.8.3 Documentación de prueba y centros de ayuda 43118.8.4 Prueba para sistemas de tiempo real 43218.9 Patrones para pruebas de software 43318.10 Resumen 434PROBLEMAS Y PUNTOS POR EVALUAR 435LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 436CAPÍTULO 19 PRUEBA DE APLICACIONES ORIENTADAS A OBJETOS 43719.1 Ampliación de la definición de las pruebas 43819.2 Modelos de prueba AOO y DOO 43919.2.1 Exactitud de los modelos AOO y DOO 43919.2.2 Consistencia de los modelos orientados a objetos 43919.3 Estrategias de pruebas orientadas a objetos 44119.3.1 Prueba de unidad en el contexto OO 44119.3.2 Prueba de integración en el contexto OO 44219.3.3 Prueba de validación en un contexto OO 44219.4 Métodos de prueba orientada a objetos 44219.4.1 Implicaciones del diseño de casos de prueba de los conceptos OO 44319.4.2 Aplicabilidad de los métodos convencionales de diseño de casos de prueba 44319.4.3 Prueba basada en fallo 44419.4.4 Casos de prueba y jerarquía de clase 44419.4.5 Diseño de pruebas basadas en escenario 44519.4.6 Pruebas de las estructuras superficial y profunda 44619.5 Métodos de prueba aplicables en el nivel clase 44719.5.1 Prueba aleatoria para clases OO 44719.5.2 Prueba de partición en el nivel de clase 44819.6 Diseño de casos de prueba interclase 44819.6.1 Prueba de clase múltiple 44919.6.2 Pruebas derivadas a partir de modelos de comportamiento 45019.7 Resumen 451PROBLEMAS Y PUNTOS POR EVALUAR 451LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 452CAPÍTULO 20 PRUEBA DE APLICACIONES WEB 45320.1 Conceptos de pruebas para aplicaciones web 45320.1.1 Dimensiones de calidad 45420.1.2 Errores dentro de un entorno de webapp 45520.1.3 Estrategia de las pruebas 45520.1.4 Planificación de pruebas 45620.2 Un panorama del proceso de prueba 45620.3 Prueba de contenido 45720.3.1 Objetivos de la prueba de contenido 45720.3.2 Prueba de base de datos 45820.4 Prueba de interfaz de usuario 46020.4.1 Estrategia de prueba de interfaz 46020.4.2 Prueba de mecanismos de interfaz 46120.4.3 Prueba de la semántica de la interfaz 46320.4.4 Pruebas de usabilidad 46320.4.5 Pruebas de compatibilidad 46520.5 Prueba en el nivel de componente 46600Pressman(i-xxx)prelim.indd xix 2/2/10 11:40:16xx CONTENIDO20.6 Prueba de navegación 46720.6.1 Prueba de sintaxis de navegación 46720.6.2 Prueba de la semántica de navegación 46820.7 Prueba de configuración 46920.7.1 Conflictos en el lado servidor 46920.7.2 Conflictos en el lado cliente 47020.8 Prueba de seguridad 47020.9 Prueba de rendimiento 47120.9.1 Objetivos de la prueba de rendimiento 47220.9.2 Prueba de carga 47220.9.3 Prueba de esfuerzo 47320.10 Resumen 475PROBLEMAS Y PUNTOS POR EVALUAR 475LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 476CAPÍTULO 21 MODELADO Y VERIFICACIÓN FORMAL 47821.1 Estrategia de cuarto limpio 47921.2 Especificación funcional 48021.2.1 Especificación de caja negra 48221.2.2 Especificación de caja de estado 48221.2.3 Especificación de caja clara 48321.3 Diseño de cuarto limpio 48321.3.1 Refinamiento de diseño 48321.3.2 Verificación de diseño 48421.4 Pruebas de cuarto limpio 48521.4.1 Pruebas de uso estadístico 48621.4.2 Certificación 48721.5 Conceptos de métodos formales 48721.6 Aplicación de notación matemática para especificación formal 49021.7 Lenguajes de especificación formal 49221.7.1 Lenguaje de restricción de objeto (OCL) 49221.7.2 El lenguaje de especificación Z 49521.8 Resumen 498PROBLEMAS Y PUNTOS POR EVALUAR 499LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 500CAPÍTULO 22 ADMINISTRACIÓN DE LA CONFIGURACIÓN DEL SOFTWARE 50122.1 Administración de la configuración del software 50222.1.1 Un escenario ACS 50222.1.2 Elementos de un sistema de administración de la configuración 50322.1.3 Líneas de referencia 50422.1.4 Ítems de configuración del software 50522.2 El repositorio ACS 50622.2.1 El papel del repositorio 50622.2.2 Características y contenido generales 50722.2.3 Características ACS 50722.3 El proceso ACS 50822.3.1 Identificación de objetos en la configuración del software 50922.3.2 Control de versión 51022.3.3 Control de cambio 51122.3.4 Auditoría de configuración 51422.3.5 Reporte de estado 51522.4 Administración de la configuración para webapps 51522.4.1 Conflictos dominantes 51622.4.2 Objetos de configuración de webapps 51722.4.3 Administración de contenido 51700Pressman(i-xxx)prelim.indd xx 2/2/10 11:40:17CONTENIDO xxi22.4.4 Administración del cambio 52022.4.5 Control de versión 52222.4.6 Auditoría y reporte 52222.5 Resumen 523PROBLEMAS Y PUNTOS POR EVALUAR 524LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN 525CAPÍTULO 23 MÉTRICAS DE PRODUCTO 52623.1 Marco conceptual para las métricas de producto 52723.1.1 Medidas, métricas e indicadores 52723.1.2 El reto de la métrica de producto 52723.1.3 Principios de medición 52823.1.4 Medición de software orientado a meta 52923.1.5 Atributos de las métricas de software efectivas 53023.2 Métricas para el modelo de requerimientos 53123.2.1 Métrica basada en funciones 53123.2.2 Métricas para calidad de la especificación 53423.3 Métricas para el modelo de diseño 53523.3.1 Métricas del diseño arquitectónico 53523.3.2 Métricas para diseño orientado a objetos 53723.3.3 Métricas orientadas a clase: la suite de métricas CK 53923.3.4 Métricas orientadas a clase: La suite de métricas MOOD 54123.3.5 Métricas OO propuestas por Lorenz y Kidd 54223.3.6 Métricas de diseño en el nivel de componente 54223.3.7 Métricas orientadas a operación 54423.3.8 Métricas de diseño de interfaz de usuario 54523.4 Métricas de diseño para webapps 54523.5 Métricas para código fuente 54723.6 Métricas para pruebas 54823.6.1 Métricas de Halstead aplicadas para probar 54923.6.2 Métricas para pruebas orientadas a objetos 54923.7 Métricas para mantenimiento 55023.8 Resumen 551PROBLEMAS Y PUNTOS POR EVALUAR 551LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 552PARTE CUATRO ADMINISTRACIÓN DE PROYECTOS DE SOFTWARE 553CAPÍTULO 24 CONCEPTOS DE ADMINISTRACIÓN DE PROYECTO 55424.1 El espectro administrativo 55524.1.1 El personal 55524.1.2 El producto 55524.1.3 El proceso 55624.1.4 El proyecto 55624.2 El personal 55624.2.1 Los participantes 55724.2.2 Líderes de equipo 55724.2.3 El equipo de software 55824.2.4 Equipos ágiles 56124.2.5 Conflictos de coordinación y comunicación 56124.3 El producto 56224.3.1 Ámbito del software 56224.3.2 Descomposición del problema 56324.4 El proceso 56324.4.1 Fusión de producto y proceso 56424.4.2 Descomposición del proceso 56400Pressman(i-xxx)prelim.indd xxi 2/2/10 11:40:17xxii CONTENIDO24.5 El proyecto 56624.6 El principio W5HH 56724.7 Prácticas cruciales 56724.8 Resumen 568PROBLEMAS Y PUNTOS POR EVALUAR 569LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 569CAPÍTULO 25 MÉTRICAS DE PROCESO Y DE PROYECTO 57125.1 Métricas en los dominios de proceso y proyecto 57225.1.1 Las métricas del proceso y la mejora del proceso de software 57225.1.2 Métricas de proyecto 57425.2 Medición del software 57525.2.1 Métricas orientadas a tamaño 57625.2.2 Métricas orientadas a función 57725.2.3 Reconciliación de métricas LOC y PF 57725.2.4 Métricas orientadas a objeto 57925.2.5 Métricas orientadas a caso de uso 58025.2.6 Métricas de proyecto webapp 58025.3 Métricas para calidad de software 58225.3.1 Medición de la calidad 58325.3.2 Eficiencia en la remoción del defecto 58425.4 Integración de métricas dentro del proceso de software 58525.4.1 Argumentos para métricas de software 58525.4.2 Establecimiento de una línea de referencia 58625.4.3 Recolección, cálculo y evaluación de métricas 58625.5 Métricas para organizaciones pequeñas 58725.6 Establecimiento de un programa de métricas del software 58825.7 Resumen 590PROBLEMAS Y PUNTOS POR EVALUAR 590LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 591CAPÍTULO 26 ESTIMACIÓN PARA PROYECTOS DE SOFTWARE 59326.1 Observaciones acerca de las estimaciones 59426.2 El proceso de planificación del proyecto 59526.3 Ámbito y factibilidad del software 59526.4 Recursos 59626.4.1 Recursos humanos 59626.4.2 Recursos de software reutilizables 59726.4.3 Recursos ambientales 59826.5 Estimación de proyectos de software 59826.6 Técnicas de descomposición 59926.6.1 Dimensionamiento del software 59926.6.2 Estimación basada en problema 60026.6.3 Un ejemplo de estimación basada en LOC 60126.6.4 Un ejemplo de estimación basada en PF 60226.6.5 Estimación basada en proceso 60426.6.6 Un ejemplo de estimación basada en proceso 60526.6.7 Estimación con casos de uso 60526.6.8 Un ejemplo de estimación basada en caso de uso 60626.6.9 Reconciliación de estimaciones 60726.7 Modelos de estimación empíricos 60826.7.1 La estructura de los modelos de estimación 60826.7.2 El modelo COCOMO II 60926.7.3 La ecuación del software 61000Pressman(i-xxx)prelim.indd xxii 2/2/10 11:40:17CONTENIDO xxiii26.8 Estimación para proyectos orientados a objetos 61126.9 Técnicas de estimación especializadas 61226.9.1 Estimación para desarrollo ágil 61226.9.2 Estimación para webapp 61326.10 La decisión hacer/comprar 61426.10.1 Creación de un árbol de decisión 61526.10.2 Outsourcing 61626.11 Resumen 617PROBLEMAS Y PUNTOS POR EVALUAR 617LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 618CAPÍTULO 27 CALENDARIZACIÓN DEL PROYECTO 62027.1 Conceptos básicos 62127.2 Calendarización del proyecto 62227.2.1 Principios básicos 62327.2.2 Relación entre personal y esfuerzo 62427.2.3 Distribución de esfuerzo 62527.3 Definición de un conjunto de tareas para el proyecto de software 62627.3.1 Un ejemplo de conjunto de tareas 62727.3.2 Refinamiento de acciones de ingeniería del software 62727.4 Definición de una red de tareas 62827.5 Calendarización 62927.5.1 Cronogramas 62927.5.2 Seguimiento del calendario 63127.5.3 Seguimiento del progreso para un proyecto OO 63227.5.4 Calendarización para proyectos webapp 63327.6 Análisis de valor ganado 63527.7 Resumen 637PROBLEMAS Y PUNTOS POR EVALUAR 637LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 638CAPÍTULO 28 ADMINISTRACIÓN DEL RIESGO 64028.1 Estrategias reactivas de riesgo frente a estrategias proactivas de riesgo 64128.2 Riesgos de software 64128.3 Identificación de riesgos 64228.3.1 Valoración del riesgo de proyecto global 64328.3.2 Componentes y promotores de riesgo 64428.4 Proyección del riesgo 64428.4.1 Elaboración de una lista de riesgos 64528.4.2 Valoración de impacto de riesgo 64728.5 Refinamiento del riesgo 64928.6 Mitigación, monitoreo y manejo de riesgo 64928.7 El plan MMMR 65128.8 Resumen 652PROBLEMAS Y PUNTOS POR EVALUAR 653LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 653CAPÍTULO 29 MANTENIMIENTO Y REINGENIERÍA 65529.1 Mantenimiento de software 65629.2 Soportabilidad del software 65729.3 Reingenería 65829.4 Reingeniería de procesos de empresa 65829.4.1 Procesos empresariales 65929.4.2 Un modelo RPE 65900Pressman(i-xxx)prelim.indd xxiii 2/2/10 11:40:17xxiv CONTENIDO29.5 Reingeniería de software 66129.5.1 Un modelo de proceso de reingeniería de software 66129.5.2 Actividades de reingeniería de software 66229.6 Ingeniería inversa 66429.6.1 Ingeniería inversa para comprender datos 66529.6.2 Ingeniería inversa para entender el procesamiento 66629.6.3 Ingeniería inversa de interfaces de usuario 66729.7 Reestructuración 66829.7.1 Reestructuración de código 66829.7.2 Reestructuración de datos 66829.8 Ingeniería hacia adelante 66929.8.1 Ingeniería hacia adelante para arquitecturas cliente-servidor 67029.8.2 Ingeniería hacia adelante para arquitecturas orientadas a objetos 67129.9 Economía de la reingeniería 67129.10 Resumen 672PROBLEMAS Y PUNTOS POR EVALUAR 673LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 674PARTE CINCO TEMAS AVANZADOS 675CAPÍTULO 30 MEJORAMIENTO DEL PROCESO DE SOFTWARE 67630.1 ¿Qué es mps? 67730.1.1 Enfoques del MPS 67730.1.2 Modelos de madurez 67930.1.3 ¿El MPS es para todos? 68030.2 El proceso MPS 68030.2.1 Valoración y análisis de la desviación 68130.2.2 Educación y capacitación 68230.2.3 Selección y justificación 68230.2.4 Instalación/migración 68330.2.5 Evaluación 68330.2.6 Gestión del riesgo para MPS 68430.2.7 Factores de éxito cruciales 68530.3 El CMMI 68530.4 El CMM de personal 68830.5 Otros marcos conceptuales MPS 68930.6 Rendimiento sobre inversión de MPS 69130.7 Tendencias MPS 69230.8 Resumen 693PROBLEMAS Y PUNTOS POR EVALUAR 693LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 694CAPÍTULO 31 TENDENCIAS EMERGENTES EN INGENIERÍA DEL SOFTWARE 69531.1 Evolución tecnológica 69631.2 Observación de las tendencias en ingeniería del software 69731.3 Identificación de “tendencias blandas” 69931.3.1 Administración de la complejidad 70031.3.2 Software de mundo abierto 70131.3.3 Requerimientos emergentes 70131.3.4 La mezcla de talento 70231.3.5 Bloques constructores de software 70331.3.6 Cambio de percepciones de “valor” 70331.3.7 Fuente abierta 70331.4 Direcciones de la tecnología 70431.4.1 Tendencias de proceso 70531.4.2 El gran desafío 70600Pressman(i-xxx)prelim.indd xxiv 2/2/10 11:40:17CONTENIDO xxv31.4.3 Desarrollo colaborativo 70731.4.4 Ingeniería de requerimientos 70831.4.5 Desarrollo de software impulsado por modelo 70931.4.6 Diseño posmoderno 71031.4.7 Desarrollo impulsado por pruebas 71031.5 Tendencias relacionadas con herramientas 71131.5.1 Herramientas que responden a tendencias blandas 71231.5.2 Herramientas que abordan tendencias tecnológicas 71431.6 Resumen 714PROBLEMAS Y PUNTOS POR EVALUAR 715LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALES 715CAPÍTULO 32 COMENTARIOS FINALES 71732.1 La importancia del software-revisión 71832.2 Las personas y la forma en la que construyen sistemas 71832.3 Nuevos modos para representar la información 71932.4 La vista larga 72032.5 La responsabilidad del ingeniero de software 72132.6 Un comentario final 722APÉNDICE 1 Introducción a UML 725APÉNDICE 2 Conceptos orientados a objeto 743REFERENCIAS 751ÍNDICE ANALÍTICO 76700Pressman(i-xxx)prelim.indd xxv 2/2/10 11:40:1700Pressman(i-xxx)prelim.indd xxvi 2/2/10 11:40:18Cuando el software de computadora triunfa (al satisfacer las necesidades de las personasque lo usan, trabajar sin fallos durante largos periodos, será fácil de modificar e inclusomás fácil de usar) puede y debe cambiar las cosas a fin de mejorar. Pero cuando el software fracasa (cuando sus usuarios no están satisfechos, es proclive al error, es difícil de cambiare incluso más difícil de usar) pueden ocurrir, y ocurren, cosas malas. Todo mundo quiere construir software que haga mejor las cosas y que evite las malas que acechan en la sombra de losesfuerzos fallidos. Para triunfar, se necesita disciplina al momento de diseñar y construir elsoftware. Es necesario un enfoque de ingeniería.Han pasado casi tres décadas desde que se escribió la primera edición de este libro. Duranteese tiempo, la ingeniería del software evolucionó desde una oscura idea practicada por un número relativamente pequeño de fanáticos hasta una legítima disciplina de la ingeniería. En laactualidad, se le reconoce como una materia merecedora de investigación seria, estudio concienzudo y debate turbulento. A lo largo de toda la industria, el ingeniero de software sustituyóal programador como el título laboral de preferencia. Los modelos de proceso de software, losmétodos de ingeniería de software y las herramientas del software se adoptaron exitosamentea través de un amplio espectro de segmentos industriales.Aunque los gestores y profesionales reconocen por igual la necesidad de un enfoque delsoftware más disciplinado, continúan debatiendo la forma en la que la disciplina debe aplicarse.Muchos individuos y compañías todavía desarrollan el software de manera fortuita, inclusocuando construyen sistemas para atender las tecnologías más avanzadas de la actualidad. Muchos profesionales y estudiantes no están conscientes de los métodos modernos. Como resultado, la calidad del software que producen es deficiente y ocurren cosas malas. Además, continúa el debate y la controversia en torno de la verdadera naturaleza del enfoque de la ingenieríadel software. El estatus de la ingeniería del software es un estudio en contrastes. Las actitudeshan cambiado, se ha progresado, pero todavía falta mucho por hacer antes de que la disciplinaalcance madurez plena.La séptima edición de Ingeniería del software: un enfoque práctico tiene la intención de funcionar como guía hacia una disciplina de ingeniería que madura. Como las seis ediciones que laprecedieron, la séptima se dirige a estudiantes y profesionales, y conserva su atractivo comoguía para el profesional industrial y como introducción abarcadora para el estudiante en losniveles superiores de pregrado o en el primer año de graduado.La séptima edición es considerablemente más que una simple actualización. El libro se revisóy reestructuró para mejorar el flujo pedagógico y enfatizar nuevos e importantes procesos yprácticas de la ingeniería del software. Además, este texto cuenta con un paquete de complementos, los cuales están disponibles para los profesores que lo adopten. Consulte con el representante de McGraw-Hill local.La séptima edición. Los 32 capítulos de la séptima edición se reorganizaron en cinco partes.Esta organización, que difiere considerablemente de la sexta edición, se realizó para dividirmejor los temas y ayudar a los profesores que tal vez no tengan tiempo para completar todo ellibro en un semestre.La parte 1, El proceso, presenta varias visiones diferentes del proceso de software, consideratodos los modelos de proceso importantes y aborda el debate entre las filosofías de procesoPREFACIOxxvii00Pressman(i-xxx)prelim.indd xxvii 2/2/10 11:40:18prescriptivo y ágil. La parte 2, Modelado, presenta los métodos de análisis y diseño con énfasisen las técnicas orientadas a objeto y al modelado UML. También se considera el diseño basado en patrón y el diseño para aplicaciones web. La parte 3, Gestión de la calidad, presenta losconceptos, procedimientos, técnicas y métodos que permiten a un equipo de software valorarla calidad del software, revisar los productos de trabajo de la ingeniería del software, realizarprocedimientos SQA y aplicar una estrategia y tácticas de prueba efectivas. Además, también seconsidera el modelado formal y los métodos de verificación. La parte 4, Gestión de proyectos desoftware, presenta temas que son relevantes a quienes planean, gestionan y controlan un proyecto de desarrollo de software. La parte 5, Temas avanzados, considera el mejoramiento delproceso de software y las tendencias en la ingeniería del software. Al continuar con la tradiciónde las ediciones pasadas, a lo largo del libro se usa una serie de recuadros para presentar lasexperiencias y tribulaciones de un equipo de software (ficticio) y para proporcionar materialescomplementarios acerca de los métodos y herramientas que son relevantes para los temas delcapítulo. Dos nuevos apéndices proporcionan breves tutoriales acerca del UML y del pensamiento orientado a objeto para quienes no estén familiarizados con estos importantes temas.La organización en cinco partes de la séptima edición permite al profesor “englobar” los temas con base en el tiempo disponible y las necesidades del estudiante. Un curso de todo unsemestre podría construirse en torno de uno o más de las cinco partes. Uno de evaluación deingeniería del software seleccionaría capítulos de las cinco. Uno de ingeniería del software queenfatice el análisis y el diseño elegiría temas de las partes 1 y 2. Un curso de ingeniería del software orientado a pruebas seleccionaría temas de las partes 1 y 3, con una breve incursión en laparte 2. Un “curso administrativo” subrayaría las partes 1 y 4.Reconocimientos. Mi trabajo en las siete ediciones de Ingeniería del software: un enfoque práctico ha sido el proyecto técnico continuo más largo de mi vida. Aun cuando la escritura cesó, lainformación extraída de la literatura técnica continúa asimilándose y organizándose, y las críticas y sugerencias de los lectores en todo el mundo se evalúan y catalogan. Por esta razón,agradezco a los muchos autores de libros, ponencias y artículos (tanto en copia dura como enmedios electrónicos) que me han proporcionado comprensión, ideas y comentarios adicionalesdurante casi 30 años.Agradezco especialmente a Tim Lethbridge, de la Universidad de Ottawa, quien me auxilióen el desarrollo de los ejemplos UML y OCL, y quien desarrolló el estudio de caso que acompañaa este libro, y a Dale Skrien, de Colby College, quien desarrolló el tutorial UML en el apéndice 1.Su asistencia y sus comentarios fueron invaluables. Un agradecimiento especial también paraBruce Maxim, de la Universidad de Michigan-Dearborn, quien me auxilió en el desarrollo degran parte del contenido pedagógico en el sitio web que acompaña a este libro. Finalmente,quiero agradecer a los revisores de la séptima edición: sus comentarios a profundidad y críticasbien pensadas han sido invaluables.Osman Balci,Virginia Tech UniversityMax Fomitchev,Penn State UniversityJerry (Zeyu) Gao,San Jose State UniversityGuillermo Garcia,Universidad Alfonso X MadridPablo Gervas,Universidad Complutense de MadridSK Jain,National Institute of Technology HamirpurSaeed Monemi,Cal Poly PomonaAhmed Salem,California State UniversityVasudeva Varma,IIIT HyderabadEl contenido de la séptima edición de Ingeniería del software: un enfoque práctico fue conformado por profesionales de la industria, profesores universitarios y estudiantes, quienes usaronediciones anteriores del libro y tomaron tiempo para comunicar sus sugerencias, críticas e ideas.xxviii PREFACIO00Pressman(i-xxx)prelim.indd xxviii 2/2/10 11:40:18Mi agradecimiento a cada uno de ustedes. Además, mi reconocimiento personal a nuestrosmuchos clientes industriales en todo el mundo, quienes, ciertamente, me enseñaron tanto o másde lo que yo podría haberles enseñado en algún momento.Conforme las ediciones de este libro evolucionaban, mis hijos, Mathew y Michael, crecieronde niños a hombres. Su madurez, carácter y éxito en el mundo real han sido una inspiraciónpara mí. Nada me ha llenado más de orgullo. Y finalmente, a Bárbara, mi amor y agradecimientopor tolerar las muchísimas horas en la oficina y por alentar todavía otra edición de “el libro”.Roger S. PressmanPREFACIO xxix00Pressman(i-xxx)prelim.indd xxix 2/2/10 11:40:1800Pressman(i-xxx)prelim.indd xxx 2/2/10 11:40:181CAPÍTULO1 EL SOFTWARE Y LA INGENIERÍADE SOFTWARECONCEPTOS CLAVEactividades estructurales . . . . 12actividades sombrilla. . . . . . . 12características del software . . . 3dominios de aplicación . . . . . . . 6ingeniería de software . . . . . 10mitos del software . . . . . . . . 18práctica . . . . . . . . . . . . . . . . 15principios . . . . . . . . . . . . . . . 16proceso del software. . . . . . . 12software heredado . . . . . . . . . 8webapps . . . . . . . . . . . . . . . . 9¿Qué es? El software de computadora es elproducto que construyen los programadoresprofesionales y al que después le dan mantenimiento durante un largo tiempo. Incluye programas que se ejecutan en una computadora de cualquier tamaño y arquitectura, contenido que se presenta amedida de que se ejecutan los programas de cómputo einformación descriptiva tanto en una copia dura como enformatos virtuales que engloban virtualmente a cualesquiera medios electrónicos. La ingeniería de software está formada por un proceso, un conjunto de métodos (prácticas)y un arreglo de herramientas que permite a los profesionales elaborar software de cómputo de alta calidad.¿Quién lo hace? Los ingenieros de software elaboran ydan mantenimiento al software, y virtualmente cada persona lo emplea en el mundo industrializado, ya sea en formadirecta o indirecta.¿Por qué es importante? El software es importante porque afecta a casi todos los aspectos de nuestras vidas y hainvadido nuestro comercio, cultura y actividades cotidianas. La ingeniería de software es importante porque nospermite construir sistemas complejos en un tiempo razonable y con alta calidad.¿Cuáles son los pasos? El software de computadora seconstruye del mismo modo que cualquier producto exitoso,con la aplicación de un proceso ágil y adaptable paraobtener un resultado de mucha calidad, que satisfaga lasnecesidades de las personas que usarán el producto. Enestos pasos se aplica el enfoque de la ingeniería de software.¿Cuál es el producto final? Desde el punto de vista deun ingeniero de software, el producto final es el conjuntode programas, contenido (datos) y otros productos terminados que constituyen el software de computadora. Perodesde la perspectiva del usuario, el producto final es lainformación resultante que de algún modo hace mejor almundo en el que vive.¿Cómo me aseguro de que lo hice bien? Lea el restode este libro, seleccione aquellas ideas que sean aplicablesal software que usted hace y aplíquelas a su trabajo.U N AMIRADARÁPIDATenía la apariencia clásica de un alto ejecutivo de una compañía importante de software—a la mitad de los 40, con las sienes comenzando a encanecer, esbelto y atlético, conojos que penetraban al observador mientras hablaba—. Pero lo que dijo me dejó anonadado. “El software ha muerto”.Pestañeé con sorpresa y sonreí. “Bromeas, ¿verdad? El mundo es dirigido con software y tuempresa se ha beneficiado mucho de ello. ¡No ha muerto! Está vivo y en desarrollo.”Movió su cabeza de manera enfática. “No, está muerto… al menos como lo conocimos.”Me apoyé en el escritorio. “Continúa.”Habló al tiempo que golpeaba en la mesa con énfasis. “El concepto antiguo del software —locompras, lo posees y tu trabajo consiste en administrarlo— está llegando a su fin. Hoy día, conWeb 2.0 y la computación ubicua cada vez más fuerte, vamos a ver una generación de softwarepor completo diferente. Se distribuirá por internet y se verá exactamente como si estuviera instalado en el equipo de cómputo de cada usuario… pero se encontrará en un servidor remoto.”Tuve que estar de acuerdo. “Entonces, tu vida será mucho más sencilla. Tus muchachos notendrán que preocuparse por las cinco diferentes versiones de la misma App que utilizan decenas de miles de usuarios.”Sonrió. “Absolutamente. Sólo la versión más reciente estará en nuestros servidores. Cuandohagamos un cambio o corrección, actualizaremos funcionalidad y contenido a cada usuario.Todos lo tendrán en forma instantánea…”Hice una mueca. “Pero si cometes un error, todos lo tendrán también instantáneamente”.Él se rió entre dientes. “Es verdad, por eso estamos redoblando nuestros esfuerzos para haceruna ingeniería de software aún mejor. El problema es que tenemos que hacerlo ‘rápido’ porqueel mercado se ha acelerado en cada área de aplicación.”01Pressman(001-024).indd 1 14/1/10 13:30:532 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE¿Está muerto realmente el software? Si lo estuviera, usted no estaría leyendo este libro…El software de computadora sigue siendo la tecnología más importante en la escena mundial.Y también es un ejemplo magnífico de la ley de las consecuencias inesperadas. Hace 50 años,nadie hubiera podido predecir que el software se convertiría en una tecnología indispensablepara los negocios, ciencias e ingeniería, ni que permitiría la creación de tecnologías nuevas (porejemplo, ingeniería genética y nanotecnología), la ampliación de tecnologías ya existentes (telecomunicaciones) y el cambio radical de tecnologías antiguas (la industria de la impresión);tampoco que el software sería la fuerza que impulsaría la revolución de las computadoras personales, que productos de software empacados se comprarían en los supermercados, que elsoftware evolucionaría poco a poco de un producto a un servicio cuando compañías de software“sobre pedido” proporcionaran funcionalidad justo a tiempo a través de un navegador web, queuna compañía de software sería más grande y tendría más influencia que casi todas las empresas de la era industrial, que una vasta red llamada internet sería operada con software y evolucionaría y cambiaría todo, desde la investigación en bibliotecas y la compra de productos parael consumidor hasta el discurso político y los hábitos de encuentro de los adultos jóvenes (y notan jóvenes).Nadie pudo prever que habría software incrustado en sistemas de toda clase: de transporte,médicos, de telecomunicaciones, militares, industriales, de entretenimiento, en máquinas deoficina… la lista es casi infinita. Y si usted cree en la ley de las consecuencias inesperadas, haymuchos efectos que aún no podemos predecir.Nadie podía anticipar que millones de programas de computadora tendrían que ser corregidos, adaptados y mejorados a medida que transcurriera el tiempo. Ni que la carga de ejecutarestas actividades de “mantenimiento” absorbería más personas y recursos que todo el trabajoaplicado a la creación de software nuevo.Conforme ha aumentado la importancia del software, la comunidad de programadores hatratado continuamente de desarrollar tecnologías que hagan más fácil, rápida y barata la elaboración de programas de cómputo de alta calidad. Algunas de estas tecnologías se dirigen a undominio específico de aplicaciones (por ejemplo, diseño e implantación de un sitio web), otrasse centran en un dominio tecnológico (sistemas orientados a objetos o programación orientadaa aspectos), otros más tienen una base amplia (sistemas operativos, como Linux). Sin embargo,todavía falta por desarrollarse una tecnología de software que haga todo esto, y hay pocas probabilidades de que surja una en el futuro. A pesar de ello, las personas basan sus trabajos,confort, seguridad, diversiones, decisiones y sus propias vidas en software de computadora. Másvale que esté bien hecho.Este libro presenta una estructura que puede ser utilizada por aquellos que hacen softwarede cómputo —personas que deben hacerlo bien—. La estructura incluye un proceso, un conjuntode métodos y unas herramientas que llamamos ingeniería de software. 1.1 LA NATURALEZA DEL SOFTWAREEn la actualidad, el software tiene un papel dual. Es un producto y al mismo tiempo es el vehículo para entregar un producto. En su forma de producto, brinda el potencial de cómputo incorporado en el hardware de cómputo o, con más amplitud, en una red de computadoras a lasMe recargué en la espalda y coloqué mis manos en mi nuca. “Ya sabes lo que se dice… puedes tenerlo rápido o bien hecho o barato. Escoge dos de estas características…”“Elijo rápido y bien hecho”, dijo mientras comenzaba a levantarse.También me incorporé. “Entonces realmente necesitas ingeniería de software.”“Ya lo sé”, dijo mientras salía. “El problema es que tenemos que llegar a convencer a otrageneración más de técnicos de que así es…”Cita:“Las ideas y los descubrimientostecnológicos son los motores queimpulsan el crecimiento económico.”Wall Street Journal01Pressman(001-024).indd 2 14/1/10 13:30:55CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 3que se accede por medio de un hardware local. Ya sea que resida en un teléfono móvil u opereen el interior de una computadora central, el software es un transformador de información—produce, administra, adquiere, modifica, despliega o transmite información que puede ser tansimple como un solo bit o tan compleja como una presentación con multimedios generada apartir de datos obtenidos de decenas de fuentes independientes—. Como vehículo utilizado paradistribuir el producto, el software actúa como la base para el control de la computadora (sistemas operativos), para la comunicación de información (redes) y para la creación y control deotros programas (herramientas y ambientes de software).El software distribuye el producto más importante de nuestro tiempo: información. Transforma los datos personales (por ejemplo, las transacciones financieras de un individuo) de modoque puedan ser más útiles en un contexto local, administra la información de negocios paramejorar la competitividad, provee una vía para las redes mundiales de información (la internet)y brinda los medios para obtener información en todas sus formas.En el último medio siglo, el papel del software de cómputo ha sufrido un cambio significativo.Las notables mejoras en el funcionamiento del hardware, los profundos cambios en las arquitecturas de computadora, el gran incremento en la memoria y capacidad de almacenamiento, yuna amplia variedad de opciones de entradas y salidas exóticas han propiciado la existencia desistemas basados en computadora más sofisticados y complejos. Cuando un sistema tiene éxito,la sofisticación y complejidad producen resultados deslumbrantes, pero también plantean problemas enormes para aquellos que deben construir sistemas complejos.En la actualidad, la enorme industria del software se ha convertido en un factor dominanteen las economías del mundo industrializado. Equipos de especialistas de software, cada unocentrado en una parte de la tecnología que se requiere para llegar a una aplicación compleja,han reemplazado al programador solitario de los primeros tiempos. A pesar de ello, las preguntas que se hacía aquel programador son las mismas que surgen cuando se construyen sistemasmodernos basados en computadora:1• ¿Por qué se requiere tanto tiempo para terminar el software?• ¿Por qué son tan altos los costos de desarrollo?• ¿Por qué no podemos detectar todos los errores antes de entregar el software a nuestrosclientes?• ¿Por qué dedicamos tanto tiempo y esfuerzo a mantener los programas existentes?• ¿Por qué seguimos con dificultades para medir el avance mientras se desarrolla ymantiene el software?Éstas y muchas otras preguntas, denotan la preocupación sobre el software y la manera enque se desarrolla, preocupación que ha llevado a la adopción de la práctica de la ingeniería delsoftware.1.1.1 Definición de softwareEn la actualidad, la mayoría de profesionales y muchos usuarios tienen la fuerte sensación deque entienden el software. Pero, ¿es así?La descripción que daría un libro de texto sobre software sería más o menos así:El software es: 1) instrucciones (programas de cómputo) que cuando se ejecutan proporcionan lascaracterísticas, función y desempeño buscados; 2) estructuras de datos que permiten que los prograPUNTOCLAVEEl software es tanto un productocomo un vehículo para entregar unproducto.Cita:“El software es un lugar dondese siembran sueños y se cosechan pesadillas, una ciénegaabstracta y mística en la queterribles demonios luchan contrapanaceas mágicas, un mundo dehombres lobo y balas de plata.”Brad J. Cox1 En un excelente libro de ensayos sobre el negocio del software, Tom DeMarco [DeM95] defiende el punto de vistacontrario. Dice: “En lugar de preguntar por qué el software cuesta tanto, necesitamos comenzar a preguntar:¿Qué hemos hecho para hacer posible que el software actual cueste tan poco? La respuesta a esa pregunta nosayudará a continuar el extraordinario nivel de logro que siempre ha distinguido a la industria del software.”¿Cómo se define ? software?01Pressman(001-024).indd 3 14/1/10 13:30:554 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWAREmas manipulen en forma adecuada la información, y 3) información descriptiva tanto en papel comoen formas virtuales que describen la operación y uso de los programas.No hay duda de que podrían darse definiciones más completas.Pero es probable que una definición más formal no mejore de manera apreciable nuestracomprensión. Para asimilar lo anterior, es importante examinar las características del softwareque lo hacen diferente de otros objetos que construyen los seres humanos. El software es elemento de un sistema lógico y no de uno físico. Por tanto, tiene características que difieren considerablemente de las del hardware: 1. El software se desarrolla o modifica con intelecto; no se manufactura en el sentido clásico.Aunque hay algunas similitudes entre el desarrollo de software y la fabricación de hardware, las dos actividades son diferentes en lo fundamental. En ambas, la alta calidad selogra a través de un buen diseño, pero la fase de manufactura del hardware introduceproblemas de calidad que no existen (o que se corrigen con facilidad) en el software.Ambas actividades dependen de personas, pero la relación entre los individuos dedicados y el trabajo logrado es diferente por completo (véase el capítulo 24). Las dos actividades requieren la construcción de un “producto”, pero los enfoques son distintos. Loscostos del software se concentran en la ingeniería. Esto significa que los proyectos desoftware no pueden administrarse como si fueran proyectos de manufactura. 2. El software no se “desgasta”.La figura 1.1 ilustra la tasa de falla del hardware como función del tiempo. La relación,que es frecuente llamar “curva de tina”, indica que el hardware presenta una tasa de fallas relativamente elevada en una etapa temprana de su vida (fallas que con frecuenciason atribuibles a defectos de diseño o manufactura); los defectos se corrigen y la tasade fallas se abate a un nivel estable (muy bajo, por fortuna) durante cierto tiempo. Noobstante, conforme pasa el tiempo, la tasa de fallas aumenta de nuevo a medida que loscomponentes del hardware resienten los efectos acumulativos de suciedad, vibración,abuso, temperaturas extremas y muchos otros inconvenientes ambientales. En pocaspalabras, el hardware comienza a desgastarse.El software no es susceptible a los problemas ambientales que hacen que el hardware se desgaste. Por tanto, en teoría, la curva de la tasa de fallas adopta la forma de la“curva idealizada” que se aprecia en la figura 1.2. Los defectos ocultos ocasionarán taPUNTOCLAVEEl software se modifica con intelecto,no se manufactura.“Mortalidad “Desgaste”infantil”TiempoTasa de fallaFIGURA 1.1Curva de fallasdel hardwarePUNTOCLAVEEl software no se desgasta, pero síse deteriora.01Pressman(001-024).indd 4 14/1/10 13:30:55CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 5sas elevadas de fallas al comienzo de la vida de un programa. Sin embargo, éstas se corrigen y la curva se aplana, como se indica. La curva idealizada es una gran simplificación de los modelos reales de las fallas del software. Aun así, la implicación está clara:el software no se desgasta, ¡pero sí se deteriora!Esta contradicción aparente se entiende mejor si se considera la curva real en la figura 1.2. Durante su vida,2 el software sufrirá cambios. Es probable que cuando éstos serealicen, se introduzcan errores que ocasionen que la curva de tasa de fallas tenga aumentos súbitos, como se ilustra en la “curva real” (véase la figura 1.2). Antes de que lacurva vuelva a su tasa de fallas original de estado estable, surge la solicitud de otrocambio que hace que la curva se dispare otra vez. Poco a poco, el nivel mínimo de latasa de fallas comienza a aumentar: el software se está deteriorando como consecuencia del cambio.Otro aspecto del desgaste ilustra la diferencia entre el hardware y el software.Cuando un componente del hardware se desgasta es sustituido por una refacción. Encambio, no hay refacciones para el software. Cada falla de éste indica un error en el diseño o en el proceso que tradujo el diseño a código ejecutable por la máquina. Entonces, las tareas de mantenimiento del software, que incluyen la satisfacción de peticiones de cambios, involucran una complejidad considerablemente mayor que elmantenimiento del hardware.3. Aunque la industria se mueve hacia la construcción basada en componentes, la mayor partedel software se construye para un uso individualizado.A medida que evoluciona una disciplina de ingeniería, se crea un conjunto de componentes estandarizados para el diseño. Los tornillos estándar y los circuitos integradospreconstruidos son sólo dos de los miles de componentes estándar que utilizan los ingenieros mecánicos y eléctricos conforme diseñan nuevos sistemas. Los componentesreutilizables han sido creados para que el ingeniero pueda concentrarse en los elementos verdaderamente innovadores de un diseño; es decir, en las partes de éste que representan algo nuevo. En el mundo del hardware, volver a usar componentes es una parteSi quiere reducir el deterioro delsoftware, tendrá que mejorar sudiseño (capítulos 8 a 13).CONSEJOTasa de fallasincrementada debidoa efectos colateralesTiempoTasa de fallasCambioCurva realCurva idealizadaFIGURA 1.2Curvas de falladel software2 En realidad, los distintos participantes solicitan cambios desde el momento en que comienza el desarrollo ymucho antes de que se disponga de la primera versión.PUNTOCLAVELos métodos de la ingeniería desoftware llevan a reducir la magnitudde los picos y de la pendiente de lacurva real en la figura 1.2.Cita:“Las ideas son los ladrillos conlos que se construyen las ideas.”Jason Zebehazy01Pressman(001-024).indd 5 14/1/10 13:30:566 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWAREnatural del proceso de ingeniería. En el del software, es algo que apenas ha empezado ahacerse a gran escala.Un componente de software debe diseñarse e implementarse de modo que puedavolverse a usar en muchos programas diferentes. Los modernos componentes reutilizables incorporan tanto los datos como el procesamiento que se les aplica, lo que permiteque el ingeniero de software cree nuevas aplicaciones a partir de partes susceptibles devolverse a usar.3 Por ejemplo, las actuales interfaces interactivas de usuario se construyen con componentes reutilizables que permiten la creación de ventanas gráficas, menús desplegables y una amplia variedad de mecanismos de interacción. Las estructurasde datos y el detalle de procesamiento que se requieren para construir la interfaz estáncontenidos en una librería de componentes reusables para tal fin.1.1.2 Dominios de aplicación del softwareActualmente, hay siete grandes categorías de software de computadora que plantean retoscontinuos a los ingenieros de software:Software de sistemas: conjunto de programas escritos para dar servicio a otros programas. Determinado software de sistemas (por ejemplo, compiladores, editores y herramientas para administrar archivos) procesa estructuras de información complejas pero deterministas.4 Otras aplicaciones de sistemas (por ejemplo, componentes de sistemas operativos,manejadores, software de redes, procesadores de telecomunicaciones) procesan sobre tododatos indeterminados. En cualquier caso, el área de software de sistemas se caracterizapor: gran interacción con el hardware de la computadora, uso intensivo por parte de usuarios múltiples, operación concurrente que requiere la secuenciación, recursos compartidosy administración de un proceso sofisticado, estructuras complejas de datos e interfaces externas múltiples.Software de aplicación: programas aislados que resuelven una necesidad específica denegocios. Las aplicaciones en esta área procesan datos comerciales o técnicos en unaforma que facilita las operaciones de negocios o la toma de decisiones administrativas otécnicas. Además de las aplicaciones convencionales de procesamiento de datos, el software de aplicación se usa para controlar funciones de negocios en tiempo real (por ejemplo, procesamiento de transacciones en punto de venta, control de procesos de manufactura en tiempo real).Software de ingeniería y ciencias: se ha caracterizado por algoritmos “devoradores denúmeros”. Las aplicaciones van de la astronomía a la vulcanología, del análisis de tensiones en automóviles a la dinámica orbital del transbordador espacial, y de la biología molecular a la manufactura automatizada. Sin embargo, las aplicaciones modernas dentro delárea de la ingeniería y las ciencias están abandonando los algoritmos numéricos convencionales. El diseño asistido por computadora, la simulación de sistemas y otras aplicaciones interactivas, han comenzado a hacerse en tiempo real e incluso han tomado características del software de sistemas.Software incrustado: reside dentro de un producto o sistema y se usa para implementar ycontrolar características y funciones para el usuario final y para el sistema en sí. El softwareincrustado ejecuta funciones limitadas y particulares (por ejemplo, control del tablero de unhorno de microondas) o provee una capacidad significativa de funcionamiento y control3 El desarrollo basado en componentes se estudia en el capítulo 10.4 El software es determinista si es posible predecir el orden y momento de las entradas, el procesamiento y lassalidas. El software es no determinista si no pueden predecirse el orden y momento en que ocurren éstos.WebRefEn la dirección shareware.cnet.com se encuentra una de las libreríasmás completas de software compartidoy libre.01Pressman(001-024).indd 6 14/1/10 13:30:56CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 7(funciones digitales en un automóvil, como el control del combustible, del tablero de control y de los sistemas de frenado).Software de línea de productos: es diseñado para proporcionar una capacidad específica para uso de muchos consumidores diferentes. El software de línea de productos secentra en algún mercado limitado y particular (por ejemplo, control del inventario de productos) o se dirige a mercados masivos de consumidores (procesamiento de textos, hojasde cálculo, gráficas por computadora, multimedios, entretenimiento, administración debase de datos y aplicaciones para finanzas personales o de negocios).Aplicaciones web: llamadas “webapps”, esta categoría de software centrado en redesagrupa una amplia gama de aplicaciones. En su forma más sencilla, las webapps son pocomás que un conjunto de archivos de hipertexto vinculados que presentan información conuso de texto y gráficas limitadas. Sin embargo, desde que surgió Web 2.0, las webapps están evolucionando hacia ambientes de cómputo sofisticados que no sólo proveen características aisladas, funciones de cómputo y contenido para el usuario final, sino que tambiénestán integradas con bases de datos corporativas y aplicaciones de negocios.Software de inteligencia artificial: hace uso de algoritmos no numéricos para resolverproblemas complejos que no son fáciles de tratar computacionalmente o con el análisis directo. Las aplicaciones en esta área incluyen robótica, sistemas expertos, reconocimientode patrones (imagen y voz), redes neurales artificiales, demostración de teoremas y juegos.Son millones de ingenieros de software en todo el mundo los que trabajan duro en proyectos desoftware en una o más de estas categorías. En ciertos casos se elaboran sistemas nuevos, peroen muchos otros se corrigen, adaptan y mejoran aplicaciones ya existentes. No es raro que unajoven ingeniera de software trabaje en un programa de mayor edad que la de ella… Las generaciones pasadas de los trabajadores del software dejaron un legado en cada una de las categoríasmencionadas. Por fortuna, la herencia que dejará la actual generación aligerará la carga de losfuturos ingenieros de software. Aun así, nuevos desafíos (capítulo 31) han aparecido en el horizonte.Computación en un mundo abierto: el rápido crecimiento de las redes inalámbricasquizá lleve pronto a la computación verdaderamente ubicua y distribuida. El reto para losingenieros de software será desarrollar software de sistemas y aplicación que permita adispositivos móviles, computadoras personales y sistemas empresariales comunicarse através de redes enormes.Construcción de redes: la red mundial (World Wide Web) se está convirtiendo con rapidez tanto en un motor de computación como en un proveedor de contenido. El desafíopara los ingenieros de software es hacer arquitecturas sencillas (por ejemplo, planeación financiera personal y aplicaciones sofisticadas que proporcionen un beneficio a mercadosobjetivo de usuarios finales en todo el mundo).Fuente abierta: tendencia creciente que da como resultado la distribución de códigofuente para aplicaciones de sistemas (por ejemplo, sistemas operativos, bases de datos yambientes de desarrollo) de modo que mucha gente pueda contribuir a su desarrollo. El desafío para los ingenieros de software es elaborar código fuente que sea autodescriptivo, ytambién, lo que es más importante, desarrollar técnicas que permitirán tanto a los consumidores como a los desarrolladores saber cuáles son los cambios hechos y cómo se manifiestan dentro del software.Es indudable que cada uno de estos nuevos retos obedecerá a la ley de las consecuencias imprevistas y tendrá efectos (para hombres de negocios, ingenieros de software y usuarios finales)que hoy no pueden predecirse. Sin embargo, los ingenieros de software pueden prepararse deCita:“No hay computadora quetenga sentido común.”Marvin MinskyCita:“No siempre puedes predecir,pero siempre puedesprepararte.”Anónimo01Pressman(001-024).indd 7 14/1/10 13:30:578 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWAREsarrollando un proceso que sea ágil y suficientemente adaptable para que acepte los cambiosprofundos en la tecnología y las reglas de los negocios que seguramente surgirán en la décadasiguiente.1.1.3 Software heredadoCientos de miles de programas de cómputo caen en uno de los siete dominios amplios de aplicación que se estudiaron en la subsección anterior. Algunos de ellos son software muy nuevo,disponible para ciertos individuos, industria y gobierno. Pero otros programas son más viejos,en ciertos casos muy viejos.Estos programas antiguos —que es frecuente denominar software heredado— han sido centrode atención y preocupación continuas desde la década de 1960. Dayani-Fard y sus colegas[Day99] describen el software heredado de la manera siguiente:Los sistemas de software heredado […] fueron desarrollados hace varias décadas y han sido modificados de manera continua para que satisfagan los cambios en los requerimientos de los negocios yplataformas de computación. La proliferación de tales sistemas es causa de dolores de cabeza paralas organizaciones grandes, a las que resulta costoso mantenerlos y riesgoso hacerlos evolucionar.Liu y sus colegas [Liu98] amplían esta descripción al hacer notar que “muchos sistemas heredados continúan siendo un apoyo para las funciones básicas del negocio y son ‘indispensables’para éste”. Además, el software heredado se caracteriza por su longevidad e importancia crítica para el negocio.Desafortunadamente, en ocasiones hay otra característica presente en el software heredado:mala calidad.5 Hay veces en las que los sistemas heredados tienen diseños que no son susceptibles de extenderse, código confuso, documentación mala o inexistente, casos y resultados depruebas que nunca se archivaron, una historia de los cambios mal administrada… la lista es muylarga. A pesar de esto, dichos sistemas dan apoyo a las “funciones básicas del negocio y sonindispensables para éste”. ¿Qué hacer?La única respuesta razonable es: hacer nada, al menos hasta que el sistema heredado tengaun cambio significativo. Si el software heredado satisface las necesidades de sus usuarios ycorre de manera confiable, entonces no falla ni necesita repararse. Sin embargo, conforme paseel tiempo será frecuente que los sistemas de software evolucionen por una o varias de las siguientes razones:• El software debe adaptarse para que cumpla las necesidades de los nuevos ambientesdel cómputo y de la tecnología.• El software debe ser mejorado para implementar nuevos requerimientos del negocio.• El software debe ampliarse para que sea operable con otros sistemas o bases de datosmodernos.• La arquitectura del software debe rediseñarse para hacerla viable dentro de un ambientede redes.Cuando ocurren estos modos de evolución, debe hacerse la reingeniería del sistema heredado(capítulo 29) para que sea viable en el futuro. La meta de la ingeniería de software moderna es“desarrollar metodologías que se basen en el concepto de evolución; es decir, el concepto deque los sistemas de software cambian continuamente, que los nuevos sistemas de software se5 En este caso, la calidad se juzga con base en el pensamiento moderno de la ingeniería de software, criterio algoinjusto, ya que algunos conceptos y principios de la ingeniería de software moderna tal vez no hayan sido bienentendidos en la época en que se desarrolló el software heredado.¿Qué hago si encuentroun sistema heredado demala calidad??¿Qué tipos de cambiosse hacen a los sistemasheredados??Todo ingeniero de software debereconocer que el cambio es natural.No trate de evitarlo.CONSEJO01Pressman(001-024).indd 8 14/1/10 13:30:57CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 9desarrollan a partir de los antiguos y […] que todo debe operar entre sí y cooperar con cada unode los demás” [Day99]. 1.2 LA NATURALEZA ÚNICA DE LAS WEBAPPSEn los primeros días de la Red Mundial (entre 1990 y 1995), los sitios web consistían en poco másque un conjunto de archivos de hipertexto vinculados que presentaban la información con elempleo de texto y gráficas limitadas. Al pasar el tiempo, el aumento de HTML por medio deherramientas de desarrollo (XML, Java) permitió a los ingenieros de la web brindar capacidadde cómputo junto con contenido de información. Habían nacido los sistemas y aplicaciones basados en la web6 (denominó a éstas en forma colectiva como webapps). En la actualidad, laswebapps se han convertido en herramientas sofisticadas de cómputo que no sólo proporcionanfunciones aisladas al usuario final, sino que también se han integrado con bases de datos corporativas y aplicaciones de negocios.Como se dijo en la sección 1.1.2, las webapps son una de varias categorías distintas de software. No obstante, podría argumentarse que las webapps son diferentes. Powell [Pow98] sugiereque los sistemas y aplicaciones basados en web “involucran una mezcla entre las publicacionesimpresas y el desarrollo de software, entre la mercadotecnia y la computación, entre las comunicaciones internas y las relaciones exteriores, y entre el arte y la tecnología”. La gran mayoríade webapps presenta los siguientes atributos:Uso intensivo de redes. Una webapp reside en una red y debe atender las necesidadesde una comunidad diversa de clientes. La red permite acceso y comunicación mundiales(por ejemplo, internet) o tiene acceso y comunicación limitados (por ejemplo, una intranetcorporativa).Concurrencia. A la webapp puede acceder un gran número de usuarios a la vez. En muchos casos, los patrones de uso entre los usuarios finales varían mucho.Carga impredecible. El número de usuarios de la webapp cambia en varios órdenes demagnitud de un día a otro. El lunes tal vez la utilicen cien personas, el jueves quizá 10 000usen el sistema.Rendimiento. Si un usuario de la webapp debe esperar demasiado (para entrar, para elprocesamiento por parte del servidor, para el formado y despliegue del lado del cliente), élo ella quizá decidan irse a otra parte.Disponibilidad. Aunque no es razonable esperar una disponibilidad de 100%, es frecuente que los usuarios de webapps populares demanden acceso las 24 horas de los 365días del año. Los usuarios en Australia o Asia quizá demanden acceso en horas en las quelas aplicaciones internas de software tradicionales en Norteamérica no estén en línea porrazones de mantenimiento.Orientadas a los datos. La función principal de muchas webapp es el uso de hipermedios para presentar al usuario final contenido en forma de texto, gráficas, audio y video.Además, las webapps se utilizan en forma común para acceder a información que existe enbases de datos que no son parte integral del ambiente basado en web (por ejemplo, comercio electrónico o aplicaciones financieras).Cita:“Cuando veamos cualquier tipode estabilización, la web sehabrá convertido en algo completamente diferente.”Louis Monier6 En el contexto de este libro, el término aplicación web (webapp) agrupa todo, desde una simple página web queayude al consumidor a calcular el pago del arrendamiento de un automóvil hasta un sitio web integral que proporcione servicios completos de viaje para gente de negocios y vacacionistas. En esta categoría se incluyen sitiosweb completos, funcionalidad especializada dentro de sitios web y aplicaciones de procesamiento de información que residen en internet o en una intranet o extranet.¿Qué característicadiferencia las webappsde otro software??01Pressman(001-024).indd 9 14/1/10 13:30:5810 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWAREContenido sensible. La calidad y naturaleza estética del contenido constituye un rasgoimportante de la calidad de una webapp.Evolución continua. A diferencia del software de aplicación convencional que evoluciona a lo largo de una serie de etapas planeadas y separadas cronológicamente, las aplicaciones web evolucionan en forma continua. No es raro que ciertas webapp (específicamente su contenido) se actualicen minuto a minuto o que su contenido se calcule en cadasolicitud.Inmediatez. Aunque la inmediatez —necesidad apremiante de que el software llegue conrapidez al mercado— es una característica en muchos dominios de aplicación, es frecuenteque las webapps tengan plazos de algunos días o semanas para llegar al mercado.7Seguridad. Debido a que las webapps se encuentran disponibles con el acceso a una red,es difícil o imposible limitar la población de usuarios finales que pueden acceder a la aplicación. Con el fin de proteger el contenido sensible y brindar modos seguros de transmisión de los datos, deben implementarse medidas estrictas de seguridad a través de la infraestructura de apoyo de una webapp y dentro de la aplicación misma.Estética. Parte innegable del atractivo de una webapp es su apariencia y percepción.Cuando se ha diseñado una aplicación para comercializar o vender productos o ideas, laestética tiene tanto que ver con el éxito como el diseño técnico.Podría argumentarse que otras categorías de aplicaciones estudiadas en la sección 1.1.2muestran algunos de los atributos mencionados. Sin embargo, las webapps casi siempre poseentodos ellos. 1.3 INGENIERÍA DE SOFTWARECon objeto de elaborar software listo para enfrentar los retos del siglo XXI, el lector debe aceptaralgunas realidades sencillas:• El software se ha incrustado profundamente en casi todos los aspectos de nuestras vidasy, como consecuencia, el número de personas que tienen interés en las características yfunciones que brinda una aplicación específica8 ha crecido en forma notable. Cuando hade construirse una aplicación nueva o sistema incrustado, deben escucharse muchasopiniones. Y en ocasiones parece que cada una de ellas tiene una idea un poco distintade cuáles características y funciones debiera tener el software. Se concluye que debehacerse un esfuerzo concertado para entender el problema antes de desarrollar una aplicación de software.• Los requerimientos de la tecnología de la información que demandan los individuos,negocios y gobiernos se hacen más complejos con cada año que pasa. En la actualidad,grandes equipos de personas crean programas de cómputo que antes eran elaboradospor un solo individuo. El software sofisticado, que alguna vez se implementó en unambiente de cómputo predecible y autocontenido, hoy en día se halla incrustado en elinterior de todo, desde la electrónica de consumo hasta dispositivos médicos o sistemasde armamento. La complejidad de estos nuevos sistemas y productos basados encomputadora demanda atención cuidadosa a las interacciones de todos los elementosdel sistema. Se concluye que el diseño se ha vuelto una actividad crucial.7 Con las herramientas modernas es posible producir páginas web sofisticadas en unas cuantas horas.8 En una parte posterior de este libro, llamaré a estas personas “participantes”.PUNTOCLAVEEntender el problema antes de daruna solución.PUNTOCLAVEEl diseño es una actividad crucial dela ingeniería de software.01Pressman(001-024).indd 10 14/1/10 13:30:58CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 11• Los individuos, negocios y gobiernos dependen cada vez más del software para tomardecisiones estratégicas y tácticas, así como para sus operaciones y control cotidianos. Siel software falla, las personas y empresas grandes pueden experimentar desde un inconveniente menor hasta fallas catastróficas. Se concluye que el software debe tener altacalidad.• A medida que aumenta el valor percibido de una aplicación específica se incrementa laprobabilidad de que su base de usuarios y longevidad también crezcan. Conforme seextienda su base de usuarios y el tiempo de uso, las demandas para adaptarla ymejorarla también crecerán. Se concluye que el software debe tener facilidad para recibirmantenimiento.Estas realidades simples llevan a una conclusión: debe hacerse ingeniería con el software en todassus formas y a través de todos sus dominios de aplicación. Y esto conduce al tema de este libro: laingeniería de software.Aunque cientos de autores han desarrollado definiciones personales de la ingeniería de software, la propuesta por Fritz Bauer [Nau69] en la conferencia fundamental sobre el tema todavíasirve como base para el análisis:[La ingeniería de software es] el establecimiento y uso de principios fundamentales de la ingenieríacon objeto de desarrollar en forma económica software que sea confiable y que trabaje con eficienciaen máquinas reales.El lector se sentirá tentado de ampliar esta definición.9 Dice poco sobre los aspectos técnicosde la calidad del software; no habla directamente de la necesidad de satisfacer a los consumidores ni de entregar el producto a tiempo; omite mencionar la importancia de la medición y lametrología; no establece la importancia de un proceso eficaz. No obstante, la definición deBauer proporciona una base. ¿Cuáles son los “principios fundamentales de la ingeniería” quepueden aplicarse al desarrollo del software de computadora? ¿Cómo se desarrolla software “enforma económica” y que sea “confiable”? ¿Qué se requiere para crear programas de cómputoque trabajen con “eficiencia”, no en una sino en muchas “máquinas reales” diferentes? Éstas sonlas preguntas que siguen siendo un reto para los ingenieros de software.El IEEE [IEEE93a] ha desarrollado una definición más completa, como sigue:La ingeniería de software es: 1) La aplicación de un enfoque sistemático, disciplinado y cuantificableal desarrollo, operación y mantenimiento de software; es decir, la aplicación de la ingeniería al software. 2) El estudio de enfoques según el punto 1.Aun así, el enfoque “sistemático, disciplinado y cuantificable” aplicado por un equipo desoftware podría ser algo burdo para otro. Se necesita disciplina, pero también adaptabilidad yagilidad.La ingeniería de software es una tecnología con varias capas. Como se aprecia en la figura1.3, cualquier enfoque de ingeniería (incluso la de software) debe basarse en un compromisoorganizacional con la calidad. La administración total de la calidad, Six Sigma y otras filosofíassimilares10 alimentan la cultura de mejora continua, y es esta cultura la que lleva en última instancia al desarrollo de enfoques cada vez más eficaces de la ingeniería de software. El fundamento en el que se apoya la ingeniería de software es el compromiso con la calidad.El fundamento para la ingeniería de software es la capa proceso. El proceso de ingeniería desoftware es el aglutinante que une las capas de la tecnología y permite el desarrollo racional yPUNTOCLAVETanto la calidad como la facilidad derecibir mantenimiento son resultadode un buen diseño.Cita:“Más que una disciplina o cuerpo de conocimientos, ingenieríaes un verbo, una palabra deacción, una forma de abordarun problema.”Scott WhitmirPUNTOCLAVELa ingeniería de software incluye unproceso, métodos y herramientaspara administrar y hacer ingenieríacon el software.¿Cómo se define la ? ingeniería de software? 9 Consulte muchas otras definiciones en www.answers.com/topic/software-engineering#wp-_note-13.10 En el capítulo 14 y toda la parte 3 del libro se estudia la administración de la calidad y los enfoques relacionadoscon ésta.01Pressman(001-024).indd 11 14/1/10 13:30:5912 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWAREoportuno del software de cómputo. El proceso define una estructura que debe establecerse parala obtención eficaz de tecnología de ingeniería de software. El proceso de software forma la basepara el control de la administración de proyectos de software, y establece el contexto en el quese aplican métodos técnicos, se generan productos del trabajo (modelos, documentos, datos,reportes, formatos, etc.), se establecen puntos de referencia, se asegura la calidad y se administra el cambio de manera apropiada.Los métodos de la ingeniería de software proporcionan la experiencia técnica para elaborarsoftware. Incluyen un conjunto amplio de tareas, como comunicación, análisis de los requerimientos, modelación del diseño, construcción del programa, pruebas y apoyo. Los métodos dela ingeniería de software se basan en un conjunto de principios fundamentales que gobiernancada área de la tecnología e incluyen actividades de modelación y otras técnicas descriptivas.Las herramientas de la ingeniería de software proporcionan un apoyo automatizado o semiautomatizado para el proceso y los métodos. Cuando se integran las herramientas de modoque la información creada por una pueda ser utilizada por otra, queda establecido un sistemallamado ingeniería de software asistido por computadora que apoya el desarrollo de software. 1.4 EL PROCESO DEL SOFTWAREUn proceso es un conjunto de actividades, acciones y tareas que se ejecutan cuando va a crearsealgún producto del trabajo. Una actividad busca lograr un objetivo amplio (por ejemplo, comunicación con los participantes) y se desarrolla sin importar el dominio de la aplicación, tamañodel proyecto, complejidad del esfuerzo o grado de rigor con el que se usará la ingeniería desoftware. Una acción (diseño de la arquitectura) es un conjunto de tareas que producen un producto importante del trabajo (por ejemplo, un modelo del diseño de la arquitectura). Una tarease centra en un objetivo pequeño pero bien definido (por ejemplo, realizar una prueba unitaria)que produce un resultado tangible.En el contexto de la ingeniería de software, un proceso no es una prescripción rígida de cómoelaborar software de cómputo. Por el contrario, es un enfoque adaptable que permite que laspersonas que hacen el trabajo (el equipo de software) busquen y elijan el conjunto apropiado deacciones y tareas para el trabajo. Se busca siempre entregar el software en forma oportuna ycon calidad suficiente para satisfacer a quienes patrocinaron su creación y a aquellos que lousarán.La estructura del proceso establece el fundamento para el proceso completo de la ingenieríade software por medio de la identificación de un número pequeño de actividades estructuralesque sean aplicables a todos los proyectos de software, sin importar su tamaño o complejidad.Además, la estructura del proceso incluye un conjunto de actividades sombrilla que son aplicables a través de todo el proceso del software. Una estructura de proceso general para la ingeniería de software consta de cinco actividades:HerramientasCompromiso con la calidadMétodosProcesoFIGURA 1.3Capas de laingeniería desoftwareWebRefCrossTalk es un periódico que dainformación práctica sobre procesos,métodos y herramientas. Se encuentraen www.stsc.hill.af.milCita:“Un proceso define quién hacequé, cuándo y cómo, paraalcanzar cierto objetivo.”Ivar Jacobson, Grady Boochy James Rumbaugh¿Cuáles son loselementos de unproceso de software??01Pressman(001-024).indd 12 14/1/10 13:30:59CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 13Comunicación. Antes de que comience cualquier trabajo técnico, tiene importancia crítica comunicarse y colaborar con el cliente (y con otros participantes).11 Se busca entenderlos objetivos de los participantes respecto del proyecto, y reunir los requerimientos queayuden a definir las características y funciones del software.Planeación. Cualquier viaje complicado se simplifica si existe un mapa. Un proyecto desoftware es un viaje difícil, y la actividad de planeación crea un “mapa” que guía al equipomientras viaja. El mapa —llamado plan del proyecto de software— define el trabajo de ingeniería de software al describir las tareas técnicas por realizar, los riesgos probables, los recursos que se requieren, los productos del trabajo que se obtendrán y una programación delas actividades.Modelado. Ya sea usted diseñador de paisaje, constructor de puentes, ingeniero aeronáutico, carpintero o arquitecto, a diario trabaja con modelos. Crea un “bosquejo” del objeto porhacer a fin de entender el panorama general —cómo se verá arquitectónicamente, cómoajustan entre sí las partes constituyentes y muchas características más—. Si se requiere, refina el bosquejo con más y más detalles en un esfuerzo por comprender mejor el problema ycómo resolverlo. Un ingeniero de software hace lo mismo al crear modelos a fin de entendermejor los requerimientos del software y el diseño que los satisfará.Construcción. Esta actividad combina la generación de código (ya sea manual o automatizada) y las pruebas que se requieren para descubrir errores en éste.Despliegue. El software (como entidad completa o como un incremento parcialmenteterminado) se entrega al consumidor que lo evalúa y que le da retroalimentación, mismaque se basa en dicha evaluación.Estas cinco actividades estructurales genéricas se usan durante el desarrollo de programas pequeños y sencillos, en la creación de aplicaciones web grandes y en la ingeniería de sistemasenormes y complejos basados en computadoras. Los detalles del proceso de software serándistintos en cada caso, pero las actividades estructurales son las mismas.Para muchos proyectos de software, las actividades estructurales se aplican en forma iterativa a medida que avanza el proyecto. Es decir, la comunicación, la planeación, el modelado, la construcción y el despliegue se ejecutan a través de cierto número de repeticionesdel proyecto. Cada iteración produce un incremento del software que da a los participantes unsubconjunto de características y funcionalidad generales del software. Conforme se producecada incremento, el software se hace más y más completo.Las actividades estructurales del proceso de ingeniería de software son complementadas porcierto número de actividades sombrilla. En general, las actividades sombrilla se aplican a lo largode un proyecto de software y ayudan al equipo que lo lleva a cabo a administrar y controlar elavance, la calidad, el cambio y el riesgo. Es común que las actividades sombrilla sean las siguientes:Seguimiento y control del proyecto de software: permite que el equipo de softwareevalúe el progreso comparándolo con el plan del proyecto y tome cualquier acción necesaria para apegarse a la programación de actividades.Administración del riesgo: evalúa los riesgos que puedan afectar el resultado del proyecto o la calidad del producto.¿Cuáles son lascinco actividadesestructurales delproceso??11 Un participante es cualquier persona que tenga algo que ver en el resultado exitoso del proyecto —gerentes delnegocio, usuarios finales, ingenieros de software, personal de apoyo, etc.—. Rob Thomset dice en broma que “unparticipante es una persona que blande una estaca grande y aguda […] Si no vez más lejos que los participantes,ya sabes dónde terminará la estaca”. (N. del T.: Esta nota es un juego de palabras: stake significa estaca y tambiénparte, y stakeholder es el que blande una estaca, pero también un participante.)Cita:“Einstein afirmaba que debíahaber una explicación sencillade la naturaleza porque Dios noes caprichoso o arbitrario. Alingeniero de software no lo conforta una fe parecida. Granparte de la complejidad quedebe doblegar es de origenarbitrario.”Fred BrooksPUNTOCLAVELas actividades sombrilla ocurrena lo largo del proceso de softwarey se centran sobre todo en laadministración, el seguimientoy el control del proyecto.01Pressman(001-024).indd 13 14/1/10 13:31:0014 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWAREAseguramiento de la calidad del software: define y ejecuta las actividades requeridaspara garantizar la calidad del software.Revisiones técnicas: evalúa los productos del trabajo de la ingeniería de software a fin dedescubrir y eliminar errores antes de que se propaguen a la siguiente actividad.Medición: define y reúne mediciones del proceso, proyecto y producto para ayudar alequipo a entregar el software que satisfaga las necesidades de los participantes; puedeusarse junto con todas las demás actividades estructurales y sombrilla.Administración de la configuración del software: administra los efectos del cambio alo largo del proceso del software.Administración de la reutilización: define criterios para volver a usar el producto deltrabajo (incluso los componentes del software) y establece mecanismos para obtener componentes reutilizables.Preparación y producción del producto del trabajo: agrupa las actividades requeridaspara crear productos del trabajo, tales como modelos, documentos, registros, formatos ylistas.Cada una de estas actividades sombrilla se analiza en detalle más adelante.Ya se dijo en esta sección que el proceso de ingeniería de software no es una prescripciónrígida que deba seguir en forma dogmática el equipo que lo crea. Al contrario, debe ser ágil yadaptable (al problema, al proyecto, al equipo y a la cultura organizacional). Por tanto, un proceso adoptado para un proyecto puede ser significativamente distinto de otro adoptado paraotro proyecto. Entre las diferencias se encuentran las siguientes:• Flujo general de las actividades, acciones y tareas, así como de las interdependenciasentre ellas• Grado en el que las acciones y tareas están definidas dentro de cada actividad estructural• Grado en el que se identifican y requieren los productos del trabajo• Forma en la que se aplican las actividades de aseguramiento de la calidad• Manera en la que se realizan las actividades de seguimiento y control del proyecto• Grado general de detalle y rigor con el que se describe el proceso• Grado con el que el cliente y otros participantes se involucran con el proyecto• Nivel de autonomía que se da al equipo de software• Grado con el que son prescritos la organización y los roles del equipoEn la parte 1 de este libro, se examinará el proceso de software con mucho detalle. Los modelosde proceso prescriptivo (capítulo 2) enfatizan la definición, la identificación y la aplicación detalladas de las actividades y tareas del proceso. Su objetivo es mejorar la calidad del sistema,desarrollar proyectos más manejables, hacer más predecibles las fechas de entrega y los costos,y guiar a los equipos de ingenieros de software cuando realizan el trabajo que se requiere paraconstruir un sistema. Desafortunadamente, ha habido casos en los que estos objetivos no se hanlogrado. Si los modelos prescriptivos se aplican en forma dogmática y sin adaptación, puedenincrementar el nivel de burocracia asociada con el desarrollo de sistemas basados en computadora y crear inadvertidamente dificultades para todos los participantes.Los modelos de proceso ágil (capítulo 3) ponen el énfasis en la “agilidad” del proyecto y siguenun conjunto de principios que conducen a un enfoque más informal (pero no menos efectivo,dicen sus defensores) del proceso de software. Por lo general, se dice que estos modelos delproceso son “ágiles” porque acentúan la maniobrabilidad y la adaptabilidad. Son apropiadospara muchos tipos de proyectos y son útiles en particular cuando se hace ingeniería sobre aplicaciones web.PUNTOCLAVELa adaptación del proceso desoftware es esencial para el éxitodel proyecto.¿Qué diferenciasexisten entre losmodelos del proceso??Cita:“Siento que una receta es sóloun tema que una cocinera inteligente ejecuta con una variaciónen cada ocasión.”Madame Benoit¿Qué caracteriza a un ? proceso “ágil”?01Pressman(001-024).indd 14 14/1/10 13:31:00CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 15 1.5 LA PRÁCTICA DE LA INGENIERÍA DE SOFTWAREEn la sección 1.4 se introdujo un modelo general de proceso de software compuesto de un conjunto de actividades que establecen una estructura para la práctica de la ingeniería de software.Las actividades estructurales generales —comunicación, planeación, modelado, construcción y despliegue— y las actividades sombrilla establecen el esqueleto de la arquitectura parael trabajo de ingeniería de software. Pero, ¿cómo entra aquí la práctica de la ingeniería de software? En las secciones que siguen, el lector obtendrá la comprensión básica de los conceptos yprincipios generales que se aplican a las actividades estructurales.121.5.1 La esencia de la prácticaEn un libro clásico, How to Solve It, escrito antes de que existieran las computadoras modernas,George Polya [Pol45] describió la esencia de la solución de problemas y, en consecuencia, laesencia de la práctica de la ingeniería de software: 1. Entender el problema (comunicación y análisis). 2. Planear la solución (modelado y diseño del software). 3. Ejecutar el plan (generación del código). 4. Examinar la exactitud del resultado (probar y asegurar la calidad).En el contexto de la ingeniería de software, estas etapas de sentido común conducen a unaserie de preguntas esenciales [adaptado de Pol45]:Entender el problema. En ocasiones es difícil de admitir, pero la mayor parte de nosotrosadoptamos una actitud de orgullo desmedido cuando se nos presenta un problema. Escuchamospor unos segundos y después pensamos: Claro, sí, entiendo, resolvamos esto. Desafortunadamente, entender no siempre es fácil. Es conveniente dedicar un poco de tiempo a responderalgunas preguntas sencillas:• ¿Quiénes tienen que ver con la solución del problema? Es decir, ¿quiénes son los participantes?• ¿Cuáles son las incógnitas? ¿Cuáles datos, funciones y características se requieren pararesolver el problema en forma apropiada?• ¿Puede fraccionarse el problema? ¿Es posible representarlo con problemas más pequeñosque sean más fáciles de entender?• ¿Es posible representar gráficamente el problema? ¿Puede crearse un modelo de análisis?Planear la solución. Ahora entiende el problema (o es lo que piensa) y no puede esperar paraescribir el código. Antes de hacerlo, cálmese un poco y haga un pequeño diseño:• ¿Ha visto antes problemas similares? ¿Hay patrones reconocibles en una soluciónpotencial? ¿Hay algún software existente que implemente los datos, funciones y características que se requieren?• ¿Ha resuelto un problema similar? Si es así, ¿son reutilizables los elementos de lasolución?• ¿Pueden definirse problemas más pequeños? Si así fuera, ¿hay soluciones evidentes paraéstos?Podría decirse que el enfoque dePolya es simple sentido común. Esverdad. Pero es sorprendente lafrecuencia con la que el sentidocomún es poco común en el mundodel software.CONSEJOWebRefEn la dirección www.literateprogramming.com seencuentran varias citasprovocativas sobre la práctica de laingeniería de software.12 El lector debería volver a consultar las secciones de este capítulo a medida que en el libro se describan en específico los métodos y las actividades sombrilla de la ingeniería de software.Cita:“En la solución de cualquier problema hay un grano dedescubrimiento.”George Polya01Pressman(001-024).indd 15 14/1/10 13:31:0116 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE• ¿Es capaz de representar una solución en una forma que lleve a su implementación eficaz?¿Es posible crear un modelo del diseño?Ejecutar el plan. El diseño que creó sirve como un mapa de carreteras para el sistema quequiere construir. Puede haber desviaciones inesperadas y es posible que descubra un caminomejor a medida que avanza, pero el “plan” le permitirá proceder sin que se pierda.• ¿Se ajusta la solución al plan? ¿El código fuente puede apegarse al modelo del diseño?• ¿Es probable que cada parte componente de la solución sea correcta? ¿El diseño y código sehan revisado o, mejor aún, se han hecho pruebas respecto de la corrección delalgoritmo?Examinar el resultado. No se puede estar seguro de que la solución sea perfecta, pero sí deque se ha diseñado un número suficiente de pruebas para descubrir tantos errores como seaposible.• ¿Puede probarse cada parte componente de la solución? ¿Se ha implementado una estrategia razonable para hacer pruebas?• ¿La solución produce resultados que se apegan a los datos, funciones y características que serequieren? ¿El software se ha validado contra todos los requerimientos de los participantes?No debiera sorprender que gran parte de este enfoque tenga que ver con el sentido común. Enrealidad, es razonable afirmar que un enfoque de sentido común para la ingeniería de softwarehará que nunca se extravíe.1.5.2 Principios generalesEl diccionario define la palabra principio como “una ley importante o suposición que subyace yse requiere en un sistema de pensamiento”. En este libro se analizarán principios en muchosniveles distintos de abstracción. Algunos se centran en la ingeniería de software como un todo,otros consideran una actividad estructural general específica (por ejemplo, comunicación),y otros más se centran en acciones de la ingeniería de software (por ejemplo, diseño de la arquitectura) o en tareas técnicas (escribir un escenario para el uso). Sin importar su nivel deenfoque, los principios lo ayudarán a establecer un conjunto de herramientas mentales para unapráctica sólida de la ingeniería de software. Ésa es la razón de que sean importantes.David Hooker [Hoo96] propuso siete principios que se centran en la práctica de la ingenieríade software como un todo. Se reproducen en los párrafos siguientes:13Primer principio: La razón de que exista todoUn sistema de software existe por una razón: dar valor a sus usuarios. Todas las decisionesdeben tomarse teniendo esto en mente. Antes de especificar un requerimiento del sistema,antes de notar la funcionalidad de una parte de él, antes de determinar las plataformas delhardware o desarrollar procesos, plantéese preguntas tales como: “¿Esto agrega valor real alsistema?” Si la respuesta es “no”, entonces no lo haga. Todos los demás principios apoyan aéste.Segundo principio: MSE (Mantenlo sencillo, estúpido…)El diseño de software no es un proceso caprichoso. Hay muchos factores por considerar encualquier actividad de diseño. Todo diseño debe ser tan simple como sea posible, pero no más.13 Reproducido con permiso del autor [Hoo96]. Hooker define algunos patrones para estos principios en http://c2.com/cgi/wiki?SevenPrinciplesOfSoftwareDevelopment.Antes de comenzar un proyecto desoftware, asegúrese de que elsoftware tenga un propósito para elnegocio y que los usuarios percibenvalor en él.CONSEJO01Pressman(001-024).indd 16 14/1/10 13:31:01CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 17Esto facilita conseguir un sistema que sea comprendido más fácilmente y que sea susceptiblede recibir mantenimiento, lo que no quiere decir que en nombre de la simplicidad deban descartarse características o hasta rasgos internos. En realidad, los diseños más elegantes por logeneral son los más simples. Simple tampoco significa “rápido y sucio”. La verdad es que confrecuencia se requiere mucha reflexión y trabajo con iteraciones múltiples para poder simplificar. La recompensa es un software más fácil de mantener y menos propenso al error.Tercer principio: Mantener la visiónUna visión clara es esencial para el éxito de un proyecto de software. Sin ella, casi infaliblemente el proyecto terminará siendo un ser “con dos [o más mentes]”. Sin integridad conceptual, un sistema está amenazado de convertirse en una urdimbre de diseños incompatiblesunidos por tornillos del tipo equivocado […] Comprometer la visión de la arquitectura de unsistema de software debilita y, finalmente hará que colapsen incluso los sistemas bien diseñados. Tener un arquitecto que pueda para mantener la visión y que obligue a su cumplimientogarantiza un proyecto de software muy exitoso.Cuarto principio: Otros consumirán lo que usted produceRara vez se construye en el vacío un sistema de software con fortaleza industrial. En unmodo u otro, alguien más lo usará, mantendrá, documentará o, de alguna forma, dependeráde su capacidad para entender el sistema. Así que siempre establezca especificaciones, diseñe eimplemente con la seguridad de que alguien más tendrá que entender lo que usted haga. La audiencia para cualquier producto de desarrollo de software es potencialmente grande. Elaboreespecificaciones con la mirada puesta en los usuarios. Diseñe con los implementadores enmente. Codifique pensando en aquellos que deben dar mantenimiento y ampliar el sistema.Alguien debe depurar el código que usted escriba, y eso lo hace usuario de su código. Hacer sutrabajo más fácil agrega valor al sistema.Quinto principio: Ábrase al futuroUn sistema con larga vida útil tiene más valor. En los ambientes de cómputo actuales,donde las especificaciones cambian de un momento a otro y las plataformas de hardwarequedan obsoletas con sólo unos meses de edad, es común que la vida útil del software semida en meses y no en años. Sin embargo, los sistemas de software con verdadera “fortalezaindustrial” deben durar mucho más tiempo. Para tener éxito en esto, los sistemas deben serfáciles de adaptar a ésos y otros cambios. Los sistemas que lo logran son los que se diseñaronpara ello desde el principio. Nunca diseñe sobre algo iniciado. Siempre pregunte: “¿qué pasasi…?” y prepárese para todas las respuestas posibles mediante la creación de sistemas que resuelvan el problema general, no sólo uno específico.14 Es muy posible que esto lleve a volver ausar un sistema completo.Sexto principio: Planee por anticipado la reutilizaciónLa reutilización ahorra tiempo y esfuerzo.15 Al desarrollar un sistema de software, lograr unalto nivel de reutilización es quizá la meta más difícil de lograr. La reutilización del código yde los diseños se ha reconocido como uno de los mayores beneficios de usar tecnologíasorientadas a objetos. Sin embargo, la recuperación de esta inversión no es automática. Parareforzar las posibilidades de la reutilización que da la programación orientada a objetos [o laCita:“Hay cierta majestad en la sencillez, que es con mucho todo loque adorna al ingenio.”Papa Alejandro(1688-1744)PUNTOCLAVESi el software tiene valor, cambiarádurante su vida útil. Por esa razón,debe construirse de forma que seafácil darle mantenimiento.14 Es peligroso llevar este consejo a los extremos. Diseñar para resolver “el problema general” en ocasiones requierecompromisos de rendimiento y puede volver ineficientes las soluciones específicas.15 Aunque esto es verdad para aquellos que reutilizan software en proyectos futuros, volver a usar puede ser caropara quienes deben diseñar y elaborar componentes reutilizables. Los estudios indican que diseñar y construircomponentes reutilizables llega a costar entre 25 y 200% más que el software buscado. En ciertos casos no sejustifica la diferencia de costos.01Pressman(001-024).indd 17 14/1/10 13:31:0218 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWAREconvencional], se requiere reflexión y planeación. Hay muchas técnicas para incluir la reutilización en cada nivel del proceso de desarrollo del sistema… La planeación anticipada en buscade la reutilización disminuye el costo e incrementa el valor tanto de los componentes reutilizablescomo de los sistemas en los que se incorpora.Séptimo principio: ¡Piense!Este último principio es tal vez el que más se pasa por alto. Pensar en todo con claridad antes de emprender la acción casi siempre produce mejores resultados. Cuando se piensa en algoes más probable que se haga bien. Asimismo, también se gana conocimiento al pensar cómovolver a hacerlo bien. Si usted piensa en algo y aun así lo hace mal, eso se convierte en unaexperiencia valiosa. Un efecto colateral de pensar es aprender a reconocer cuando no se sabealgo, punto en el que se puede investigar la respuesta. Cuando en un sistema se han puestopensamientos claros, el valor se manifiesta. La aplicación de los primeros seis principios requiere pensar con intensidad, por lo que las recompensas potenciales son enormes.Si todo ingeniero y equipo de software tan sólo siguiera los siete principios de Hooker, se eliminarían muchas de las dificultades que se experimentan al construir sistemas complejos basadosen computadora. 1.6 MITOS DEL SOFTWARELos mitos del software —creencias erróneas sobre éste y sobre el proceso que se utiliza paraobtenerlo— se remontan a los primeros días de la computación. Los mitos tienen cierto númerode atributos que los hacen insidiosos. Por ejemplo, parecen enunciados razonables de hechos(a veces contienen elementos de verdad), tienen una sensación intuitiva y es frecuente que losmanifiesten profesionales experimentados que “conocen la historia”.En la actualidad, la mayoría de profesionales de la ingeniería de software reconocen los mitos como lo que son: actitudes equivocadas que han ocasionado serios problemas a los administradores y a los trabajadores por igual. Sin embargo, las actitudes y hábitos antiguos sondifíciles de modificar, y persisten algunos remanentes de los mitos del software.Mitos de la administración. Los gerentes que tienen responsabilidades en el software, comolos de otras disciplinas, con frecuencia se hallan bajo presión para cumplir el presupuesto, mantener la programación de actividades sin desvíos y mejorar la calidad. Así como la persona quese ahoga se agarra de un clavo ardiente, no es raro que un gerente de software sostenga lacreencia en un mito del software si eso disminuye la presión a que está sujeto (incluso de manera temporal).Mito: Tenemos un libro lleno de estándares y procedimientos para elaborar software.¿No le dará a mi personal todo lo que necesita saber?Realidad: Tal vez exista el libro de estándares, pero ¿se utiliza? ¿Saben de su existencialos trabajadores del software? ¿Refleja la práctica moderna de la ingenieríade software? ¿Es completo? ¿Es adaptable? ¿Está dirigido a mejorar la entrega a tiempo y también se centra en la calidad? En muchos casos, la respuesta a todas estas preguntas es “no”.Mito: Si nos atrasamos, podemos agregar más programadores y ponernos al corriente(en ocasiones, a esto se le llama “concepto de la horda de mongoles”).Realidad: El desarrollo del software no es un proceso mecánico similar a la manufactura. En palabras de Brooks [Bro95]: “agregar personal a un proyecto de software atrasado lo atrasará más”. Al principio, esta afirmación parece ir contrala intuición. Sin embargo, a medida que se agregan personas, las que ya seCita:“En ausencia de estándares significativos, una industria nuevacomo la del software dependesólo del folklore.”Tom DeMarcoWebRefLa Software Project Managers Network(Red de Gerentes de Proyectos deSoftware), en www.spmn.com, loayuda a eliminar éstos y otros mitos.01Pressman(001-024).indd 18 14/1/10 13:31:02CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 19encontraban trabajando deben dedicar tiempo para enseñar a los recién llegados, lo que disminuye la cantidad de tiempo dedicada al esfuerzo de desarrollo productivo. Pueden agregarse individuos, pero sólo en forma planeaday bien coordinada.Mito: Si decido subcontratar el proyecto de software a un tercero, puedo descansar ydejar que esa compañía lo elabore.Realidad: Si una organización no comprende cómo administrar y controlar proyectos desoftware internamente, de manera invariable tendrá dificultades cuando subcontrate proyectos de software.Mitos del cliente. El cliente que requiere software de computadora puede ser la persona enel escritorio de al lado, un grupo técnico en el piso inferior, el departamento de mercadotecniay ventas, o una compañía externa que solicita software mediante un contrato. En muchos casos,el cliente sostiene mitos sobre el software porque los gerentes y profesionales de éste hacenpoco para corregir la mala información. Los mitos generan falsas expectativas (por parte delcliente) y, en última instancia, la insatisfacción con el desarrollador.Mito: Para comenzar a escribir programas, es suficiente el enunciado general de losobjetivos —podremos entrar en detalles más adelante.Realidad: Aunque no siempre es posible tener el enunciado exhaustivo y estable de losrequerimientos, un “planteamiento de objetivos” ambiguo es una receta parael desastre. Los requerimientos que no son ambiguos (que por lo general seobtienen en forma iterativa) se desarrollan sólo por medio de una comunicación eficaz y continua entre el cliente y el desarrollador.Mito: Los requerimientos del software cambian continuamente, pero el cambio se asimila con facilidad debido a que el software es flexible.Realidad: Es verdad que los requerimientos del software cambian, pero el efecto quelos cambios tienen varía según la época en la que se introducen. Cuando sesolicitan al principio cambios en los requerimientos (antes de que haya comenzado el diseño o la elaboración de código), el efecto sobre el costo es relativamente pequeño.16 Sin embargo, conforme pasa el tiempo, el costo aumenta con rapidez: los recursos ya se han comprometido, se ha establecidola estructura del diseño y el cambio ocasiona perturbaciones que exigen recursos adicionales y modificaciones importantes del diseño.Mitos del profesional. Los mitos que aún sostienen los trabajadores del software han sidoalimentados por más de 50 años de cultura de programación. Durante los primeros días, la programación se veía como una forma del arte. Es difícil que mueran los hábitos y actitudes arraigados.Mito: Una vez que escribimos el programa y hacemos que funcione, nuestro trabajoha terminado.Realidad: Alguien dijo alguna vez que “entre más pronto se comience a ‘escribir el código’, más tiempo tomará hacer que funcione”. Los datos de la industria indican que entre 60 y 80% de todo el esfuerzo dedicado al software ocurrirádespués de entregarlo al cliente por primera vez.Mito: Hasta que no se haga “correr” el programa, no hay manera de evaluar su calidad.16 Muchos ingenieros de software han adoptado un enfoque “ágil” que asimila los cambios en forma gradual ycreciente, con lo que controlan su efecto y costo. Los métodos ágiles se estudian en el capítulo 3.Trabaje muy duro para entender quées lo que tiene que hacer antes deempezar. Quizás no puedadesarrollarlo a detalle, pero entremás sepa, menor será el riesgo quetome.CONSEJOSiempre que piense que no haytiempo para la ingeniería desoftware, pregúntese: “¿tendremostiempo de hacerlo otra vez?”.CONSEJO01Pressman(001-024).indd 19 14/1/10 13:31:0220 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARERealidad: Uno de los mecanismos más eficaces de asegurar la calidad del softwarepuede aplicarse desde la concepción del proyecto: la revisión técnica. Las revisiones del software (descritas en el capítulo 15) son un “filtro de la calidad”que se ha revelado más eficaz que las pruebas para encontrar ciertas clasesde defectos de software.Mito: El único producto del trabajo que se entrega en un proyecto exitoso es el programa que funciona.Realidad: Un programa que funciona sólo es una parte de una configuración de software que incluye muchos elementos. Son varios los productos terminados(modelos, documentos, planes) que proporcionan la base de la ingenieríaexitosa y, lo más importante, que guían el apoyo para el software.Mito: La ingeniería de software hará que generemos documentación voluminosa e innecesaria, e invariablemente nos retrasará.Realidad: La ingeniería de software no consiste en producir documentos. Se trata decrear un producto de calidad. La mejor calidad conduce a menos repeticiones, lo que da como resultado tiempos de entrega más cortos.Muchos profesionales del software reconocen la falacia de los mitos mencionados. Es lamentable que las actitudes y métodos habituales nutran la administración y las prácticas técnicasdeficientes, aun cuando la realidad dicta un enfoque mejor. El primer paso hacia la formulaciónde soluciones prácticas para la ingeniería de software es el reconocimiento de las realidades eneste campo. 1.7 CÓMO COMIENZA TODOTodo proyecto de software se desencadena por alguna necesidad de negocios: la de corregir undefecto en una aplicación existente, la de adaptar un “sistema heredado” a un ambiente de negocios cambiante, la de ampliar las funciones y características de una aplicación ya existente ola necesidad de crear un producto, servicio o sistema nuevo.Al comenzar un proyecto de software, es frecuente que las necesidades del negocio se expresen de manera informal como parte de una simple conversación. La plática que se presentaen el recuadro que sigue es muy común.Cómo se inicia un proyectoLa escena: Sala de juntas en CPI Corporation,empresa (ficticia) que manufactura productos deconsumo para uso doméstico y comercial.Participantes: Mal Golden, alto directivo de desarrollo de productos; Lisa Pérez, gerente comercial; Lee Warren, gerente de ingeniería; Joe Camalleri, VP ejecutivo, desarrollo de negocios.La conversación:Joe: Oye, Lee, ¿qué es eso que oí acerca de que tu gente va a desarrollar no sé qué? ¿Una caja inalámbrica universal general?Lee: Es sensacional… más o menos del tamaño de una caja de cerillos pequeña… podemos conectarla a sensores de todo tipo, unacámara digital… a cualquier cosa. Usa el protocolo 802.11g inalámbrico. Permite el acceso a la salida de dispositivos sin cables.Pensamos que llevará a toda una nueva generación de productos.Joe: ¿Estás de acuerdo, Mal?Mal: Sí. En realidad, con las ventas tan planas que hemos tenidoeste año necesitamos algo nuevo. Lisa y yo hemos hecho algo deinvestigación del mercado y pensamos que tenemos una línea deproductos que podría ser algo grande.CASASEGURA1717 El proyecto CasaSegura se usará en todo el libro para ilustrar los entretelones de un equipo de proyecto que elabora un producto de software. La compañía, el proyecto y las personas son ficticias, pero las situaciones y problemas son reales.01Pressman(001-024).indd 20 14/1/10 13:31:03CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 21Con excepción de una referencia casual, el software no se mencionó en la conversación. Y,sin embargo, es lo que hará triunfar o fracasar la línea de productos CasaSegura. El esfuerzo deingeniería tendrá éxito sólo si también lo tiene el software de CasaSegura. El mercado aceptaráel producto sólo si el software incrustado en éste satisface las necesidades del cliente (aún noestablecidas). En muchos de los capítulos siguientes continuaremos el avance de la ingenieríadel software en CasaSegura. 1.8 RESUMENEl software es un elemento clave en la evolución de sistemas y productos basados en computadoras, y una de las tecnologías más importantes en todo el mundo. En los últimos 50 años, elsoftware ha pasado de ser la solución de un problema especializado y herramienta de análisisde la información a una industria en sí misma. No obstante, aún hay problemas para desarrollarsoftware de alta calidad a tiempo y dentro del presupuesto asignado.El software —programas, datos e información descriptiva— se dirige a una gama amplia detecnología y campos de aplicación. El software heredado sigue planteando retos especiales aquienes deben darle mantenimiento.Los sistemas y aplicaciones basados en web han evolucionado de simples conjuntos de contenido de información a sistemas sofisticados que presentan una funcionalidad compleja ycontenido en multimedios. Aunque dichas webapps tienen características y requerimientos únicos, son software.La ingeniería de software incluye procesos, métodos y herramientas que permiten elaborar atiempo y con calidad sistemas complejos basados en computadoras. El proceso de softwareincorpora cinco actividades estructurales: comunicación, planeación, modelado, construccióny despliegue que son aplicables a todos los proyectos de software. La práctica de la ingenieríade software es una actividad para resolver problemas, que sigue un conjunto de principios fundamentales.Muchos mitos del software todavía hacen que administradores y trabajadores se equivoquen,aun cuando ha aumentado nuestro conocimiento colectivo del software y las tecnologías requeridas para elaborarlo. Conforme el lector aprenda más sobre ingeniería de software, comenzaráa entender por qué deben rebatirse estos mitos cada vez que surjan. PROBLEMAS Y PUNTOS POR EVALUAR1.1. Dé al menos cinco ejemplos de la forma en que se aplica la ley de las consecuencias imprevistas alsoftware de cómputo.Joe: ¿Cuán grande… tanto como el renglón de utilidades?Mal (que evita el compromiso directo): Cuéntale nuestraidea, Lisa.Lisa: Es toda una nueva generación que hemos llamado “productospara la administración del hogar”. Le dimos el nombre de CasaSegura. Usan la nueva interfaz inalámbrica, proporcionan a los dueños de viviendas o pequeños negocios un sistema controlado por suPC —seguridad del hogar, vigilancia, control de aparatos y equipos—, tú sabes, apaga el aire acondicionado cuando sales de casa,esa clase de cosas.Lee (dando un brinco): La oficina de ingeniería hizo un estudiode factibilidad técnica de esta idea, Joe. Es algo realizable con uncosto bajo de manufactura. La mayor parte del hardware es delínea. Queda pendiente el software, pero no es algo que no podamos hacer.Joe: Interesante. Pero pregunté sobre las utilidades.Mal: Las PC han penetrado a 70 por ciento de los hogares de Estados Unidos. Si lo vendemos en el precio correcto, podría ser unaaplicación sensacional. Nadie tiene nuestra caja inalámbrica…somos dueños. Nos adelantaremos dos años a la competencia. ¿Lasganancias? Quizá tanto como 30 a 40 millones de dólares en elsegundo año.Joe (sonriente): Llevemos esto al siguiente nivel. Estoy interesado.01Pressman(001-024).indd 21 14/1/10 13:31:0322 CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE1.2. Diga algunos ejemplos (tanto positivos como negativos) que indiquen el efecto del software en nuestrasociedad.1.3. Desarrolle sus propias respuestas a las cinco preguntas planteadas al principio de la sección 1.1. Analícelas con sus compañeros estudiantes.1.4. Muchas aplicaciones modernas cambian con frecuencia, antes de que se presenten al usuario final ydespués de que la primera versión ha entrado en uso. Sugiera algunos modos de elaborar software paradetener el deterioro que produce el cambio.1.5. Considere las siete categorías de software presentadas en la sección 1.1.2. ¿Piensa que puede aplicarsea cada una el mismo enfoque de ingeniería de software? Explique su respuesta.1.6. La figura 1.3 muestra las tres capas de la ingeniería de software arriba de otra llamada “compromisocon la calidad”. Esto implica un programa de calidad organizacional como el enfoque de la administracióntotal de la calidad. Haga un poco de investigación y desarrolle los lineamientos de los elementos clave de unprograma para la administración de la calidad.1.7. ¿Es aplicable la ingeniería de software cuando se elaboran webapps? Si es así, ¿cómo puede modificarsepara que asimile las características únicas de éstas?1.8. A medida que el software gana ubicuidad, los riesgos para el público (debidos a programas defectuosos)se convierten en motivo de preocupación significativa. Desarrolle un escenario catastrófico pero realista enel que la falla de un programa de cómputo pudiera ocasionar un gran daño (económico o humano).1.9. Describa con sus propias palabras una estructura de proceso. Cuando se dice que las actividades estructurales son aplicables a todos los proyectos, ¿significa que se realizan las mismas tareas en todos losproyectos sin que importe su tamaño y complejidad? Explique su respuesta.1.10. Las actividades sombrilla ocurren a través de todo el proceso del software. ¿Piensa usted que son aplicables por igual a través del proceso, o que algunas se concentran en una o más actividades estructurales?1.11. Agregue dos mitos adicionales a la lista presentada en la sección 1.6. También diga la realidad queacompaña al mito. LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓN18Hay literalmente miles de libros escritos sobre software de cómputo. La gran mayoría analiza lenguajes deprogramación o aplicaciones de software, pero algunos estudian al software en sí mismo. Pressman y Herron(Software Shock, Dorset House, 1991) presentaron un estudio temprano (dirigido a las personas comunes)sobre el software y la forma en la que lo elaboran los profesionales. El libro de Negroponte que se convirtióen un éxito de ventas (Being Digital, Alfred A. Knopf, Inc., 1995) describe el panorama de la computación ysu efecto general en el siglo XXI. DeMarco (Why Does Software Cost So Much?, Dorset House, 1995) ha producido varios ensayos amenos y profundos sobre el software y el proceso con el que se elabora.Minasi (The Software Conspiracy: Why Software Companies Put out Faulty Products, How They Can Hurt You,and What You Can Do, McGraw-Hill, 2000) afirma que el “flagelo moderno” de los errores en el software puedeeliminarse y sugiere formas de lograrlo. Compaine (Digital Divide: Facing A Crisis or Creating a Myth, MIT Press,2001) asegura que la “división” entre aquellos que tienen acceso a recursos de la información (por ejemplo,la web) y los que no lo tienen se está estrechando conforme avanzamos en la primera década de este siglo.Los libros escritos por Greenfield (Everyware: The Dawning Age of Ubiquitous Computing, New Riders Publishing, 2006) y Loke (Context-Aware Pervasive Systems: Architectures for a New Breed of Applications, Auerbach,2006) introducen el concepto de software de “mundo abierto” y predicen un ambiente inalámbrico en el queel software deba adaptarse a los requerimientos que surjan en tiempo real.18 La sección de “Lecturas adicionales y fuentes de información” que se presenta al final de cada capítulo exponeun panorama breve de fuentes impresas que ayudan a aumentar la comprensión de los principales temas presentados. El autor ha creado un sitio web para apoyar al libro Ingeniería de software: enfoque del profesional enwww.mhhe.com/compsci/pressman. Entre los muchos temas que se abordan en dicho sitio, se encuentrandesde los recursos de la ingeniería de software capítulo por capítulo hasta información basada en web que complementa el material presentado. Como parte de esos recursos se halla un vínculo hacia Amazon.com para cadalibro citado en esta sección.01Pressman(001-024).indd 22 14/1/10 13:31:04CAPÍTULO 1 EL SOFTWARE Y LA INGENIERÍA DE SOFTWARE 23El estado actual de la ingeniería y del proceso de software se determina mejor a partir de publicacionestales como IEEE Software, IEEE Computer, CrossTalk y IEEE Transactions on Software Engineering. Publicaciones periódicas como Application Development Trends y Cutter IT Journal con frecuencia contienen artículossobre temas de ingeniería de software. La disciplina se “resume” cada año en Proceeding of the InternationalConference on Software Engineering, patrocinada por IEEE y ACM, y se analiza a profundidad en revistas talescomo ACM Transactions on Software Engineering and Methodology, ACM Software Engineering Notes y Annalsof Software Engineering. Hay decenas de miles de sitios web dedicados a la ingeniería y al proceso de software.En años recientes se han publicado muchos libros que abordan el proceso y la ingeniería de software.Algunos presentan un panorama de todo el proceso, mientras otros profundizan en algunos temas importantes y omiten otros. Entre los más populares (¡además del que tiene usted en sus manos!) se encuentranlos siguientes:Abran, A., and J. Moore, SWEBOK: Guide to the Software Engineering Body of Knowledge, IEEE, 2002.Andersson, E., et al., Software Engineering for Internet Applications, The MIT Press, 2006.Christensen, M., and R. Thayer, A Project Manager’s Guide to Software Engineering Best Practices, IEEE-CSPress (Wiley), 2002.Glass, R., Fact and Fallacies of Software Engineering, Addison-Wesley, 2002.Jacobson, I., Object-Oriented Software Engineering: A Use Case Driven Approach, 2d ed., Addison-Wesley,2008.Jalote, P., An Integrated Approach to Software Engineering, Springer, 2006.Pfleeger, S., Software Engineering: Theory and Practice, 3d ed., Prentice-Hall, 2005.Schach, S., Object-Oriented and Classical Software Engineering, 7th ed., McGraw-Hill, 2006.Sommerville, I., Software Engineering, 8th ed., Addison-Wesley, 2006.Tsui, F., and O. Karam, Essentials of Software Engineering, Jones & Bartlett Publishers, 2006.En las últimas décadas, son muchos los estándares para la ingeniería de software que han sido publicadospor IEEE, ISO y sus organizaciones. Moore (The Road Map to Software Engineering: A Standards-Based Guide,Wiley-IEEE Computer Society Press, 2006) proporciona una revisión útil de los estándares relevantes y laforma en la que se aplican a proyectos reales.En internet se encuentra disponible una amplia variedad de fuentes acerca de la ingeniería y el procesode software. Una lista actualizada de referencias en la Red Mundial que son útiles para el proceso de software se encuentra en el sitio web del libro, en la dirección www.mhhe.com/engcs/compsci/pressman/professional/olc/ser.htm.01Pressman(001-024).indd 23 14/1/10 13:31:0401Pressman(001-024).indd 24 14/1/10 13:31:0425EL PROCESODEL SOFTWAREPARTEUnoEn esta parte de la obra, aprenderá sobre el proceso que genera unaestructura para la práctica de la ingeniería de software. En los capítulos que siguen se abordan preguntas como las siguientes:• ¿Qué es el proceso del software?• ¿Cuáles son las actividades estructurales generales que están presentes en todo proceso del software?• ¿Cómo se modelan los procesos y cuáles son los patrones del proceso?• ¿Cuáles son los modelos prescriptivos del proceso y cuáles son susfortalezas y debilidades?• ¿Por qué la agilidad es un imperativo en la ingeniería de softwaremoderna?• ¿Qué es un desarrollo ágil del software y en qué se diferencia de losmodelos más tradicionales del proceso?Una vez respondidas estas preguntas, el lector estará mejor preparadopara entender el contexto en el que se aplica la práctica de la ingenieríade software.......02Pressman(025-054).indd 25 14/1/10 13:36:4326CAPÍTULO2 MODELOSDEL PROCESOC ONCEPTOS CLAVEconjunto de tareas. . . . . . . . . 29desarrollo basadoen componentes . . . . . . . . . . 43modelo de métodosformales. . . . . . . . . . . . . . . . 44modelo general de proceso. . . 27modelos concurrentes . . . . . . 40modelos de procesoevolutivo . . . . . . . . . . . . . . . 36modelos de procesoincremental. . . . . . . . . . . . . . 35modelos de procesoprescriptivo . . . . . . . . . . . . . 33patrones del proceso . . . . . . . 29proceso del equipode software . . . . . . . . . . . . . 49proceso personaldel software. . . . . . . . . . . . . 48proceso unificado . . . . . . . . . 45¿Qué es? Cuando se trabaja en la construcción de un producto o sistema, es importanteejecutar una serie de pasos predecibles —elmapa de carreteras que lo ayuda a obtener atiempo un resultado de alta calidad—. El mapa que sesigue se llama “proceso del software”.¿Quién lo hace? Los ingenieros de software y sus gerentes adaptan el proceso a sus necesidades y luego losiguen. Además, las personas que solicitaron el softwaretienen un papel en el proceso de definición, elaboración yprueba.¿Por qué es importante? Porque da estabilidad, controly organización a una actividad que puede volverse caóticasi se descontrola. Sin embargo, un enfoque moderno deingeniería de software debe ser “ágil”. Debe incluir sóloaquellas actividades, controles y productos del trabajo quesean apropiados para el equipo del proyecto y para elproducto que se busca obtener.¿Cuáles son los pasos? En un nivel detallado, el procesoque se adopte depende del software que se esté elaborando. Un proceso puede ser apropiado para crear softwaredestinado a un sistema de control electrónico de un aeroplano, mientras que para la creación de un sitio web seránecesario un proceso completamente distinto.¿Cuál es el producto final? Desde el punto de vista deun ingeniero de software, los productos del trabajo son losprogramas, documentos y datos que se producen comoconsecuencia de las actividades y tareas definidas por elproceso.¿Cómo me aseguro de que lo hice bien? Hay ciertonúmero de mecanismos de evaluación del proceso delsoftware que permiten que las organizaciones determinenla “madurez” de su proceso. Sin embargo, la calidad,oportunidad y viabilidad a largo plazo del producto quese elabora son los mejores indicadores de la eficacia delproceso que se utiliza.U N AMIRADARÁPIDAEn un libro fascinante que expone el punto de vista de un economista sobre el softwarey su ingeniería, Howard Baetjer, Jr. [Bae98] comenta acerca del proceso del software.Debido a que el software, como todo capital, es conocimiento incorporado y a que el conocimientooriginalmente se halla disperso, tácito, latente e incompleto en gran medida, el desarrollo de softwarees un proceso de aprendizaje social. El proceso es un diálogo en el que el conocimiento que debeconvertirse en software se reúne e incorpora en éste. El proceso genera interacción entre usuarios ydiseñadores, entre usuarios y herramientas cambiantes, y entre diseñadores y herramientas en evolución [tecnología]. Es un proceso que se repite y en el que la herramienta que evoluciona sirve por símisma como medio para la comunicación: con cada nueva ronda del diálogo se genera más conocimiento útil a partir de las personas involucradas.En realidad, la elaboración de software de computadora es un proceso reiterativo de aprendizaje social, y el resultado, algo que Baetjer llamaría “capital de software”, es la reunión deconocimiento recabado, depurado y organizado a medida que se realiza el proceso.Pero desde el punto de vista técnico, ¿qué es exactamente un proceso del software? En elcontexto de este libro, se define proceso del software como una estructura para las actividades,acciones y tareas que se requieren a fin de construir software de alta calidad. ¿“Proceso” es sinónimo de “ingeniería de software”? La respuesta es “sí y no”. Un proceso del software defineel enfoque adoptado mientras se hace ingeniería sobre el software. Pero la ingeniería de software también incluye tecnologías que pueblan el proceso: métodos técnicos y herramientasautomatizadas.Más importante aún, la ingeniería de software es llevada a cabo por personas creativas ypreparadas que deben adaptar un proceso maduro de software a fin de que resulte apropiadopara los productos que construyen y para las demandas de su mercado.02Pressman(025-054).indd 26 14/1/10 13:36:44CAPÍTULO 2 MODELOS DEL PROCESO 27 2.1 U N MODELO GENERAL DE PROCESOEn el capítulo 1 se definió un proceso como la colección de actividades de trabajo, acciones ytareas que se realizan cuando va a crearse algún producto terminado. Cada una de las actividades, acciones y tareas se encuentra dentro de una estructura o modelo que define su relacióntanto con el proceso como entre sí.En la figura 2.1 se representa el proceso del software de manera esquemática. En dicha figura, cada actividad estructural está formada por un conjunto de acciones de ingeniería desoftware y cada una de éstas se encuentra definida por un conjunto de tareas que identifica lastareas del trabajo que deben realizarse, los productos del trabajo que se producirán, los puntosde aseguramiento de la calidad que se requieren y los puntos de referencia que se utilizarán paraevaluar el avance.Como se dijo en el capítulo 1, una estructura general para la ingeniería de software definecinco actividades estructurales: comunicación, planeación, modelado, construcción ydespliegue. Además, a lo largo de todo el proceso se aplica un conjunto de actividades somPUNTOCLAVELa jerarquía del trabajo técnicodentro del proceso del software es:actividades, acciones que contiene ytareas constituyentes.Estructura del procesoActividades sombrillaactividad estructural # 1Conjuntosde tareastareas del trabajoproductos del trabajopuntos de aseguramiento de la calidadpuntos de referencia del proyectoacción de ingeniería de software # 1.1Conjuntosde tareastareas del trabajoproductos del trabajopuntos de aseguramiento de la calidadpuntos de referencia del proyectoacción de ingeniería de software # 1.kactividad estructural # nConjuntosde tareastareas del trabajoproductos del trabajopuntos de aseguramiento de la calidadpuntos de referencia del proyectoacción de ingeniería de software # n.1Conjuntosde tareastareas del trabajoproductos del trabajopuntos de aseguramiento de la calidadpuntos de referencia del proyectoacción de ingeniería de software # n.mProceso del software FIGURA 2.1Estructura de unproceso delsoftware02Pressman(025-054).indd 27 14/1/10 13:36:4528 PARTE UNO EL PROCESO DEL SOFTWAREbrilla: seguimiento y control del proyecto, administración de riesgos, aseguramiento de la calidad, administración de la configuración, revisiones técnicas, entre otras.El lector debe observar que aún no se menciona un aspecto importante del proceso del software. En la figura 2.2 se ilustra dicho aspecto —llamado flujo del proceso— y se describe lamanera en que están organizadas las actividades estructurales y las acciones y tareas que ocurren dentro de cada una con respecto de la secuencia y el tiempo.Un flujo de proceso lineal ejecuta cada una de las cinco actividades estructurales en secuencia,comenzando por la comunicación y terminando con el despliegue (véase la figura 2.2a). Un flujode proceso iterativo repite una o más de las actividades antes de pasar a la siguiente (véase lafigura 2.2b). Un flujo de proceso evolutivo realiza las actividades en forma “circular”. A través delas cinco actividades, cada circuito lleva a una versión más completa del software (véase la figura 2.2c). Un flujo de proceso paralelo (véase la figura 2.2d) ejecuta una o más actividades enCita:“Pensamos que los desarrolladores de software pierden devista una verdad fundamental:la mayor parte de organizaciones no saben lo que hacen.Piensan que lo saben, pero noes así.”Tom DeMarcod) Flujo de proceso paraleloc) Flujo de proceso evolutivoComunicación Planeación Modeladoa) Flujo de proceso linealConstrucción DespliegueComunicación Planeación Modelado Construcción DespliegueConstrucción DespliegueComunicación PlaneaciónModelado Tiempob) Flujo de proceso iterativoPlaneaciónModeladoDespliegue Construcción IncrementoobtenidoComunicaciónFIGURA 2.2 Flujo del proceso02Pressman(025-054).indd 28 14/1/10 13:36:45CAPÍTULO 2 MODELOS DEL PROCESO 29paralelo con otras (por ejemplo, el modelado de un aspecto del software tal vez se ejecuteen paralelo con la construcción de otro aspecto del software).2.1.1 Definición de actividad estructuralAunque en el capítulo 1 se describieron cinco actividades estructurales y se dio una definiciónbásica de cada una, un equipo de software necesitará mucha más información antes de poderejecutar de manera apropiada cualquiera de ellas como parte del proceso del software. Portanto, surge una pregunta clave: ¿qué acciones son apropiadas para una actividad estructural,dados la naturaleza del problema por resolver, las características de las personas que hacen el trabajo y los participantes que patrocinan el proyecto?Para un proyecto de software pequeño solicitado por una persona (en una ubicación remota)con requerimientos sencillos y directos, la actividad de comunicación tal vez no incluya algomás que una llamada telefónica con el participante apropiado. Entonces, la única acción necesaria es una conversación telefónica, y las tareas del trabajo (el conjunto de tareas) que englobason las siguientes: 1. Hacer contacto con el participante por vía telefónica. 2. Analizar los requerimientos y tomar notas. 3. Organizar las notas por escrito en una formulación breve de los requerimientos. 4. Enviar correo electrónico al participante para que revise y apruebe.Si el proyecto fuera considerablemente más complejo, con muchos participantes y cada unocon un distinto conjunto de requerimientos (a veces en conflicto), la actividad de comunicaciónpuede tener seis acciones distintas (descritas en el capítulo 5): concepción, indagación, elaboración, negociación, especificación y validación. Cada una de estas acciones de la ingeniería delsoftware tendrá muchas tareas de trabajo y un número grande de diferentes productos finales.2.1.2 Identificación de un conjunto de tareasEn relación con la figura 2.1, cada acción de la ingeniería de software (por ejemplo, obtención,asociada a la actividad de comunicación) se representa por cierto número de distintos conjuntosde tareas, cada uno de los cuales es una colección de tareas de trabajo de la ingeniería de software, relacionadas con productos del trabajo, puntos de aseguramiento de la calidad y puntosde referencia del proyecto. Debe escogerse el conjunto de tareas que se adapte mejor a las necesidades del proyecto y a las características del equipo. Esto implica que una acción de la ingeniería de software puede adaptarse a las necesidades específicas del proyecto de software ya las características del equipo del proyecto.2.1.3 Patrones del procesoCada equipo de software se enfrenta a problemas conforme avanza en el proceso del software.Si se demostrara que existen soluciones fáciles para dichos problemas, sería útil para el equipoabordarlos y resolverlos rápidamente. Un patrón del proceso1 describe un problema relacionadocon el proceso que se encuentra durante el trabajo de ingeniería de software, identifica el ambiente en el que surge el problema y sugiere una o más soluciones para el mismo. Dicho demanera general, un patrón de proceso da un formato [Amb98]: un método consistente paradescribir soluciones del problema en el contexto del proceso del software. Al combinar patrones, un equipo de software resuelve problemas y construye el proceso que mejor satisfaga lasnecesidades de un proyecto.¿Cómo se transformauna actividadestructural cuandocambia la naturalezadel proyecto??PUNTOCLAVEDiferentes proyectos demandandiferentes conjuntos de tareas. Elequipo de software elige el conjuntode tareas con base en lascaracterísticas del problema y elproyecto.¿Qué es un patrón del ? proceso?1 En el capítulo 12 se hace el análisis detallado de los patrones.02Pressman(025-054).indd 29 14/1/10 13:36:4530 PARTE UNO EL PROCESO DEL SOFTWARELos patrones se definen en cualquier nivel de abstracción.2 En ciertos casos, un patrón puedeusarse para describir un problema (y su solución) asociado con un modelo completo del proceso(por ejemplo, hacer prototipos). En otras situaciones, los patrones se utilizan para describir unproblema (y su solución) asociado con una actividad estructural (por ejemplo, planeación) ouna acción dentro de una actividad estructural (estimación de proyectos).Ambler [Amb98] ha propuesto un formato para describir un patrón del proceso:Nombre del patrón. El patrón recibe un nombre significativo que lo describe en el contexto del proceso del software (por ejemplo, RevisionesTécnicas).Fuerzas. El ambiente en el que se encuentra el patrón y los aspectos que hacen visible elproblema y afectan su solución.Tipo. Se especifica el tipo de patrón. Ambler [Amb98] sugiere tres tipos: 1. Patrón de etapa: define un problema asociado con una actividad estructural para elproceso. Como una actividad estructural incluye múltiples acciones y tareas del trabajo, un patrón de la etapa incorpora múltiples patrones de la tarea (véase a continuación) que son relevantes para la etapa (actividad estructural). Un ejemplo de patrón de etapa sería EstablecerComunicación. Este patrón incorporaría el patrón detarea RecabarRequerimientos y otros más. 2. Patrón de tarea: define un problema asociado con una acción o tarea de trabajo de laingeniería de software y que es relevante para el éxito de la práctica de ingeniería desoftware (por ejemplo, RecabarRequerimientos es un patrón de tarea).Conjunto de tareasUn conjunto de tareas define el trabajo real por efectuar afin de cumplir los objetivos de una acción de ingeniería desoftware. Por ejemplo, la indagación (mejor conocida como “recabarlos requerimientos”) es una acción importante de la ingeniería de software que ocurre durante la actividad de comunicación. La meta alrecabar los requerimientos es entender lo que los distintos participantes desean del software que se va a elaborar.Para un proyecto pequeño y relativamente sencillo, el conjunto detareas para la indagación de requerimientos tendrá un aspecto parecido al siguiente: 1. Elaborar la lista de participantes del proyecto. 2. Invitar a todos los participantes a una reunión informal. 3. Pedir a cada participante que haga una relación de las características y funciones que requiere. 4. Analizar los requerimientos y construir la lista definitiva. 5. Ordenar los requerimientos según su prioridad. 6. Identificar las áreas de incertidumbre.Para un proyecto de software más grande y complejo se requeriráde un conjunto de tareas diferente que quizá esté constituido por lassiguientes tareas de trabajo: 1. Hacer la lista de participantes del proyecto. 2. Entrevistar a cada participante por separado a fin de determinar los deseos y necesidades generales. 3. Formar la lista preliminar de las funciones y características conbase en las aportaciones del participante. 4. Programar una serie de reuniones para facilitar la elaboraciónde las especificaciones de la aplicación. 5. Celebrar las reuniones. 6. Producir en cada reunión escenarios informales de usuario. 7. Afinar los escenarios del usuario con base en la retroalimentación de los participantes. 8. Formar una lista revisada de los requerimientos de los participantes. 9. Usar técnicas de despliegue de la función de calidad para asignar prioridades a los requerimientos. 10. Agrupar los requerimientos de modo que puedan entregarse enforma paulatina y creciente. 11. Resaltar las limitantes y restricciones que se introducirán al sistema. 12. Analizar métodos para validar el sistema.Los dos conjuntos de tareas mencionados sirven para “recabar losrequerimientos”, pero son muy distintos en profundidad y formalidad.El equipo de software elige el conjunto de tareas que le permitaalcanzar la meta de cada acción con calidad y agilidad.INFORMACIÓNCita:“La repetición de patrones esalgo muy diferente de la repetición de las partes. En realidad,las distintas partes serán únicasporque los patrones son los mismos.”Christopher Alexander2 Los patrones son aplicables a muchas actividades de la ingeniería de software. El análisis, el diseño y la pruebade patrones se estudian en los capítulos 7, 9, 10, 12 y 14. Los patrones y “antipatrones” para las actividades deadministración de proyectos se analizan en la parte 4 del libro.PUNTOCLAVEUn formato de patrón proporciona unmedio consistente para describir alpatrón.02Pressman(025-054).indd 30 14/1/10 13:36:45CAPÍTULO 2 MODELOS DEL PROCESO 31 3. Patrón de fase: define la secuencia de las actividades estructurales que ocurren dentrodel proceso, aun cuando el flujo general de las actividades sea de naturaleza iterativa.Un ejemplo de patrón de fase es ModeloEspiral o Prototipos.3Contexto inicial. Describe las condiciones en las que se aplica el patrón. Antes de iniciarel patrón: 1) ¿Qué actividades organizacionales o relacionadas con el equipo han ocurrido?2) ¿Cuál es el estado de entrada para el proceso? 3) ¿Qué información de ingeniería de software o del proyecto ya existe? Por ejemplo, el patrón Planeación (patrón de etapa) requiere que: 1) los clientes y losingenieros de software hayan establecido una comunicación colaboradora; 2) haya terminado con éxito cierto número de patrones de tarea [especificado] para el patrón Comunicación; y 3) se conozcan el alcance del proyecto, los requerimientos básicos del negocio ylas restricciones del proyecto.Problema. El problema específico que debe resolver el patrón.Solución. Describe cómo implementar con éxito el patrón. Esta sección describe la formaen la que se modifica el estado inicial del proceso (que existe antes de implementar el patrón) como consecuencia de la iniciación del patrón. También describe cómo se transformala información sobre la ingeniería de software o sobre el proyecto, disponible antes de queinicie el patrón, como consecuencia de la ejecución exitosa del patrón.Contexto resultante. Describe las condiciones que resultarán una vez que se haya implementado con éxito el patrón: 1) ¿Qué actividades organizacionales o relacionadas con elequipo deben haber ocurrido? 2) ¿Cuál es el estado de salida del proceso? 3) ¿Qué información sobre la ingeniería de software o sobre el proyecto se ha desarrollado?Patrones relacionados. Proporciona una lista de todos los patrones de proceso directamente relacionados con éste. Puede representarse como una jerarquía o en alguna formade diagrama. Por ejemplo, el patrón de etapa Comunicación incluye los patrones de tarea:EquipoDelProyecto, LineamientosDeColaboración, DefiniciónDeAlcances, RecabarRequerimientos, DescripciónDeRestricciones y CreaciónDeEscenarios.Usos y ejemplos conocidos. Indica las instancias específicas en las que es aplicable elpatrón. Por ejemplo, Comunicación es obligatoria al principio de todo proyecto de software, es recomendable a lo largo del proyecto y de nuevo obligatoria una vez alcanzada laactividad de despliegue.Los patrones de proceso dan un mecanismo efectivo para enfrentar problemas asociados concualquier proceso del software. Los patrones permiten desarrollar una descripción jerárquicadel proceso, que comienza en un nivel alto de abstracción (un patrón de fase). Después se mejora la descripción como un conjunto de patrones de etapa que describe las actividades estructurales y se mejora aún más en forma jerárquica en patrones de tarea más detallados para cadapatrón de etapa. Una vez desarrollados los patrones de proceso, pueden reutilizarse para ladefinición de variantes del proceso, es decir, un equipo de software puede definir un modelo deproceso específico con el empleo de los patrones como bloques constituyentes del modelodel proceso. 2.2 EVALUACIÓN Y MEJORA DEL PROCESOLa existencia de un proceso del software no es garantía de que el software se entregue a tiempo,que satisfaga las necesidades de los consumidores o que tenga las características técnicas que3 Estos patrones de fase se estudian en la sección 2.3.3.WebRefEn la dirección www.ambysoft.com/processPatternsPage.htmlse encuentran recursos amplios sobrelos patrones de proceso.02Pressman(025-054).indd 31 14/1/10 13:36:4632 PARTE UNO EL PROCESO DEL SOFTWAREconducirán a características de calidad de largo plazo (véanse los capítulos 14 y 16). Los patrones de proceso deben acoplarse con una práctica sólida de ingeniería de software (véase la parte2 del libro). Además, el proceso en sí puede evaluarse para garantizar que cumple con ciertoscriterios de proceso básicos que se haya demostrado que son esenciales para el éxito de la ingeniería de software.4En las últimas décadas se han propuesto numerosos enfoques para la evaluación y mejorade un proceso del software:Método de evaluación del estándar CMMI para el proceso de mejora (SCAMPI, porsus siglas en inglés): proporciona un modelo de cinco fases para evaluar el proceso: inicio,diagnóstico, establecimiento, actuación y aprendizaje. El método SCAMPI emplea el SEICMMI como la base de la evaluación [SEI00].Evaluación basada en CMM para la mejora del proceso interno (CBA IPI, por sus siglas en inglés): proporciona una técnica de diagnóstico para evaluar la madurez relativa deuna organización de software; usa el SEI CMM como la base de la evaluación [Dun01].SPICE (ISO/IEC 15504): estándar que define un conjunto de requerimientos para la evaluación del proceso del software. El objetivo del estándar es ayudar a las organizaciones adesarrollar una evaluación objetiva de cualquier proceso del software definido [ISO08].ISO9001:2000 para software: estándar genérico que se aplica a cualquier organizaciónque desee mejorar la calidad general de los productos, sistemas o servicios que proporciona. Por tanto, el estándar es directamente aplicable a las organizaciones y compañías desoftware [Ant06].En el capítulo 30 se presenta un análisis detallado de los métodos de evaluación del softwarey del proceso de mejora.Ejemplo de patrón de procesoEl siguiente patrón de proceso abreviado describe unenfoque aplicable en el caso en el que los participantestienen una idea general de lo que debe hacerse, pero no están seguros de los requerimientos específicos de software.Nombre del patrón. RequerimientosPocoClarosIntención. Este patrón describe un enfoque para construir un modelo (un prototipo) que los participantes pueden evaluar en forma iterativa, en un esfuerzo por identificar o solidificar los requerimientos desoftware.Tipo. Patrón de fase.Contexto inicial. Antes de iniciar este patrón deben cumplirse lassiguientes condiciones: 1) se ha identificado a los participantes; 2) seha establecido un modo de comunicación entre los participantes y elequipo de software; 3) los participantes han identificado el problemageneral de software que se va a resolver; 4) se ha obtenido el entendimiento inicial del alcance del proyecto, los requerimientos básicosdel negocio y las restricciones del proyecto.Problema. Los requerimientos son confusos o inexistentes, pero hayun reconocimiento claro de que existe un problema por resolver y quedebe hacerse con una solución de software. Los participantes no estánseguros de lo que quieren, es decir, no pueden describir con detallelos requerimientos del software.Solución. Aquí se presentaría una descripción del proceso prototipo, que se describirá más adelante, en la sección 2.3.3.Contexto resultante. Los participantes aprueban un prototipo desoftware que identifica los requerimientos básicos (por ejemplo,modos de interacción, características computacionales, funciones deprocesamiento). Después de esto, 1) el prototipo quizá evolucione através de una serie de incrementos para convertirse en el software deproducción, o 2) tal vez se descarte el prototipo y el software de producción se elabore con el empleo de otro proceso de patrón.Patrones relacionados. Los patrones siguientes están relacionados con este patrón: ComunicaciónConClientes, DiseñoIterativo, DesarrolloIterativo, EvaluaciónDelCliente, ObtenciónDeRequerimientos.Usos y ejemplos conocidos. Cuando los requerimientos seaninciertos, es recomendable hacer prototipos.INFORMACIÓNPUNTOCLAVELa evaluación busca entender elestado actual del proceso delsoftware con el objeto de mejorarlo.4 En la publicación CMMI [CMM07] del SEI, se describen con muchos detalles las características de un proceso delsoftware y los criterios para un proceso exitoso.¿De qué técnicasformales se disponepara evaluar el procesodel software??Cita:“Las organizaciones de softwaretienen deficiencias significativasen su capacidad de capitalizarlas experiencias obtenidas de losproyectos terminados.”NASA02Pressman(025-054).indd 32 14/1/10 13:36:46CAPÍTULO 2 MODELOS DEL PROCESO 33 2.3 MODELOS DE PROCESO PRESCRIPTIVOLos modelos de proceso prescriptivo fueron propuestos originalmente para poner orden en elcaos del desarrollo de software. La historia indica que estos modelos tradicionales han dadocierta estructura útil al trabajo de ingeniería de software y que constituyen un mapa razonablemente eficaz para los equipos de software. Sin embargo, el trabajo de ingeniería de software yel producto que genera siguen “al borde del caos”.En un artículo intrigante sobre la extraña relación entre el orden y el caos en el mundo delsoftware, Nogueira y sus colegas [Nog00] afirman lo siguiente:El borde del caos se define como “el estado natural entre el orden y el caos, un compromiso grandeentre la estructura y la sorpresa” [Kau95]. El borde del caos se visualiza como un estado inestable yparcialmente estructurado […] Es inestable debido a que se ve atraído constantemente hacia el caoso hacia el orden absoluto.Tenemos la tendencia de pensar que el orden es el estado ideal de la naturaleza. Esto podría serun error […] las investigaciones apoyan la teoría de que la operación que se aleja del equilibrio generacreatividad, procesos autoorganizados y rendimientos crecientes [Roo96]. El orden absoluto significaausencia de variabilidad, que podría ser una ventaja en los ambientes impredecibles. El cambio ocurrecuando hay cierta estructura que permita que el cambio pueda organizarse, pero que no sea tan rígida como para que no pueda suceder. Por otro lado, demasiado caos hace imposible la coordinación yla coherencia. La falta de estructura no siempre significa desorden.Las implicaciones filosóficas de este argumento son significativas para la ingeniería de software.Si los modelos de proceso prescriptivo5 buscan generar estructura y orden, ¿son inapropiadospara el mundo del software, que se basa en el cambio? Pero si rechazamos los modelos de proceso tradicional (y el orden que implican) y los reemplazamos con algo menos estructurado,¿hacemos imposible la coordinación y coherencia en el trabajo de software?No hay respuestas fáciles para estas preguntas, pero existen alternativas disponibles para losingenieros de software. En las secciones que siguen se estudia el enfoque de proceso prescriptivo en el que los temas dominantes son el orden y la consistencia del proyecto. El autor losllama “prescriptivos” porque prescriben un conjunto de elementos del proceso: actividades estructurales, acciones de ingeniería de software, tareas, productos del trabajo, aseguramiento dela calidad y mecanismos de control del cambio para cada proyecto. Cada modelo del procesotambién prescribe un flujo del proceso (también llamado flujo de trabajo), es decir, la manera enla que los elementos del proceso se relacionan entre sí.Todos los modelos del proceso del software pueden incluir las actividades estructurales generales descritas en el capítulo 1, pero cada una pone distinto énfasis en ellas y define en formadiferente el flujo de proceso que invoca cada actividad estructural (así como acciones y tareasde ingeniería de software).2.3.1 Modelo de la cascadaHay veces en las que los requerimientos para cierto problema se comprenden bien: cuando eltrabajo desde la comunicación hasta el despliegue fluye en forma razonablemente lineal. Estasituación se encuentra en ocasiones cuando deben hacerse adaptaciones o mejoras bien definidas a un sistema ya existente (por ejemplo, una adaptación para software de contabilidad quees obligatorio hacer debido a cambios en las regulaciones gubernamentales). También ocurreen cierto número limitado de nuevos esfuerzos de desarrollo, pero sólo cuando los requerimientos están bien definidos y tienen una estabilidad razonable.Cita:“Si el proceso está bien, losresultados cuidarán de sí mismos.”Takashi Osada5 Los modelos de proceso prescriptivo en ocasiones son denominados modelos de proceso “tradicional”.PUNTOCLAVELos modelos de proceso prescriptivodefinen un conjunto prescrito deelementos del proceso y un flujopredecible para el trabajo delproceso.02Pressman(025-054).indd 33 14/1/10 13:36:4634 PARTE UNO EL PROCESO DEL SOFTWAREEl modelo de la cascada, a veces llamado ciclo de vida clásico, sugiere un enfoque sistemáticoy secuencial6 para el desarrollo del software, que comienza con la especificación de los requerimientos por parte del cliente y avanza a través de planeación, modelado, construcción y despliegue, para concluir con el apoyo del software terminado (véase la figura 2.3).Una variante de la representación del modelo de la cascada se denomina modelo en V. En lafigura 2.4 se ilustra el modelo en V [Buc99], donde se aprecia la relación entre las acciones parael aseguramiento de la calidad y aquellas asociadas con la comunicación, modelado y construcción temprana. A medida que el equipo de software avanza hacia abajo desde el lado izquierdode la V, los requerimientos básicos del problema mejoran hacia representaciones técnicas cadavez más detalladas del problema y de su solución. Una vez que se ha generado el código, elequipo sube por el lado derecho de la V, y en esencia ejecuta una serie de pruebas (acciones paraasegurar la calidad) que validan cada uno de los modelos creados cuando el equipo fue haciaabajo por el lado izquierdo.7 En realidad, no hay diferencias fundamentales entre el ciclo de vidaclásico y el modelo en V. Este último proporciona una forma de visualizar el modo de aplicaciónde las acciones de verificación y validación al trabajo de ingeniería inicial.El modelo de la cascada es el paradigma más antiguo de la ingeniería de software. Sin embargo, en las últimas tres décadas, las críticas hechas al modelo han ocasionado que incluso susdefensores más obstinados cuestionen su eficacia [Han95]. Entre los problemas que en ocasiones surgen al aplicar el modelo de la cascada se encuentran los siguientes: 1. Es raro que los proyectos reales sigan el flujo secuencial propuesto por el modelo. Aunque el modelo lineal acepta repeticiones, lo hace en forma indirecta. Como resultado,los cambios generan confusión conforme el equipo del proyecto avanza. 2. A menudo, es difícil para el cliente enunciar en forma explícita todos los requerimientos. El modelo de la cascada necesita que se haga y tiene dificultades para aceptar la incertidumbre natural que existe al principio de muchos proyectos. 3. El cliente debe tener paciencia. No se dispondrá de una versión funcional del(de los)programa(s) hasta que el proyecto esté muy avanzado. Un error grande sería desastrososi se detectara hasta revisar el programa en funcionamiento.En un análisis interesante de proyectos reales, Bradac [Bra94] encontró que la naturalezalineal del ciclo de vida clásico llega a “estados de bloqueo” en los que ciertos miembros delequipo de proyecto deben esperar a otros a fin de terminar tareas interdependientes. En realidad, ¡el tiempo de espera llega a superar al dedicado al trabajo productivo! Los estados debloqueo tienden a ocurrir más al principio y al final de un proceso secuencial lineal.Hoy en día, el trabajo de software es acelerado y está sujeto a una corriente sin fin de cambios(en las características, funciones y contenido de información). El modelo de la cascada suele serComunicación inicio del proyecto recabar los requerimientosPlaneación estimación programación seguimientoModelado análisis diseño Despliegue entrega asistencia retroalimentaciónConstrucción código pruebasFIGURA 2.3 Modelo de la cascada6 Aunque el modelo de la cascada propuesto originalmente por Winston Royce [Roy70] prevé los “bucles de retroalimentación”, la gran mayoría de organizaciones que aplican este modelo de proceso lo tratan como si fueraestrictamente lineal.7 En la parte 3 del libro se estudian con detalle las acciones de aseguramiento de la calidad.PUNTOCLAVEEl modelo en V ilustra la forma en laque se asocian las acciones deverificación y validación con lasprimeras acciones de ingeniería.¿Por qué a veces fallael modelo de lacascada??Cita:“Con demasiada frecuencia, eltrabajo de software sigue la primera ley del ciclismo: noimporta hacia dónde te dirijas,vas hacia arriba y contra elviento.”Anónimo02Pressman(025-054).indd 34 14/1/10 13:36:47CAPÍTULO 2 MODELOS DEL PROCESO 35inapropiado para ese tipo de labor. No obstante, sirve como un modelo de proceso útil en situaciones en las que los requerimientos son fijos y el trabajo avanza en forma lineal hacia el final.2.3.2 Modelos de proceso incrementalHay muchas situaciones en las que los requerimientos iniciales del software están razonablemente bien definidos, pero el alcance general del esfuerzo de desarrollo imposibilita un procesolineal. Además, tal vez haya una necesidad imperiosa de dar rápidamente cierta funcionalidadlimitada de software a los usuarios y aumentarla en las entregas posteriores de software. Entales casos, se elige un modelo de proceso diseñado para producir el software en incrementos.El modelo incremental combina elementos de los flujos de proceso lineal y paralelo estudiados en la sección 2.1. En relación con la figura 2.5, el modelo incremental aplica secuencias lineales en forma escalonada a medida que avanza el calendario de actividades. Cada secuencialineal produce “incrementos” de software susceptibles de entregarse [McD93] de manera parecida a los incrementos producidos en un flujo de proceso evolutivo (sección 2.3.3).Por ejemplo, un software para procesar textos que se elabore con el paradigma incrementalquizá entregue en el primer incremento las funciones básicas de administración de archivos,edición y producción del documento; en el segundo dará herramientas más sofisticadas de edición y producción de documentos; en el tercero habrá separación de palabras y revisión de laortografía; y en el cuarto se proporcionará la capacidad para dar formato avanzado a las páginas. Debe observarse que el flujo de proceso para cualquier incremento puede incorporar elparadigma del prototipo.Cuando se utiliza un modelo incremental, es frecuente que el primer incremento sea el producto fundamental. Es decir, se abordan los requerimientos básicos, pero no se proporcionanmuchas características suplementarias (algunas conocidas y otras no). El cliente usa el productofundamental (o lo somete a una evaluación detallada). Como resultado del uso y/o evaluación,Generaciónde códigoDiseño de laarquitecturaDiseño de loscomponentesModelado de losrequerimientosPruebas deaceptaciónPruebasdel sistemaPruebas deintegraciónPruebasunitariasSoftwareejecutableFIGURA 2.4El modelo en VPUNTOCLAVEEl modelo incremental ejecuta unaserie de avances, llamadosincrementos, que en formaprogresiva dan más funcionalidad alcliente conforme se le entrega cadaincremento.Su cliente solicita la entrega parauna fecha que es imposible decumplir. Sugiera entregar uno o másincrementos en la fecha que pide, yel resto del software (incrementosadicionales) en un momentoposterior.CONSEJO02Pressman(025-054).indd 35 14/1/10 13:36:4736 PARTE UNO EL PROCESO DEL SOFTWAREse desarrolla un plan para el incremento que sigue. El plan incluye la modificación del productofundamental para cumplir mejor las necesidades del cliente, así como la entrega de características adicionales y más funcionalidad. Este proceso se repite después de entregar cada incremento, hasta terminar el producto final.El modelo de proceso incremental se centra en que en cada incremento se entrega un producto que ya opera. Los primeros incrementos son versiones desnudas del producto final, peroproporcionan capacidad que sirve al usuario y también le dan una plataforma de evaluación.8El desarrollo incremental es útil en particular cuando no se dispone de personal para la implementación completa del proyecto en el plazo establecido por el negocio. Los primeros incrementos se desarrollan con pocos trabajadores. Si el producto básico es bien recibido, entoncesse agrega más personal (si se requiere) para que labore en el siguiente incremento. Además, losincrementos se planean para administrar riesgos técnicos. Por ejemplo, un sistema grande talvez requiera que se disponga de hardware nuevo que se encuentre en desarrollo y cuya fechade entrega sea incierta. En este caso, tal vez sea posible planear los primeros incrementos deforma que eviten el uso de dicho hardware, y así proporcionar una funcionalidad parcial a losusuarios finales sin un retraso importante.2.3.3 Modelos de proceso evolutivoEl software, como todos los sistemas complejos, evoluciona en el tiempo. Es frecuente que losrequerimientos del negocio y del producto cambien conforme avanza el desarrollo, lo que haceque no sea realista trazar una trayectoria rectilínea hacia el producto final; los plazos apretadosdel mercado hacen que sea imposible la terminación de un software perfecto, pero debe lanzarse una versión limitada a fin de aliviar la presión de la competencia o del negocio; se comprende bien el conjunto de requerimientos o el producto básico, pero los detalles del productoo extensiones del sistema aún están por definirse. En estas situaciones y otras parecidas senecesita un modelo de proceso diseñado explícitamente para adaptarse a un producto que evoluciona con el tiempo.Los modelos evolutivos son iterativos. Se caracterizan por la manera en la que permitendesarrollar versiones cada vez más completas del software. En los párrafos que siguen se presentan dos modelos comunes de proceso evolutivo.incremento # 1incremento # 2entrega del primerincrementoentrega del segundoincrementoentrega del n-ésimoincrementoincremento # nCalendario del proyectoFuncionalidad y características del softwareComunicaciónPlaneaciónModelado (análisis, diseño)Construcción (código, prueba)Despliegue (entrega, retroalimentación)FIGURA 2.5El modeloincremental8 Es importante observar que para todos los modelos de proceso “ágiles” que se estudian en el capítulo 3 tambiénse usa la filosofía incremental.PUNTOCLAVEEl modelo del proceso evolutivogenera en cada iteración una versiónfinal cada vez más completa delsoftware.02Pressman(025-054).indd 36 14/1/10 13:36:48CAPÍTULO 2 MODELOS DEL PROCESO 37Hacer prototipos. Es frecuente que un cliente defina un conjunto de objetivos generales parael software, pero que no identifique los requerimientos detallados para las funciones y características. En otros casos, el desarrollador tal vez no esté seguro de la eficiencia de un algoritmo,de la adaptabilidad de un sistema operativo o de la forma que debe adoptar la interacción entreel humano y la máquina. En estas situaciones, y muchas otras, el paradigma de hacer prototipostal vez ofrezca el mejor enfoque.Aunque es posible hacer prototipos como un modelo de proceso aislado, es más comúnusarlo como una técnica que puede implementarse en el contexto de cualquiera de los modelosde proceso descritos en este capítulo. Sin importar la manera en la que se aplique, el paradigmade hacer prototipos le ayudará a usted y a otros participantes a mejorar la comprensión de loque hay que elaborar cuando los requerimientos no están claros.El paradigma de hacer prototipos (véase la figura 2.6) comienza con comunicación. Usted sereúne con otros participantes para definir los objetivos generales del software, identifica cualesquiera requerimientos que conozca y detecta las áreas en las que es imprescindible una mayordefinición. Se planea rápidamente una iteración para hacer el prototipo, y se lleva a cabo elmodelado (en forma de un “diseño rápido”). Éste se centra en la representación de aquellosaspectos del software que serán visibles para los usuarios finales (por ejemplo, disposición dela interfaz humana o formatos de la pantalla de salida). El diseño rápido lleva a la construcciónde un prototipo. Éste se entrega y es evaluado por los participantes, que dan retroalimentación para mejorar los requerimientos. La iteración ocurre a medida de que el prototipo es afinado para satisfacer las necesidades de distintos participantes, y al mismo tiempo le permite austed entender mejor lo que se necesita hacer.El ideal es que el prototipo sirva como mecanismo para identificar los requerimientos delsoftware. Si va a construirse un prototipo, pueden utilizarse fragmentos de programas existentes o aplicar herramientas (por ejemplo, generadores de reportes y administradores de ventanas) que permitan generar rápidamente programas que funcionen.Pero, ¿qué hacer con el prototipo cuando ya sirvió para el propósito descrito? Brooks [Bro95]da una respuesta:En la mayoría de proyectos es raro que el primer sistema elaborado sea utilizable. Tal vez sea muylento, muy grande, difícil de usar o todo a la vez. No hay más alternativa que comenzar de nuevo, conmás inteligencia, y construir una versión rediseñada en la que se resuelvan los problemas.Cita:“Planee para lanzar uno. Detodos modos hará eso. Su únicaelección es si tratará de vendera sus clientes lo que lanzó.”Frederick P. BrooksCuando su cliente tiene unanecesidad legítima, pero ignora losdetalles, como primer paso desarrolleun prototipo.CONSEJOComunicaciónPlan rápidoConstruccióndelprototipoModelado Diseño rápidoDespliegue Entrega y RetroalimentaciónFIGURA 2.6El paradigma dehacer prototipos02Pressman(025-054).indd 37 14/1/10 13:36:4838 PARTE UNO EL PROCESO DEL SOFTWAREEl prototipo sirve como “el primer sistema”. Lo que Brooks recomienda es desecharlo. Peroesto quizá sea un punto de vista idealizado. Aunque algunos prototipos se construyen para ser“desechables”, otros son evolutivos; es decir, poco a poco se transforman en el sistema real.Tanto a los participantes como a los ingenieros de software les gusta el paradigma de hacerprototipos. Los usuarios adquieren la sensación del sistema real, y los desarrolladores logranconstruir algo de inmediato. No obstante, hacer prototipos llega a ser problemático por las siguientes razones: 1. Los participantes ven lo que parece ser una versión funcional del software, sin darsecuenta de que el prototipo se obtuvo de manera caprichosa; no perciben que en la prisapor hacer que funcionara, usted no consideró la calidad general del software o la facilidad de darle mantenimiento a largo plazo. Cuando se les informa que el producto deberehacerse a fin de obtener altos niveles de calidad, los participantes gritan que es ustedun tonto y piden “unos cuantos arreglos” para hacer del prototipo un producto funcional. Con demasiada frecuencia, el gerente de desarrollo del software cede. 2. Como ingeniero de software, es frecuente que llegue a compromisos respecto de la implementación a fin de hacer que el prototipo funcione rápido. Quizá utilice un sistemaoperativo inapropiado, o un lenguaje de programación tan sólo porque cuenta con él ylo conoce; tal vez implementó un algoritmo ineficiente sólo para demostrar capacidad.Después de un tiempo, quizá se sienta cómodo con esas elecciones y olvide todas lasrazones por las que eran inadecuadas. La elección de algo menos que lo ideal ahora hapasado a formar parte del sistema.Aunque puede haber problemas, hacer prototipos es un paradigma eficaz para la ingenieríade software. La clave es definir desde el principio las reglas del juego; es decir, todos los participantes deben estar de acuerdo en que el prototipo sirva como el mecanismo para definir losrequerimientos. Después se descartará (al menos en parte) y se hará la ingeniería del softwarereal con la mirada puesta en la calidad.Resista la presión para convertir unprototipo burdo en un productoterminado. Como resultado de ello,casi siempre disminuye la calidad.CONSEJOSelección de un modelo de proceso,parte 1La escena: Sala de juntas del grupo de ingeniería de software deCPI Corporation, compañía (ficticia) que manufactura artículos deconsumo para el hogar y para uso comercial.Participantes: Lee Warren, gerente de ingeniería; Doug Miller,gerente de ingeniería de software; Jamie Lazar, miembro del equipode software; Vinod Raman, miembro del equipo de software; y EdRobbins, miembro del equipo de software.La conversación:Lee: Recapitulemos. He dedicado algún tiempo al análisis de lalínea de productos CasaSegura, según la vemos hasta el momento.No hay duda de que hemos efectuado mucho trabajo tan sólo paradefinir el concepto, pero me gustaría que ustedes comenzaran a pensar en cómo van a enfocar la parte del software de este proyecto.Doug: Pareciera que en el pasado hemos estado muy desorganizados en nuestro enfoque del software.Ed: No sé, Doug, siempre sacamos el producto.Doug: Es cierto, pero no sin muchos sobresaltos, y este proyectoparece más grande y complejo que cualquier cosa que hayamoshecho antes.Jamie: No parece tan mal, pero estoy de acuerdo… nuestro enfoque ad hoc de los proyectos anteriores no funcionará en éste, enparticular si tenemos una fecha de entrega muy apretada.Doug (sonríe): Quiero ser un poco más profesional en nuestroenfoque. La semana pasada asistí a un curso breve y aprendí muchosobre ingeniería de software… algo bueno. Aquí necesitamos unproceso.Jamie (con el ceño fruncido): Mi trabajo es producir programas de computadora, no papel.Doug: Den una oportunidad antes de ser tan negativos conmigo. Loque quiero decir es esto: [Doug pasa a describir la estructura delproceso vista en este capítulo y los modelos de proceso prescriptivopresentados hasta el momento.]Doug: De cualquier forma, parece que un modelo lineal no es paranosotros… pues supone que conocemos todos los requerimientos y,conociendo esta empresa, eso no parece probable.CASASEGURA02Pressman(025-054).indd 38 14/1/10 13:36:48CAPÍTULO 2 MODELOS DEL PROCESO 39El modelo espiral. Propuesto en primer lugar por Barry Boehm [Boe88], el modelo espiral esun modelo evolutivo del proceso del software y se acopla con la naturaleza iterativa de hacerprototipos con los aspectos controlados y sistémicos del modelo de cascada. Tiene el potencialpara hacer un desarrollo rápido de versiones cada vez más completas. Boehm [Boe01a] describeel modelo del modo siguiente:El modelo de desarrollo espiral es un generador de modelo de proceso impulsado por el riesgo, que seusa para guiar la ingeniería concurrente con participantes múltiples de sistemas intensivos en software. Tiene dos características distintivas principales. La primera es el enfoque cíclico para el crecimiento incremental del grado de definición de un sistema y su implementación, mientras que disminuye su grado de riesgo. La otra es un conjunto de puntos de referencia de anclaje puntual paraasegurar el compromiso del participante con soluciones factibles y mutuamente satisfactorias.Con el empleo del modelo espiral, el software se desarrolla en una serie de entregas evolutivas.Durante las primeras iteraciones, lo que se entrega puede ser un modelo o prototipo. En lasiteraciones posteriores se producen versiones cada vez más completas del sistema cuya ingeniería se está haciendo.Un modelo en espiral es dividido por el equipo de software en un conjunto de actividadesestructurales. Para fines ilustrativos, se utilizan las actividades estructurales generales ya analizadas.9 Cada una de ellas representa un segmento de la trayectoria espiral ilustrada en la figura2.7. Al comenzar el proceso evolutivo, el equipo de software realiza actividades implícitas en unVinod: Sí, y parece demasiado orientado a las tecnologías deinformación… tal vez sea bueno para hacer un sistema de control deinventarios o algo así, pero no parece bueno para CasaSegura.Doug: Estoy de acuerdo.Ed: Ese enfoque de hacer prototipos parece bueno. En todo caso, seasemeja mucho a lo que hacemos aquí.Vinod: Eso es un problema. Me preocupa que no nos dé suficienteestructura.Doug: No te preocupes. Tenemos muchas opciones más, y quisieraque ustedes, muchachos, elijan la que sea mejor para el equipo ypara el proyecto.ComunicaciónPlaneaciónModeladoConstrucción DespliegueentregaretroalimentaciónInicioanálisisdiseñocódigopruebaestimaciónprogramaciónanálisis de riesgoFIGURA 2.7Modelo de espiralcomún9 El modelo espiral estudiado en esta sección es una variante del propuesto por Boehm. Para más informaciónacerca del modelo espiral original, consulte [Boe88]. En [Boe98] se encuentra un análisis más reciente del modeloespiral del mismo autor.PUNTOCLAVEEl modelo en espiral se adapta paraemplearse a lo largo de todo el ciclode vida de una aplicación, desde eldesarrollo del concepto hasta elmantenimiento.02Pressman(025-054).indd 39 14/1/10 13:36:4840 PARTE UNO EL PROCESO DEL SOFTWAREcircuito alrededor de la espiral en el sentido horario, partiendo del centro. El riesgo se consideraconforme se desarrolla cada revolución (capítulo 28). En cada paso evolutivo se marcan puntosde referencia puntuales: combinación de productos del trabajo y condiciones que se encuentrana lo largo de la trayectoria de la espiral.El primer circuito alrededor de la espiral da como resultado el desarrollo de una especificación del producto; las vueltas sucesivas se usan para desarrollar un prototipo y, luego, versionescada vez más sofisticadas del software. Cada paso por la región de planeación da como resultado ajustes en el plan del proyecto. El costo y la programación de actividades se ajustan conbase en la retroalimentación obtenida del cliente después de la entrega. Además, el gerente delproyecto ajusta el número planeado de iteraciones que se requieren para terminar el software.A diferencia de otros modelos del proceso que finalizan cuando se entrega el software,el modelo espiral puede adaptarse para aplicarse a lo largo de toda la vida del software decómputo. Entonces, el primer circuito alrededor de la espiral quizá represente un “proyectode desarrollo del concepto” que comienza en el centro de la espiral y continúa por iteracionesmúltiples10 hasta que queda terminado el desarrollo del concepto. Si el concepto va a desarrollarse en un producto real, el proceso sigue hacia fuera de la espiral y comienza un “proyectode desarrollo de producto nuevo”. El nuevo producto evolucionará a través de cierto número deiteraciones alrededor de la espiral. Más adelante puede usarse un circuito alrededor de la espiralpara que represente un “proyecto de mejora del producto”. En esencia, la espiral, cuando secaracteriza de este modo, sigue operativa hasta que el software se retira. Hay ocasiones en lasque el proceso está inmóvil, pero siempre que se inicia un cambio comienza en el punto deentrada apropiado (por ejemplo, mejora del producto).El modelo espiral es un enfoque realista para el desarrollo de sistemas y de software a granescala. Como el software evoluciona a medida que el proceso avanza, el desarrollador y clientecomprenden y reaccionan mejor ante los riesgos en cada nivel de evolución. El modelo espiralusa los prototipos como mecanismo de reducción de riesgos, pero, más importante, permiteaplicar el enfoque de hacer prototipos en cualquier etapa de la evolución del producto. Mantieneel enfoque de escalón sistemático sugerido por el ciclo de vida clásico, pero lo incorpora en unaestructura iterativa que refleja al mundo real en una forma más realista. El modelo espiral demanda una consideración directa de los riesgos técnicos en todas las etapas del proyecto y, sise aplica de manera apropiada, debe reducir los riesgos antes de que se vuelvan un problema.Pero, como otros paradigmas, el modelo espiral no es una panacea. Es difícil convencer a losclientes (en particular en situaciones bajo contrato) de que el enfoque evolutivo es controlable.Demanda mucha experiencia en la evaluación del riesgo y se basa en ella para llegar al éxito.No hay duda de que habrá problemas si algún riesgo importante no se descubre y administra.2.3.4 Modelos concurrentesEl modelo de desarrollo concurrente, en ocasiones llamado ingeniería concurrente, permite queun equipo de software represente elementos iterativos y concurrentes de cualquiera de los modelos de proceso descritos en este capítulo. Por ejemplo, la actividad de modelado definida parael modelo espiral se logra por medio de invocar una o más de las siguientes acciones de software: hacer prototipos, análisis y diseño.11La figura 2.8 muestra la representación esquemática de una actividad de ingeniería de software dentro de la actividad de modelado con el uso del enfoque de modelado concurrente. LaSi su administración pide undesarrollo apegado al presupuesto(mala idea, por lo general), laespiral se convierte en un problema.El costo se revisa y modifica cadavez que se termina un circuito.CONSEJOWebRefEn la dirección www.sei.cmu.edu/publications/documents/00.reports/00sr008.html se encuentrainformación útil sobre el modeloespiral.Cita:“Sólo voy aquí y sólo el mañaname guía.”Dave Matthews Band10 Las flechas que apuntan hacia dentro a lo largo del eje que separa la región del despliegue de la de comunicación indican un potencial para la iteración local a lo largo de la misma trayectoria espiral.11 Debe observarse que el análisis y diseño son tareas complejas que requieren mucho análisis. La parte 2 de estelibro considera en detalle dichos temas.Con frecuencia, el modeloconcurrente es más apropiado paraproyectos de ingeniería de productosen los que se involucran variosequipos de trabajo.CONSEJO02Pressman(025-054).indd 40 14/1/10 13:36:49CAPÍTULO 2 MODELOS DEL PROCESO 41Selección de un modelo de proceso,parte 2La escena: Sala de juntas del grupo de ingeniería de software deCPI Corporation, compañía que manufactura productos de consumopara uso doméstico y comercial.Participantes: Lee Warren, gerente de ingeniería; Doug Miller,gerente de ingeniería de software; Vinod y Jamie, miembros delequipo de ingeniería de software.La conversación: [Doug describe las opciones de proceso evolutivo.]Jamie: Ahora me doy cuenta de algo. El enfoque incremental tienesentido, y en verdad me gusta el flujo del modelo en espiral. Es bastante realista.Vinod: De acuerdo. Entregamos un incremento, aprendemos de laretroalimentación del cliente, volvemos a planear y luego entregamosotro incremento. También se ajusta a la naturaleza del producto.Podemos lanzar con rapidez algo al mercado y luego agregar funcionalidad con cada versión, digo… con cada incremento.Lee: Un momento. Doug, ¿dijiste que volveríamos a hacer el plan acada vuelta de la espiral? Eso no es nada bueno; necesitamos unplan, un programa de actividades y apegarnos a ellos.Doug: Ésa es la vieja escuela, Lee. Como dijeron los chicos, tenemos que hacerlo apegado a la realidad. Afirmo que es mejor afinarel plan a medida de que aprendamos más y conforme se solicitencambios. Eso es más realista. ¿Qué sentido tiene un plan si no reflejala realidad?Lee (con el ceño fruncido): Supongo, pero… a la alta direcciónno le va a gustar… quieren un plan fijo.Doug (sonriente): Entonces tendrás que reeducarlos, amigo.CASASEGURAEn revisiónAlcance mínimoEnevaluaciónCambiosen esperaEndesarrolloInactivoActividad de modeladoRepresenta el estadode una actividad otarea de la ingenieríade softwareTerminadoFIGURA 2.8Un elementodel modelode procesoconcurrenteactividad —modelado— puede estar en cualquiera de los estados12 mencionados en un momento dado. En forma similar, es posible representar de manera análoga otras actividades,acciones o tareas (por ejemplo, comunicación o construcción). Todas las actividades de ingeniería de software existen de manera concurrente, pero se hallan en diferentes estados.12 Un estado es algún modo de comportamiento observable externamente.02Pressman(025-054).indd 41 14/1/10 13:36:4942 PARTE UNO EL PROCESO DEL SOFTWAREPor ejemplo, la actividad de comunicación (no se muestra en la figura) termina su primeraiteración al principio de un proyecto y existe en el estado de cambios en espera. La actividadde modelado (que existía en estado inactivo mientras concluía la comunicación inicial, ahorahace una transición al estado en desarrollo. Sin embargo, si el cliente indica que deben hacersecambios en los requerimientos, la actividad de modelado pasa del estado en desarrollo al decambios en espera.El modelado concurrente define una serie de eventos que desencadenan transiciones de unestado a otro para cada una de las actividades, acciones o tareas de la ingeniería de software.Por ejemplo, durante las primeras etapas del diseño (acción importante de la ingeniería de software que ocurre durante la actividad de modelado), no se detecta una inconsistencia en elmodelo de requerimientos. Esto genera el evento corrección del modelo de análisis, que dispararála acción de análisis de requerimientos del estado terminado al de cambios en espera.El modelado concurrente es aplicable a todos los tipos de desarrollo de software y proporciona un panorama apropiado del estado actual del proyecto. En lugar de confinar las actividades, acciones y tareas de la ingeniería de software a una secuencia de eventos, define una reddel proceso. Cada actividad, acción o tarea de la red existe simultáneamente con otras actividades, acciones o tareas. Los eventos generados en cierto punto de la red del proceso desencadenan transiciones entre los estados.2.3.5 Una última palabra acerca de los procesos evolutivosYa se dijo que el software de cómputo moderno se caracteriza por el cambio continuo, por tiempos de entrega muy apretados y por una necesidad apremiante de la satisfacción del cliente ousuario. En muchos casos, el tiempo para llegar al mercado es el requerimiento administrativomás importante. Si se pierde un nicho de mercado, todo el proyecto de software podría carecerde sentido.13Los modelos de proceso evolutivo fueron concebidos para cumplir esos requisitos, pero, aunasí, como clase general de modelos de proceso tienen demasiadas debilidades, que fueron resumidas por Nogueira y sus colegas [Nog00]:A pesar de los beneficios incuestionables de los procesos evolutivos de software, existen algunas preocupaciones. La primera es que hacer prototipos (y otros procesos evolutivos más sofisticados) planteaun problema para la planeación del proyecto debido a la incertidumbre en el número de ciclos que serequieren para elaborar el producto. La mayor parte de técnicas de administración y estimación de proyectos se basa en un planteamiento lineal de las actividades, por lo que no se ajustan por completo.En segundo lugar, los procesos evolutivos de software no establecen la velocidad máxima de laevolución. Si las evoluciones ocurren demasiado rápido, sin un periodo de relajamiento, es seguro queel proceso se volverá un caos. Por otro lado, si la velocidad es muy lenta, se verá perjudicada la productividad…En tercer lugar, los procesos de software deben centrarse en la flexibilidad y capacidad de extensión en lugar de en la alta calidad. Esto suena preocupante. Sin embargo, debe darse prioridad a lavelocidad del desarrollo con el enfoque de cero defectos. Extender el desarrollo a fin de lograr altacalidad podría dar como resultado la entrega tardía del producto, cuando haya desaparecido el nichode oportunidad. Este cambio de paradigma es impuesto por la competencia al borde del caos.En realidad, sí parece preocupante un proceso del software que se centre en la flexibilidad,expansión y velocidad del desarrollo por encima de la calidad. No obstante, esta idea ha sidopropuesta por varios expertos en ingeniería de software muy respetados ([You95], [Bac97]).Cita:“Todo proceso en su organización tiene un cliente, y unproceso sin cliente no tiene propósito.”V. Daniel Hunt13 Sin embargo, es importante notar que ser el primero en llegar al mercado no es garantía de éxito. En realidad,muchos productos de software muy exitosos han llegado en segundo o hasta en tercer lugar al mercado (aprenden de los errores de sus antecesores).02Pressman(025-054).indd 42 14/1/10 13:36:50CAPÍTULO 2 MODELOS DEL PROCESO 43El objetivo de los modelos evolutivos es desarrollar software de alta calidad14 en forma iterativa o incremental. Sin embargo, es posible usar un proceso evolutivo para hacer énfasis en laflexibilidad, expansibilidad y velocidad del desarrollo. El reto para los equipos de software y susadministradores es establecer un balance apropiado entre estos parámetros críticos del proyecto y el producto, y la satisfacción del cliente (árbitro definitivo de la calidad del software). 2.4 MODELOS DE PROCESO ESPECIALIZADOLos modelos de proceso especializado tienen muchas de las características de uno o más de losmodelos tradicionales que se presentaron en las secciones anteriores. Sin embargo, dichos modelos tienden a aplicarse cuando se elige un enfoque de ingeniería de software especializadoo definido muy específicamente.152.4.1 Desarrollo basado en componentesLos componentes comerciales de software general (COTS, por sus siglas en inglés), desarrollados por vendedores que los ofrecen como productos, brindan una funcionalidad que se persiguecon interfaces bien definidas que permiten que el componente se integre en el software que seva a construir. El modelo de desarrollo basado en componentes incorpora muchas de las características del modelo espiral. Es de naturaleza evolutiva [Nie92] y demanda un enfoque iterativopara la creación de software. Sin embargo, el modelo de desarrollo basado en componentesconstruye aplicaciones a partir de fragmentos de software prefabricados.Las actividades de modelado y construcción comienzan con la identificación de candidatosde componentes. Éstos pueden diseñarse como módulos de software convencional o clasesorientadas a objetos o paquetes16 de clases. Sin importar la tecnología usada para crear loscomponentes, el modelo de desarrollo basado en componentes incorpora las etapas siguientes(se implementan con el uso de un enfoque evolutivo): 1. Se investigan y evalúan, para el tipo de aplicación de que se trate, productos disponibles basados en componentes.2. Se consideran los aspectos de integración de los componentes.3. Se diseña una arquitectura del software para que reciba los componentes.4. Se integran los componentes en la arquitectura.5. Se efectúan pruebas exhaustivas para asegurar la funcionalidad apropiada.El modelo del desarrollo basado en componentes lleva a la reutilización del software, y esoda a los ingenieros de software varios beneficios en cuanto a la mensurabilidad. Si la reutilización de componentes se vuelve parte de la cultura, el equipo de ingeniería de software tiene laposibilidad tanto de reducir el ciclo de tiempo del desarrollo como el costo del proyecto. En elcapítulo 10 se analiza con más detalle el desarrollo basado en componentes.14 En este contexto, la calidad del software se define con mucha amplitud para que agrupe no sólo la satisfaccióndel cliente sino también varios criterios técnicos que se estudian en los capítulos 14 y 16.15 En ciertos casos, los modelos de proceso especializado pueden caracterizarse mejor como un conjunto de técnicas o “metodología” para alcanzar una meta específica de desarrollo de software. No obstante, implican unproceso.16 En el apéndice 2 se estudian los conceptos orientados a objetos, y se utilizan en toda la parte 2 del libro. En estecontexto, una clase agrupa un conjunto de datos y los procedimientos para procesarlos. Un paquete de clases esun conjunto de clases relacionadas que funcionan juntas para alcanzar cierto resultado final.WebRefEn la dirección www.cbd-hq.comhay información útil sobre el desarrollobasado en componentes.02Pressman(025-054).indd 43 14/1/10 13:36:5044 PARTE UNO EL PROCESO DEL SOFTWARE2.4.2 El modelo de métodos formalesEl modelo de métodos formales agrupa actividades que llevan a la especificación matemáticaformal del software de cómputo. Los métodos formales permiten especificar, desarrollar y verificar un sistema basado en computadora por medio del empleo de una notación matemáticarigurosa. Ciertas organizaciones de desarrollo de software aplican una variante de este enfoque,que se denomina ingeniería de software de quirófano [Mil87, Dye92].Cuando durante el desarrollo se usan métodos formales (capítulo 21), se obtiene un mecanismo para eliminar muchos de los problemas difíciles de vencer con otros paradigmas de laingeniería de software. Lo ambiguo, incompleto e inconsistente se descubre y corrige con másfacilidad, no a través de una revisión ad hoc sino con la aplicación de análisis matemático. Sidurante el diseño se emplean métodos formales, éstos sirven como base para la verificación delprograma, y así permiten descubrir y corregir errores que de otro modo no serían detectados.Aunque el modelo de los métodos formales no es el más seguido, promete un software librede defectos. Sin embargo, se han expresado preocupaciones acerca de su aplicabilidad en unambiente de negocios:• El desarrollo de modelos formales consume mucho tiempo y es caro.• Debido a que pocos desarrolladores de software tienen la formación necesaria paraaplicar métodos formales, se requiere mucha capacitación.• Es difícil utilizar los modelos como mecanismo de comunicación para clientes sincomplejidad técnica.A pesar de estas preocupaciones, el enfoque de los métodos formales ha ganado partidariosentre los desarrolladores que deben construir software de primera calidad en seguridad (porejemplo, control electrónico de aeronaves y equipos médicos), y entre los desarrolladores quesufrirían graves pérdidas económicas si ocurrieran errores en su software.2.4.3 Desarrollo de software orientado a aspectosSin importar el proceso del software que se elija, los constructores de software complejo implementan de manera invariable un conjunto de características, funciones y contenido de información localizados. Estas características localizadas del software se modelan como componentes(clases orientadas a objetos) y luego se construyen dentro del contexto de una arquitectura desistemas. A medida que los sistemas modernos basados en computadora se hacen más sofisticados (y complejos), ciertas preocupaciones —propiedades que requiere el cliente o áreas deinterés técnico— se extienden a toda la arquitectura. Algunas de ellas son las propiedadesde alto nivel de un sistema (por ejemplo, seguridad y tolerancia a fallas). Otras afectan a funciones (aplicación de las reglas de negocios), mientras que otras más son sistémicas (sincronización de la tarea o administración de la memoria).Cuando las preocupaciones afectan múltiples funciones, características e información delsistema, es frecuente que se les llame preocupaciones globales. Los requerimientos del aspectodefinen aquellas preocupaciones globales que tienen algún efecto a través de la arquitectura delsoftware. El desarrollo de software orientado a aspectos (DSOA), conocido también como programación orientada a aspectos (POA), es un paradigma de ingeniería de software relativamentenuevo que proporciona un proceso y enfoque metodológico para definir, especificar, diseñar yconstruir aspectos: “mecanismos más allá de subrutinas y herencia para localizar la expresiónde una preocupación global” [Elr01].Grundy [Gru02] analiza con más profundidad los aspectos en el contexto de lo que denominaingeniería de componentes orientada a aspectos (ICOA):La ICOA usa el concepto de rebanadas horizontales a través de componentes de software descompuestos verticalmente, llamados “aspectos”, para caracterizar las propiedades globales funcionales yPUNTOCLAVEEl DSOA define “aspectos” queexpresan preocupaciones del clienteque afectan múltiples funciones,características e información delsistema.Si con los métodosformales puededemostrarse lo correctode un software, ¿porqué no son ampliamenteutilizados??WebRefExisten muchos recursos e informaciónsobre SOA en la dirección: aosd.net02Pressman(025-054).indd 44 14/1/10 13:36:50CAPÍTULO 2 MODELOS DEL PROCESO 45no funcionales de los componentes. Los aspectos comunes y sistémicos incluyen interfaces de usuario, trabajo en colaboración, distribución, persistencia, administración de la memoria, procesamientode las transacciones, seguridad, integridad, etc. Los componentes pueden proveer o requerir uno omás “detalles de aspectos” en relación con un aspecto particular, como un mecanismo de visión, alcance extensible y clase de interfaz (aspectos de la interfaz de usuario); generación de eventos, transporte y recepción (aspectos de distribución); almacenamiento, recuperación e indización de datos(aspectos de persistencia); autenticación, encriptación y derechos de acceso (aspectos de seguridad);descomposición de las transacciones, control de concurrencia y estrategia de registro (aspectos de lastransacciones), entre otros. Cada detalle del aspecto tiene cierto número de propiedades relacionadascon las características funcionales o no del detalle del aspecto.Aún no madura un proceso distinto orientado a aspectos. Sin embargo, es probable que unproceso así adopte características tanto de los modelos de proceso evolutivo como concurrente.El modelo evolutivo es apropiado en tanto los aspectos se identifican y después se construyen.La naturaleza paralela del desarrollo concurrente es esencial porque la ingeniería de aspectosse hace en forma independiente de los componentes de software localizados; aun así, los aspectos tienen un efecto directo sobre éstos. De esta forma, es esencial disponer de comunicación asincrónica entre las actividades de proceso del software aplicadas a la ingeniería, y laconstrucción de los aspectos y componentes.El análisis detallado del desarrollo de software orientado al aspecto se deja a libros especializados en el tema. Si el lector tiene interés en profundizar, se le invita a consultar [Saf08],[Cla05], [Jac04] y [Gra03].Administración del procesoObjetivo: Ayudar a la definición, ejecución y administración de modelos de proceso prescriptivo.Mecánica: Las herramientas de administración del proceso permitenque una organización o equipo de software defina un modelo completo del proceso (actividades estructurales, acciones, tareas, aseguramiento de la calidad, puntos de revisión, referencias y productos deltrabajo). Además, las herramientas proporcionan un mapa conformelos ingenieros de software realizan el trabajo técnico, y una plantillapara los gerentes que deben dar seguimiento y controlar el procesodel software.Herramientas representativas:17GDPA, grupo de herramientas de investigación de definición del proceso, desarrollada por la Universidad de Bremen, en Alemania(www.informatik.uni-bremen.de/uniform/gdpa/home.htm), proporciona una amplia variedad de funcionespara modelar y administrar procesos.SpeeDev, desarrollada por SpeeDev Corporation (www.speedev.com), incluye un conjunto de herramientas para la definición delproceso, administración de los requerimientos, resolución de problemas, y planeación y seguimiento del proyecto.ProVision BPMx, desarrollado por Proforma (www.proformacorp.com), es representativo de muchas herramientas que ayudan a definir el proceso y que automatizan el flujo del trabajo.En la dirección www.processwave.net/Links/tool_links.htm, se encuentra una lista extensa de muchas herramientas diferentes asociadas con el proceso del software.HERRAMIENTAS DE SOFTWARE17 Las herramientas mencionadas aquí no representan una obligación; sólo son una muestra de las de esta categoría. En la mayoría de casos, los nombres de las herramientas son marcas registradas por sus desarrolladoresrespectivos. 2.5 EL PROCESO UNIFICADOEn su libro fundamental, Unified Process, Ivar Jacobson, Grady Booch y James Rumbaugh [Jac99]analizan la necesidad de un proceso del software “impulsado por el caso de uso, centrado en laarquitectura, iterativo e incremental”, con la afirmación siguiente:02Pressman(025-054).indd 45 14/1/10 13:36:5146 PARTE UNO EL PROCESO DEL SOFTWAREEn la actualidad, la tendencia en el software es hacia sistemas más grandes y complejos. Eso se debeen parte al hecho de que año tras año las computadoras son más poderosas, lo que hace que losusuarios esperen más de ellas. Esta tendencia también se ha visto influida por el uso creciente de internet para intercambiar toda clase de información […] Nuestro apetito por software cada vez mássofisticado aumenta conforme aprendemos, entre un lanzamiento y otro de un producto, cómo mejorar éste. Queremos software que se adapte mejor a nuestras necesidades, pero eso a su vez lo hacemás complejo. En pocas palabras, queremos más.En cierto modo, el proceso unificado es un intento por obtener los mejores rasgos y características de los modelos tradicionales del proceso del software, pero en forma que implementemuchos de los mejores principios del desarrollo ágil de software (véase el capítulo 3). El procesounificado reconoce la importancia de la comunicación con el cliente y los métodos directos paradescribir su punto de vista respecto de un sistema (el caso de uso).18 Hace énfasis en la importancia de la arquitectura del software y “ayuda a que el arquitecto se centre en las metas correctas, tales como que sea comprensible, permita cambios futuros y la reutilización” [Jac99]: Sugiere un flujo del proceso iterativo e incremental, lo que da la sensación evolutiva que resultaesencial en el desarrollo moderno del software.2.5.1 Breve historiaAl principio de la década de 1990, James Rumbaugh [Rum91], Grady Booch [Boo94] e Ivar Jacobson [Jac92] comenzaron a trabajar en un “método unificado” que combinaría lo mejor de cadauno de sus métodos individuales de análisis y diseño orientado a objetos. El resultado fue unUML, lenguaje de modelado unificado, que contiene una notación robusta para el modelado ydesarrollo de los sistemas orientados a objetos.El UML se utiliza en toda la parte 2 del libro para representar tanto los modelos de requerimientos como el diseño. En el apéndice 1 se presenta un método introductorio a la enseñanzapara quienes no están familiarizados con las reglas básicas de notación y modelado con el UML.El estudio exhaustivo del UML se deja a libros dedicados al tema. En el apéndice 1 se enlistanlos textos recomendables.El UML brinda la tecnología necesaria para apoyar la práctica de la ingeniería de softwareorientada a objetos, pero no da la estructura del proceso que guíe a los equipos del proyectocuando aplican la tecnología. En los siguientes años, Jacobson, Rumbaugh y Booch desarrollaron el proceso unificado, estructura para la ingeniería de software orientado a objetos que utilizaUML. Actualmente, el proceso unificado (PU) y el UML se usan mucho en proyectos de toda claseorientados a objetos. El modelo iterativo e incremental propuesto por el PU puede y debe adaptarse para que satisfaga necesidades específicas del proyecto.2.5.2 Fases del proceso unificado19Al principio de este capítulo se estudiaron cinco actividades estructurales generales y se dijo quepodían usarse para describir cualquier modelo de proceso del software. El proceso unificado noes la excepción. La figura 2.9 ilustra las “fases” del PU y las relaciona con las actividades generales estudiadas en el capítulo 1 y al inicio de éste.La fase de concepción del PU agrupa actividades tanto de comunicación con el cliente comode planeación. Al colaborar con los participantes, se identifican los requerimientos del negocio,18 El caso de uso (véase el capítulo 5) es la narración o plantilla que describe una función o rasgo de un sistemadesde el punto de vista del usuario. Éste escribe un caso en uso que sirve como base para la creación de unmodelo de requerimientos más completos.19 El proceso unificado en ocasiones recibe el nombre de Proceso Racional Unificado (PRU), acuñado por RationalCorporation (adquirida posteriormente por IBM), que contribuyó desde el principio al desarrollo y mejora del PUy a la elaboración de ambientes completos (herramientas y tecnología) que apoyan el proceso.PUNTOCLAVELas fases del PU tienen un objetivosimilar al de las actividadesestructurales generales definidas eneste libro.02Pressman(025-054).indd 46 14/1/10 13:36:51CAPÍTULO 2 MODELOS DEL PROCESO 47se propone una arquitectura aproximada para el sistema y se desarrolla un plan para la naturaleza iterativa e incremental del proyecto en cuestión. Los requerimientos fundamentales delnegocio se describen por medio de un conjunto de casos de uso preliminares (véase el capítulo5) que detallan las características y funciones que desea cada clase principal de usuarios. En estepunto, la arquitectura no es más que un lineamiento tentativo de subsistemas principales y lafunción y rasgos que tienen. La arquitectura se mejorará después y se expandirá en un conjuntode modelos que representarán distintos puntos de vista del sistema. La planeación identifica losrecursos, evalúa los riesgos principales, define un programa de actividades y establece una basepara las fases que se van a aplicar a medida que avanza el incremento del software.La fase de elaboración incluye las actividades de comunicación y modelado del modelo general del proceso (véase la figura 2.9). La elaboración mejora y amplía los casos de uso preliminares desarrollados como parte de la fase de concepción y aumenta la representación de la arquitectura para incluir cinco puntos de vista distintos del software: los modelos del caso de uso, derequerimientos, del diseño, de la implementación y del despliegue. En ciertos casos, la elaboración crea una “línea de base de la arquitectura ejecutable” [Arl02] que representa un sistemaejecutable de “primer corte”.20 La línea de base de la arquitectura demuestra la viabilidad de ésta,pero no proporciona todas las características y funciones que se requieren para usar el sistema.Además, al terminar la fase de elaboración se revisa con cuidado el plan a fin de asegurar queel alcance, riesgos y fechas de entrega siguen siendo razonables. Es frecuente que en este momento se hagan modificaciones al plan.La fase de construcción del PU es idéntica a la actividad de construcción definida para el proceso general del software. Con el uso del modelo de arquitectura como entrada, la fase deconstrucción desarrolla o adquiere los componentes del software que harán que cada casode uso sea operativo para los usuarios finales. Para lograrlo, se completan los modelos de requerimientos y diseño que se comenzaron durante la fase de elaboración, a fin de que reflejenla versión final del incremento de software. Después se implementan en código fuente todas lascaracterísticas y funciones necesarias para el incremento de software (por ejemplo, el lanzamiento). A medida de que se implementan los componentes, se diseñan y efectúan pruebasunitarias21 para cada uno. Además, se realizan actividades de integración (ensamble de compoTransiciónProducciónincremento del softwareLanzamientomodeladoconstrucciónplaneacióncomunicacióndespliegueConstrucciónConcepciónElaboración FIGURA 2.9El procesounificado20 Es importante darse cuenta de que la línea de base de la arquitectura no es un prototipo y que no se desecha. Porel contrario, es revestida durante la fase siguiente del PU.21 En los capítulos 17 a 20 se presenta el análisis exhaustivo de las pruebas del software (incluso las pruebas unitarias).WebRefEn la dirección www.ambysoft.com/unifiedprocess/agileUP.html, se encuentra un análisisinteresante del PU en el contexto deldesarrollo ágil.02Pressman(025-054).indd 47 14/1/10 13:36:5148 PARTE UNO EL PROCESO DEL SOFTWAREnentes y pruebas de integración). Se emplean casos de uso para obtener un grupo de pruebasde aceptación que se ejecutan antes de comenzar la siguiente fase del PU.La fase de transición del PU incluye las últimas etapas de la actividad general de construccióny la primera parte de la actividad de despliegue general (entrega y retroalimentación). Se da elsoftware a los usuarios finales para las pruebas beta, quienes reportan tanto los defectos comolos cambios necesarios. Además, el equipo de software genera la información de apoyo necesaria (por ejemplo, manuales de usuario, guías de solución de problemas, procedimientos deinstalación, etc.) que se requiere para el lanzamiento. Al finalizar la fase de transición, el software incrementado se convierte en un producto utilizable que se lanza.La fase de producción del PU coincide con la actividad de despliegue del proceso general.Durante esta fase, se vigila el uso que se da al software, se brinda apoyo para el ambiente deoperación (infraestructura) y se reportan defectos y solicitudes de cambio para su evaluación.Es probable que al mismo tiempo que se llevan a cabo las fases de construcción, transicióny producción, comience el trabajo sobre el siguiente incremento del software. Esto significa quelas cinco fases del PU no ocurren en secuencia sino que concurren en forma escalonada.El flujo de trabajo de la ingeniería de software está distribuido a través de todas las fases delPU. En el contexto de éste, un flujo de trabajo es análogo al conjunto de tareas (que ya se describió en este capítulo). Es decir, un flujo de trabajo identifica las tareas necesarias para completaruna acción importante de la ingeniería de software y los productos de trabajo que se generancomo consecuencia de la terminación exitosa de aquéllas. Debe notarse que no toda tarea identificada para el flujo de trabajo del PU es realizada en todos los proyectos de software. El equipoadapta el proceso (acciones, tareas, subtareas y productos del trabajo) a fin de que cumpla susnecesidades. 2.6 MODELOS DEL PROCESO PERSONAL Y DEL EQUIPOEl mejor proceso del software es el que está cerca de las personas que harán el trabajo. Si unmodelo del proceso del software se ha desarrollado en un nivel corporativo u organizacional,será eficaz sólo si acepta una adaptación significativa para que cubra las necesidades del equipode proyecto que en realidad hace el trabajo de ingeniería de software. En la situación ideal secrearía un proceso que se ajustara del mejor modo a los requerimientos, y al mismo tiempocubriera las más amplias necesidades del equipo y de la organización. En forma alternativa, elequipo crearía un proceso propio que satisficiera las necesidades más estrechas de los individuos y las más generales de la organización. Watts Humphrey ([Hum97] y [Hum00]) afirma quees posible crear un “proceso personal de software” y/o un “proceso del equipo de software”.Ambos requieren trabajo duro, capacitación y coordinación, pero los dos son asequibles.222.6.1 Proceso personal del software (PPS)Todo desarrollador utiliza algún proceso para elaborar software de cómputo. El proceso puedeser caprichoso o ad hoc; quizá cambie a diario; tal vez no sea eficiente, eficaz o incluso no sirva;pero sí existe un “proceso”. Watts Humphrey [Hum97] sugiere que a fin de cambiar un procesopersonal ineficaz, un individuo debe pasar por las cuatro fases, cada una de las cuales requierecapacitación e instrumentación cuidadosa. El proceso personal del software (PPS) pone el énfasisen la medición personal tanto del producto del trabajo que se genera como de su calidad. Además, el PPS responsabiliza al profesional acerca de la planeación del proyecto (por ejemplo,22 Es útil notar que quienes proponen un desarrollo ágil del software (véase el capítulo 3) también plantean que elproceso debe ser cercano al equipo. Para lograr esto sugieren un método alternativo.Cita:“La persona que es exitosa tansólo se ha hecho el hábito dehacer las cosas que no hacen laspersonas que no tienen éxito.”Dexter YagerWebRefEn la dirección www.ipd.uka.de/PSP, se hallan muchos recursos parael PPS.02Pressman(025-054).indd 48 14/1/10 13:36:51CAPÍTULO 2 MODELOS DEL PROCESO 49estimación y programación de actividades) y delega en el practicante el poder de controlar lacalidad de todos los productos del trabajo de software que se desarrollen. El modelo del PPSdefine cinco actividades estructurales:Planeación. Esta actividad aísla los requerimientos y desarrolla las estimaciones tantodel tamaño como de los recursos. Además, realiza la estimación de los defectos (el númerode defectos proyectados para el trabajo). Todas las mediciones se registran en hojas de trabajo o plantillas. Por último, se identifican las tareas de desarrollo y se crea un programapara el proyecto.Diseño de alto nivel. Se desarrollan las especificaciones externas para cada componente que se va a construir y se crea el diseño de componentes. Si hay incertidumbre, seelaboran prototipos. Se registran todos los aspectos relevantes y se les da seguimiento.Revisión del diseño de alto nivel. Se aplican métodos de verificación formal (véase elcapítulo 21) para descubrir errores en el diseño. Se mantienen las mediciones para todaslas tareas y resultados del trabajo importantes.Desarrollo. Se mejora y revisa el diseño del componente. El código se genera, revisa,compila y prueba. Las mediciones se mantienen para todas las tareas y resultados de trabajo de importancia.Post mórtem. Se determina la eficacia del proceso por medio de medidas y medicionesobtenidas (ésta es una cantidad sustancial de datos que deben analizarse con métodos estadísticos). Las medidas y mediciones deben dar la guía para modificar el proceso a fin demejorar su eficacia.El PPS enfatiza la necesidad de detectar pronto los errores; de igual importancia es entenderlos tipos de ellos que es probable cometer. Esto se logra a través de una actividad de evaluaciónrigurosa ejecutada para todos los productos del trabajo que se generen.El PPS representa un enfoque disciplinado basado en la medición para la ingeniería de software que quizá sea un choque cultural para muchos de sus practicantes. Sin embargo, cuandose introduce el PPS en forma apropiada en los ingenieros de software [Hum96], es significativala mejora resultante en la productividad de la ingeniería respectiva y en la calidad del software[Fer97]. No obstante, el PPS no ha sido adoptado con amplitud por la industria. Es triste reconocer que las razones de esto tienen que ver más con la naturaleza humana y la inercia organizacional que con las fortalezas y debilidades del enfoque del PPS. Dicho enfoque plantea desafíosintelectuales y demanda un nivel de compromiso (por parte de los practicantes y sus administradores) que no siempre es posible obtener. La capacitación es relativamente larga y sus costoselevados. El nivel requerido de las mediciones es culturalmente difícil para muchas personas dela comunidad del software.¿Es posible usar el PPS como un proceso eficaz de software a nivel personal? La respuesta esun rotundo “sí”. Pero aun si no se adoptara por completo el PPS, muchos de los conceptos delproceso de mejora personal que introduce constituyen un aprendizaje provechoso.2.6.2 Proceso del equipo de software (PES)Debido a que muchos proyectos de software industrial son elaborados por un equipo de profesionales, Watts Humphrey extendió las lecciones aprendidas de la introducción del PPS y propuso un proceso del equipo de software (PES). El objetivo de éste es construir un equipo “autodirigido” para el proyecto, que se organice para producir software de alta calidad. Humphrey[Hum98] define los objetivos siguientes para el PES:• Formar equipos autodirigidos que planeen y den seguimiento a su trabajo, que establezcan metas y que sean dueños de sus procesos y planes. Éstos pueden ser equipos desoftware puros o de productos integrados (EPI) constituidos por 3 a 20 ingenieros.¿Qué actividadesestructurales se usandurante el PPS??PUNTOCLAVEEl PPS pone el énfasis en lanecesidad de registrar y analizar lostipos de errores que se cometen, demodo que se desarrollen estrategiaspara eliminarlos.WebRefEn la dirección www.sei.cmu.edu/tsp/, hay información sobre laformación de equipos de altorendimiento que usan PES y PPS.02Pressman(025-054).indd 49 14/1/10 13:36:5250 PARTE UNO EL PROCESO DEL SOFTWARE• Mostrar a los gerentes cómo dirigir y motivar a sus equipos y cómo ayudarlos amantener un rendimiento máximo.• Acelerar la mejora del proceso del software, haciendo del modelo de madurez de lacapacidad, CMM,23 nivel 5, el comportamiento normal y esperado.• Brindar a las organizaciones muy maduras una guía para la mejora.• Facilitar la enseñanza universitaria de aptitudes de equipo con grado industrial.Un equipo autodirigido tiene la comprensión consistente de sus metas y objetivos generales;define el papel y responsabilidad de cada miembro del equipo; da seguimiento cuantitativo a losdatos del proyecto (sobre la productividad y calidad); identifica un proceso de equipo que seaapropiado para el proyecto y una estrategia para implementarlo; define estándares locales aplicables al trabajo de ingeniería de software del equipo; evalúa en forma continua el riesgo y reacciona en consecuencia; y da seguimiento, administra y reporta el estado del proyecto.El PES define las siguientes actividades estructurales: inicio del proyecto, diseño de altonivel, implementación, integración y pruebas, y post mórtem. Como sus contrapartes delPPS (observe que la terminología es algo diferente), estas actividades permiten que el equipoplanee, diseñe y construya software en forma disciplinada, al mismo tiempo que mide cuantitativamente el proceso y el producto. La etapa post mórtem es el escenario de las mejoras delproceso.El PES utiliza una variedad amplia de scripts, formatos y estándares que guían a los miembrosdel equipo en su trabajo. Los scripts definen actividades específicas del proceso (por ejemplo,inicio del proyecto, diseño, implementación, integración y pruebas del sistema, y post mórtem),así como otras funciones más detalladas del trabajo (planeación del desarrollo, desarrollo derequerimientos, administración de la configuración del software y prueba unitaria) que formanparte del proceso de equipo.El PES reconoce que los mejores equipos de software son los autodirigidos.24 Los miembrosdel equipo establecen los objetivos del proyecto, adaptan el proceso para que cubra las necesidades, controlan la programación de actividades del proyecto y, con la medida y análisis de lasmediciones efectuadas, trabajan de manera continua en la mejora del enfoque de ingeniería desoftware que tiene el equipo.Igual que el PPS, el PES es un enfoque riguroso para la ingeniería de software y proporcionabeneficios distintivos y cuantificables en productividad y calidad. El equipo debe tener un compromiso total con el proceso y recibir capacitación completa para asegurar que el enfoque seaplique en forma apropiada. 2.7 TECNOLOGÍA DEL PROCESOEl equipo del software debe adaptar uno o más de los modelos del proceso estudiados en lassecciones precedentes. Para ello, se han desarrollado herramientas de tecnología del proceso queayudan a las organizaciones de software a analizar su proceso actual, organizar las tareas detrabajo, controlar y vigilar el avance, y administrar la calidad técnica.Las herramientas de tecnología del proceso permiten que una organización de softwareconstruya un modelo automatizado de la estructura del proceso, conjuntos de tareas y actividades sombrilla, estudiados en la sección 2.1. El modelo, que normalmente se representa como23 El modelo de madurez de la capacidad (CMM), que es una medida de la eficacia de un proceso del software, seestudia en el capítulo 30.24 En el capítulo 31 se analiza la importancia de los equipos “autoorganizados” como elemento clave del desarrolloágil del software.PUNTOCLAVELos scripts del PES definenelementos del proceso del equipo yde las actividades que ocurren dentrodel proceso.Para formar un equipo autodirigido,usted debe colaborar bien en lointerno y comunicarse bien en loexterno.CONSEJO02Pressman(025-054).indd 50 14/1/10 13:36:52CAPÍTULO 2 MODELOS DEL PROCESO 51una red, se analiza para determinar el flujo de trabajo normal y se examinan estructuras alternativas del proceso que podrían llevar a disminuir el tiempo o costo del desarrollo.Una vez creado un proceso aceptable, se emplean otras herramientas de tecnología paraasignar, vigilar e incluso controlar todas las actividades, acciones y tareas de la ingeniería desoftware definidas como parte del modelo del proceso. Cada miembro de un equipo de softwareutiliza dichas herramientas para desarrollar una lista de verificación de las tareas de trabajo quedeben realizarse. La herramienta de tecnología del proceso también se usa para coordinar elempleo de otras herramientas de la ingeniería de software que sean apropiadas para una tareaparticular del trabajo.25 Las herramientas mencionadas aquí no son obligatorias, sino una muestra de las que hay en esta categoría. En lamayoría de casos, los nombres de las herramientas son marcas registradas por sus respectivos desarrolladores.Herramientas de modelado del procesoObjetivo: Si una organización trabaja para mejorar unproceso (o software) de negocios, primero debe entenderlo. Las herramientas de modelado del proceso (también llamadasherramientas de tecnología del proceso o de administración del proceso) se usan para representar los elementos clave de un proceso, demodo que se entienda mejor. Dichas herramientas también se relacionan con descripciones del proceso que ayudan a los involucrados aentender las acciones y tareas del trabajo que se requieren para llevarlo a cabo. Las herramientas de modelado del proceso tienen vínculos con otras que dan apoyo a las actividades del proceso definido.Mecánica: Las herramientas en esta categoría permiten que unequipo defina los elementos de un modelo de proceso único (acciones, tareas, productos del trabajo, puntos de aseguramiento de lacalidad, etc.), dan una guía detallada acerca del contenido o descripción de cada elemento del proceso, y después administran el procesoconforme se realiza. En ciertos casos, las herramientas de tecnologíadel proceso incorporan tareas estándar de administración de proyectos, tales como estimación, programación, seguimiento y control.Herramientas representativas:25Igrafx Process Tools: herramientas que permiten que un equipomapee, mida y modele el proceso del software (www.micrografx.com)Adeptia BPM Server: diseñado para administrar, automatizar y optimizar procesos de negocios (www.adptia.com)SpeedDev Suite: conjunto de seis herramientas con mucho énfasis enlas actividades de administración de la comunicación y modelado(www.speedev.com)HERRAMIENTAS DE SOFTWARE 2.8 PRODUCTO Y PROCESOSi el proceso es deficiente, no cabe duda de que el producto final sufrirá. Pero también es peligrosa la dependencia excesiva del proceso. En un ensayo corto escrito hace muchos años,Margaret Davis [Dav95a] hace comentarios atemporales sobre la dualidad del producto y delproceso:Cada diez años, más o menos, la comunidad del software redefine “el problema” por medio de cambiarsu atención de aspectos del producto a aspectos del proceso. Así, hemos adoptado lenguajes de programación estructurada (producto) seguidos de métodos de análisis estructurados (proceso) que vanseguidos por el encapsulamiento de datos (producto) a los que siguieron el énfasis actual en el modelode madurez de la capacidad, del Instituto de Ingeniería de Software para el Desarrollo de Software(proceso) (seguido por métodos orientados a objetos, a los que sigue el desarrollo ágil de software).En tanto que la tendencia natural de un péndulo es alcanzar el estado de reposo en el punto medioentre dos extremos, la atención de la comunidad del software cambia constantemente porque seaplica una nueva fuerza al fallar la última oscilación. Estos vaivenes son dañinos en sí mismos porqueconfunden al profesional promedio del software al cambiar en forma radical lo que significa hacer eltrabajo bien. Los cambios periódicos no resuelven “el problema” porque están predestinados a fallartoda vez que el producto y el proceso son tratados como si fueran una dicotomía en lugar de unadualidad.02Pressman(025-054).indd 51 14/1/10 13:36:5252 PARTE UNO EL PROCESO DEL SOFTWAREEn la comunidad científica existe el precedente de adoptar nociones de dualidad cuando las contradicciones en las observaciones no pueden ser explicadas por alguna teoría alternativa. La naturaleza dual de la luz, que parece ser al mismo tiempo onda y partícula, ha sido aceptada desde la décadade 1920, cuando la propuso Louis de Broglie. Pienso que las observaciones que podemos hacer sobreel conjunto del software y su desarrollo demuestran una dualidad fundamental entre el producto y elproceso. Nunca es posible derivar u obtener todo el conjunto, su contexto, uso, significado y beneficiossi se le ve sólo como proceso o sólo como producto…Toda la actividad humana es un proceso, pero cada uno de nosotros obtiene un sentido de beneficio propio gracias a aquellas actividades que dan como resultado una representación o instancia quepuede usar o apreciar más de una persona, utilizarla una y otra vez, o emplearla en algún otro contexto no considerado. Es decir, obtenemos sentimientos de satisfacción por la reutilización de nuestros productos, ya sea que lo hagamos nosotros u otras personas.Entonces, si bien la rápida asimilación de las metas de reutilización en el desarrollo del softwareincrementa potencialmente la satisfacción que obtienen los profesionales del software en su trabajo,también aumenta la urgencia de la aceptación de la dualidad de producto y proceso. Pensar en unartefacto reutilizable como si fuera sólo un producto o sólo un proceso oscurece el contexto y lasformas de emplearlo, o bien oculta el hecho de que cada uso da como resultado un producto que a suvez será utilizado como entrada para alguna otra actividad de desarrollo de software. Privilegiar unpunto de vista sobre el otro reduce mucho las oportunidades para la reutilización y, por tanto, se pierdela oportunidad de aumentar la satisfacción por el trabajo.La gente obtiene tanta (o más) satisfacción del proceso creativo como del producto final. Unartista disfruta las pinceladas tanto como el resultado que enmarca. Un escritor goza de la búsqueda de la metáfora apropiada tanto como del libro terminado. Como profesional creativo delsoftware, usted también debe obtener tanta satisfacción del proceso como del producto final. Ladualidad de producto y proceso es un elemento importante para hacer que personas creativasse involucren conforme la ingeniería de software evoluciona. 2.9 RESUMENUn modelo general del proceso para la ingeniería de software incluye un conjunto de actividadesestructurales y sombrilla, acciones y tareas de trabajo. Cada uno de los modelos de procesopuede describirse por un flujo distinto del proceso: descripción de cómo se organizan secuencialy cronológicamente las actividades estructurales, acciones y tareas. Los patrones del procesopueden utilizarse para resolver los problemas comunes que surgen como parte del proceso delsoftware.Los modelos de proceso prescriptivo se han aplicado durante muchos años en un esfuerzopor introducir orden y estructura al desarrollo de software. Cada uno de dichos modelos sugiereun flujo de proceso algo distinto, pero todos llevan a cabo el mismo conjunto de actividadesestructurales generales: comunicación, planeación, modelado, construcción y desarrollo.Los modelos de proceso secuencial, como el de la cascada y en V, son los paradigmas másantiguos del software. Sugieren un flujo lineal del proceso que con frecuencia no es congruentecon las realidades modernas (cambio continuo, sistemas en evolución, plazos ajustados, etc.)del mundo del software. Sin embargo, tienen aplicación en situaciones en las que los requerimientos están bien definidos y son estables.Los modelos de proceso incremental son de naturaleza iterativa y producen con mucha rapidez versiones funcionales del software. Los modelos de proceso evolutivo reconocen la naturaleza iterativa e incremental de la mayoría de proyectos de ingeniería de software y están diseñados para aceptar los cambios. Los modelos evolutivos, tales como el de hacer prototipos yel espiral, generan rápido productos de trabajo incremental (o versiones funcionales del software). Estos modelos se adoptan para aplicarse a lo largo de todas las actividades de la inge02Pressman(025-054).indd 52 14/1/10 13:36:53CAPÍTULO 2 MODELOS DEL PROCESO 53niería de software, desde el desarrollo del concepto hasta el mantenimiento del sistema a largoplazo.El modelo de proceso concurrente permite que un equipo de software represente los elementos iterativos y concurrentes de cualquier modelo de proceso. Los modelos especializados incluyen el basado en componentes, que pone el énfasis en la reutilización y ensamble de loscomponentes; el modelo de métodos formales consiste en un enfoque basado en matemáticaspara desarrollar y verificar el software; y el modelo orientado a aspectos implica preocupacionesglobales que afectan toda la arquitectura del sistema. El proceso unificado es un proceso delsoftware diseñado como estructura para los métodos y herramientas del UML, y está “impulsadopor el caso de uso, centrado en la arquitectura, y es iterativo e incremental”.Se han propuesto modelos personal y del equipo para el proceso del software. Ambos enfatizan la medición, planeación y autodirección como los ingredientes clave para un procesoexitoso del software. PROBLEMAS Y PUNTOS POR EVALUAR2.1. En la introducción de este capítulo, Baetjer afirma que: “El proceso genera interacción entre usuarios ydiseñadores, entre usuarios y herramientas cambiantes [tecnología].” Enliste cinco preguntas que a) los diseñadores deben responder a los usuarios, b) los usuarios deben plantear a los diseñadores, c) los usuariosdeben hacerse a sí mismos sobre el producto de software que ha de elaborarse, d) los diseñadores debenplantearse acerca del producto de software que va a construirse y del proceso que se usará para ello.2.2. Trate de desarrollar un conjunto de acciones para la actividad de comunicación. Seleccione una accióny defina un conjunto de tareas para ella.2.3. Un problema común durante la comunicación ocurre cuando se encuentra a dos participantes quetienen ideas en conflicto sobre lo que debe ser el software, es decir, que tienen requerimientos mutuamenteconflictivos. Desarrolle un patrón del proceso (esto sería un patrón de la etapa) con el empleo de la plantillapresentada en la sección 2.1.3 que aborda este problema y sugiera un enfoque eficaz para él.2.4. Investigue un poco sobre el PPS y haga una breve presentación que describa los tipos de medicionesque se pide hacer a un ingeniero individual de software y la forma en la que pueden usarse para mejorar laeficacia personal.2.5. El uso de scripts (mecanismo requerido en el PES) no es apreciado de manera universal en la comunidad del software. Haga una lista de pros y contras en relación con los scripts y sugiera al menos dos situaciones en las que serían útiles, y otras dos en las que generarían menos beneficios.2.6. Lea a [Nog00] y escriba un ensayo de dos o tres páginas donde analice el efecto que tiene el “caos” enla ingeniería de software.2.7. Dé tres ejemplos de proyectos de software que podrían efectuarse con el modelo de cascada. Sea específico.2.8. Proporcione tres ejemplos de proyectos de software que podrían abordarse con el modelo de hacerprototipos. Sea específico.2.9. ¿Qué adaptaciones del proceso se requerirían si el proyecto evolucionara en un sistema o producto quese entregase?2.10. Diga tres ejemplos de proyectos de software que podrían realizarse con el modelo incremental. Seaespecífico.2.11. Conforme avanza hacia fuera por el flujo de proceso en espiral, ¿qué puede decirse sobre el softwareque se está desarrollando o que está en mantenimiento?2.12. ¿Es posible combinar modelos de proceso? Si es así, diga un ejemplo.2.13. El modelo de proceso concurrente define un conjunto de “estados”. Describa con sus propias palabrasqué es lo que representan, y después indique cómo entran en juego dentro del modelo de proceso concurrente.02Pressman(025-054).indd 53 14/1/10 13:36:5354 PARTE UNO EL PROCESO DEL SOFTWARE2.14. ¿Cuáles son las ventajas y desventajas de desarrollar software en el que la calidad no es “suficientemente buena”? Es decir, ¿qué pasa cuando se pone el énfasis en la velocidad de desarrollo sobre la calidaddel producto?2.15. Dé tres ejemplos de proyectos de software que serían abordables con el modelo basado en componentes. Sea específico.2.16. ¿Es posible demostrar que un componente de software, o incluso un programa completo, es correcto?Entonces, ¿por qué no todos lo hacen?2.17. ¿Son lo mismo el proceso unificado y el UML? Explique su respuesta. LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓNLa mayor parte de los libros de ingeniería de software consideran en detalle los modelos de proceso tradicionales. Libros como el de Sommerville (Software Engineering, 8a. ed., Addison-Wesley, 2006), Pfleeger yAtlee (Software Engineering, 3a. ed., Prentice-Hall, 2005), y Schach (Object-Oriented and Classical SoftwareEngineering, 7a. ed., McGraw-Hill, 2006) consideran los paradigmas tradicionales y estudian sus fortalezas ydebilidades. Glass (Facts and Fallacies of Software Engineering, Prentice-Hall, 2002) da un punto de vista pragmático y crudo del proceso de ingeniería de software. Aunque no se dedica específicamente al proceso,Brooks (The Mythical Man-Month, 2a. ed., Addison-Wesley, 1995) presenta la sabiduría antigua sobre losproyectos y plantea que todo tiene que ver con el proceso.Firesmith y Henderson-Sellers (The OPEN Process Framework: An Introduction, Addison-Wesley, 2001)presenta una plantilla general para crear “procesos de software flexibles pero con disciplina” y analiza losatributos y objetivos del proceso. Madachy (Software Process Dynamics, Wiley-IEEE, 2008) estudia técnicas demodelado que permiten analizar los elementos técnicos y sociales interrelacionados del proceso del software. Sharpe y McDermott (Workflow Modeling: Tools for Process Improvement and Application Development,Artech House, 2001) presentan herramientas para modelar procesos tanto de software como de negocios.Lim (Managing Software Reuse, Prentice-Hall, 2004) estudia la reutilización desde la perspectiva del gerente. Ezran, Morisio y Tully (Practical Software Reuse, Springer, 2002) y Jacobson, Griss y Jonsson (SoftwareReuse, Addison-Wesley, 1997) presentan mucha información útil sobre el desarrollo basado en componentes.Heineman y Council (Component-Based Software Engineering, Addison-Wesley, 2001) describen el procesorequerido para implementar sistemas basados en componentes. Kenett y Baker (Software Process Quality:Management and Control, Marcel Dekker, 1999) analizan la manera en la que se conectan íntimamente laadministración de la calidad y el diseño del proceso.Nygard (Release It!: Design and Deploy Production-Ready Software, Pragmatic Bookshelf, 2007) y Richardson y Gwaltney (Ship it! A Practical Guide to Successful Software Projects, Pragmatic Bookshelf, 2005) presentanuna amplia colección de lineamientos útiles aplicables a la actividad de despliegue.Además del libro fundamental de Jacobson, Rumbaugh y Booch acerca del proceso unificado [Jac99], loslibros de Arlow y Neustadt (UML 2 and the Unified Process, Addison-Wesley, 2005), Kroll y Kruchten (TheRational Unified Process Made Easy, Addison-Wesley, 2003) y Farve (UML and the Unified Process, IRM Press,2003) proveen información complementaria excelente. Gibbs (Project Management with the IBM RationalUnified Process, IBM Press, 2006) analiza la administración de proyectos dentro del contexto del PU.En internet existe una amplia variedad de fuentes de información sobre la ingeniería de software y elproceso del software. En el sitio web del libro, www.mhhe.com/engcs/compsci/pressman/professional/olc/ser.htm, hay una lista actualizada de referencias en la Red Mundial que son relevantes para elproceso del software.02Pressman(025-054).indd 54 14/1/10 13:36:5355CAPÍTULO3 DESARROLLO ÁGILC ONCEPTOS CLAVEagilidad . . . . . . . . . . . . . . . . 56Cristal . . . . . . . . . . . . . . . . . 72Desarrollo adaptativode software . . . . . . . . . . . . . 68Desarrollo esbeltode software . . . . . . . . . . . . . 73DIC. . . . . . . . . . . . . . . . . . . . 72historias. . . . . . . . . . . . . . . . 62MDSD . . . . . . . . . . . . . . . . . 71proceso ágil . . . . . . . . . . . . . 58Proceso unificado ágil . . . . . . 75proceso XP . . . . . . . . . . . . . . 62programación extrema. . . . . . 61programación por parejas . . . 64rediseño . . . . . . . . . . . . . . . . 63Scrum. . . . . . . . . . . . . . . . . . 69velocidad del proyecto. . . . . . 63XP industrial. . . . . . . . . . . . . 65¿Qué es? La ingeniería de software ágil combina una filosofía con un conjunto de lineamientos de desarrollo. La filosofía pone elénfasis en: la satisfacción del cliente y en laentrega rápida de software incremental, los equipospequeños y muy motivados para efectuar el proyecto, losmétodos informales, los productos del trabajo con mínimaingeniería de software y la sencillez general en el desarrollo. Los lineamientos de desarrollo enfatizan la entregasobre el análisis y el diseño (aunque estas actividades nose desalientan) y la comunicación activa y continua entredesarrolladores y clientes.¿Quién lo hace? Los ingenieros de software y otros participantes en el proyecto (gerentes, clientes, usuarios finales,etc.) trabajan juntos en un proyecto ágil, formando unequipo con organización propia y que controla su propiodestino. Un equipo ágil facilita la comunicación y colaboración entre aquellos a quienes sirve.¿Por qué es importante? El ambiente moderno de negocios que genera sistemas basados en computadora y productos de software evoluciona rápida y constantemente. Laingeniería de software ágil representa una alternativarazonable a la ingeniería de software convencional paraciertas clases de software y en algunos tipos de proyectos.Asimismo, se ha demostrado que concluye con rapidezsistemas exitosos.¿Cuáles son los pasos? Un nombre más apropiado parael desarrollo ágil sería “ingeniería de software ligero”.Permanecen las actividades estructurales fundamentales:comunicación, planeación, modelado, construcción y despliegue. Pero se transforman en un conjunto mínimo detareas que lleva al equipo del proyecto hacia la construcción y entrega (algunas personas dirían que esto se hacea costa del análisis del problema y del diseño de la solución).¿Cuál es el producto final? Tanto el cliente como elingeniero de software tienen la misma perspectiva: el únicoproducto del trabajo realmente importante es un “incremento de software” operativo que se entrega al clienteexactamente en la fecha acordada.¿Cómo me aseguro de que lo hice bien? El trabajoestará bien hecho si el equipo ágil concuerda en que elproceso funciona y en que produce incrementos de software utilizables que satisfagan al cliente.U N AMIRADARÁPIDA1 En ocasiones se conoce a los métodos ágiles como métodos ligeros o métodos esbeltos.En 2001, Kent Beck y otros 16 notables desarrolladores de software, escritores y consultores [Bec01a] (grupo conocido como la “Alianza Ágil”) firmaron el “Manifiesto por el desarrollo ágil de software”. En él se establecía lo siguiente:Estamos descubriendo formas mejores de desarrollar software, por medio de hacerlo y de dar ayudaa otros para que lo hagan. Ese trabajo nos ha hecho valorar:Los individuos y sus interacciones, sobre los procesos y las herramientasEl software que funciona, más que la documentación exhaustivaLa colaboración con el cliente, y no tanto la negociación del contratoResponder al cambio, mejor que apegarse a un planEs decir, si bien son valiosos los conceptos que aparecen en segundo lugar, valoramos más los queaparecen en primer sitio.Un manifiesto normalmente se asocia con un movimiento político emergente: ataca a la viejaguardia y sugiere un cambio revolucionario (se espera que para mejorar). En cierta forma, deeso es de lo que trata el desarrollo ágil.Aunque las ideas subyacentes que lo guían han estado durante muchos años entre nosotros,ha sido en menos de dos décadas que cristalizaron en un “movimiento”. Los métodos ágiles1 sedesarrollaron como un esfuerzo por superar las debilidades reales y percibidas de la ingenieríade software convencional. El desarrollo ágil proporciona beneficios importantes, pero no es03Pressman(055-080).indd 55 14/1/10 13:41:0756 PARTE UNO EL PROCESO DEL SOFTWAREaplicable a todos los proyectos, productos, personas y situaciones. No es la antítesis de la práctica de la ingeniería de software sólida y puede aplicarse como filosofía general para todo eltrabajo de software.Es frecuente que en la economía moderna sea difícil o imposible predecir la forma en la queevolucionará un sistema basado en computadora (por ejemplo, una aplicación con base enweb). Las condiciones del mercado cambian con rapidez, las necesidades de los usuarios finalesse transforman y emergen nuevas amenazas competitivas sin previo aviso. En muchas situaciones no será posible definir los requerimientos por completo antes de que el proyecto comience.Se debe ser suficientemente ágil para responder a lo fluido que se presenta el ambiente de negocios.La fluidez implica cambio, y el cambio es caro, en particular si es descontrolado o si se administra mal. Una de las características más atractivas del enfoque ágil es su capacidad de reducir los costos del cambio durante el proceso del software.¿Significa esto que el reconocimiento de los retos planteados por las realidades modernashace que sean descartables los valiosos principios, conceptos, métodos y herramientas de laingeniería del software? No, en absoluto… Igual que todas las disciplinas de la ingeniería, la delsoftware evoluciona en forma continua. Puede adaptarse con facilidad para que satisfaga losdesafíos que surgen de la demanda de agilidad.En un libro que suscita la reflexión sobre el desarrollo de software ágil, Alistair Cockburn[CocO2] argumenta que los modelos de proceso prescriptivo, introducidos en el capítulo 2, tienen una falla grande: olvidan las flaquezas de las personas cuando construyen software. Los ingenieros de software no son robots. Sus estilos de trabajo varían mucho; tienen diferencias significativas en habilidad, creatividad, orden, consistencia y espontaneidad. Algunos se comunicanbien por escrito, pero otros no. Cockburn afirma que los modelos de proceso pueden “manejarlas carencias de disciplina o tolerancia de las personas comunes” y que los modelos de procesomás prescriptivo eligen la disciplina. Dice: “Como la consistencia de las acciones es una debilidad humana, las metodología que requieren mucha disciplina son frágiles.”Para funcionar, los modelos de proceso deben proveer un mecanismo realista que estimulela disciplina necesaria, o deben caracterizarse por la “tolerancia” con las personas que hacen eltrabajo de ingeniería de software. Invariablemente, las prácticas tolerantes son más fáciles deadoptar y sostener por parte de la comunidad del software, pero son menos productivas (comoadmite Cockburn). Debe considerarse la negociación entre ellas, como en todas las cosas de lavida. 3.1 ¿QUÉ ES LA AGILIDAD?Pero, ¿qué es la agilidad en el contexto del trabajo de la ingeniería de software? Ivar Jacobson[Jac02a] hace un análisis útil:La agilidad se ha convertido en la palabra mágica de hoy para describir un proceso del software moderno. Todos son ágiles. Un equipo ágil es diestro y capaz de responder de manera apropiada a loscambios. El cambio es de lo que trata el software en gran medida. Hay cambios en el software que seconstruye, en los miembros del equipo, debidos a las nuevas tecnologías, de todas clases y que tienenun efecto en el producto que se elabora o en el proyecto que lo crea. Deben introducirse apoyos parael cambio en todo lo que se haga en el software; en ocasiones se hace porque es el alma y corazón deéste. Un equipo ágil reconoce que el software es desarrollado por individuos que trabajan en equipo,y que su capacidad, su habilidad para colaborar, es el fundamento para el éxito del proyecto.Desde el punto de vista de Jacobson, la ubicuidad del cambio es el motor principal de la agilidad.Los ingenieros de software deben ir rápido si han de adaptarse a los cambios veloces que describe Jacobson.Cita:“Agilidad: 1,todo lo demás: 0.”Tom DeMarco03Pressman(055-080).indd 56 14/1/10 13:41:08CAPÍTULO 3 DESARROLLO ÁGIL 57Pero la agilidad es algo más que una respuesta efectiva al cambio. También incluye la filosofía expuesta en el manifiesto citado al principio de este capítulo. Ésta recomienda las estructurasde equipo y las actitudes que hacen más fácil la comunicación (entre los miembros del equipo,tecnólogos y gente de negocios, entre los ingenieros de software y sus gerentes, etc.); pone elénfasis en la entrega rápida de software funcional y resta importancia a los productos intermedios del trabajo (lo que no siempre es bueno); adopta al cliente como parte del equipo de desarrollo y trabaja para eliminar la actitud de “nosotros y ellos” que todavía invade muchos proyectos de software; reconoce que la planeación en un mundo incierto tiene sus límites y que un plande proyecto debe ser flexible.La agilidad puede aplicarse a cualquier proceso del software. Sin embargo, para lograrlo esesencial que éste se diseñe en forma que permita al equipo del proyecto adaptar las tareas yhacerlas directas, ejecutar la planeación de manera que entienda la fluidez de un enfoque ágildel desarrollo, eliminar todos los productos del trabajo excepto los más esenciales y mantenerlos esbeltos, y poner el énfasis en una estrategia de entrega incremental que haga trabajar alsoftware tan rápido como sea posible para el cliente, según el tipo de producto y el ambiente deoperación. 3.2 LA AGILIDAD Y EL COSTO DEL CAMBIOLa sabiduría convencional del desarrollo de software (apoyada por décadas de experiencia)señala que el costo se incrementa en forma no lineal a medida que el proyecto avanza (véasela figura 3.1, curva continua negra). Es relativamente fácil efectuar un cambio cuando el equipode software reúne los requerimientos (al principio de un proyecto). El escenario de uso tal veztenga que modificarse, la lista de funciones puede aumentar, o editarse una especificación escrita. Los costos de hacer que esto funcione son mínimos, y el tiempo requerido no perjudicaráel resultado del proyecto. Pero, ¿qué pasa una vez transcurridos algunos meses? El equipo estáa la mitad de las pruebas de validación (algo que ocurre cuando el proyecto está relativamenteavanzado) y un participante de importancia solicita que se haga un cambio funcional grande. Elcambio requiere modificar el diseño de la arquitectura del software, el diseño y construcción detres componentes nuevos, hacer cambios en otros cinco componentes, diseñar nuevas pruebas,etc. Los costos aumentan con rapidez, y no son pocos el tiempo y el dinero requeridos paraasegurar que se haga el cambio sin efectos colaterales no intencionados.Los defensores de la agilidad (por ejemplo [Bec001] y [Amb04]) afirman que un proceso ágilbien diseñado “aplana” el costo de la curva de cambio (véase la figura 3.1, curva continua yNo cometa el error de suponer que laagilidad le da permiso paraimprovisar soluciones. Se requiere deun proceso, y la disciplina esesencial.CONSEJOCosto del cambio conel empleo de procesosconvencionales de softwareCosto del cambio conel uso de procesos ágilesCosto idealizado del cambiocon el uso de un proceso ágilAvance de la programación del desarrolloCosto del desarrolloFIGURA 3.1Cambio de loscostos comofunción deltiempo transcurrido en eldesarrolloCita:“La agilidad es dinámica, específica en el contenido, aceptacon entusiasmo el cambio y seorienta al crecimiento.”Steven Goldman et al.03Pressman(055-080).indd 57 14/1/10 13:41:0858 PARTE UNO EL PROCESO DEL SOFTWAREsombreada), lo que permite que el equipo de software haga cambios en una fase tardía de unproyecto de software sin que haya un efecto notable en el costo y en el tiempo. El lector ya sabeque el proceso ágil incluye la entrega incremental. Cuando ésta se acopla con otras prácticaságiles, como las pruebas unitarias continuas y la programación por parejas (que se estudia másadelante, en este capítulo), el costo de hacer un cambio disminuye. Aunque hay debate sobre elgrado en el que se aplana la curva de costo, existen evidencias [Coc01a] que sugieren que esposible lograr una reducción significativa del costo. 3.3 ¿QUÉ ES UN PROCESO ÁGIL ?Cualquier proceso del software ágil se caracteriza por la forma en la que aborda cierto númerode suposiciones clave [Fow02] acerca de la mayoría de proyectos de software:1. Es difícil predecir qué requerimientos de software persistirán y cuáles cambiarán. También es difícil pronosticar cómo cambiarán las prioridades del cliente a medida queavanza el proyecto.2. Para muchos tipos de software, el diseño y la construcción están imbricados. Es decir,ambas actividades deben ejecutarse en forma simultánea, de modo que los modelos dediseño se prueben a medida que se crean. Es difícil predecir cuánto diseño se necesitaantes de que se use la construcción para probar el diseño.3. El análisis, el diseño, la construcción y las pruebas no son tan predecibles como nosgustaría (desde un punto de vista de planeación).Dadas estas tres suposiciones, surge una pregunta importante: ¿cómo crear un proceso quepueda manejar lo impredecible? La respuesta, como ya se dijo, está en la adaptabilidad del proceso (al cambio rápido del proyecto y a las condiciones técnicas). Por tanto, un proceso ágil debeser adaptable.Pero la adaptación continua logra muy poco si no hay avance. Entonces, un proceso de software ágil debe adaptarse incrementalmente. Para lograr la adaptación incremental, un equipoágil requiere retroalimentación con el cliente (de modo que sea posible hacer las adaptacionesapropiadas). Un catalizador eficaz para la retroalimentación con el cliente es un prototipo operativo o una porción de un sistema operativo. Así, debe instituirse una estrategia de desarrolloincremental. Deben entregarse incrementos de software (prototipos ejecutables o porciones de unsistema operativo) en periodos cortos de tiempo, de modo que la adaptación vaya a ritmo conel cambio (impredecible). Este enfoque iterativo permite que el cliente evalúe en forma regular el incremento de software, dé la retroalimentación necesaria al equipo de software e influyaen las adaptaciones del proceso que se realicen para aprovechar la retroalimentación.3.3.1 Principios de agilidadLa Alianza Ágil (véase [Agi03]), [Fow01]) define 12 principios de agilidad para aquellos que laquieran alcanzar:1. La prioridad más alta es satisfacer al cliente a través de la entrega pronta y continua desoftware valioso.2. Son bienvenidos los requerimientos cambiantes, aun en una etapa avanzada del desarrollo. Los procesos ágiles dominan el cambio para provecho de la ventaja competitivadel cliente.3. Entregar con frecuencia software que funcione, de dos semanas a un par de meses, depreferencia lo más pronto que se pueda.PUNTOCLAVEUn proceso ágil reduce el costo delcambio porque el software seentrega en incrementos y en estaforma el cambio se controla mejor.WebRefEn la dirección www.aanpo.org/articles/index hay una coleccióncompleta de artículos sobre el procesoágil.PUNTOCLAVEAunque los procesos ágiles aceptanel cambio, es importante examinarlas razones de éste.03Pressman(055-080).indd 58 14/1/10 13:41:09CAPÍTULO 3 DESARROLLO ÁGIL 594. Las personas de negocios y los desarrolladores deben trabajar juntos, a diario y durantetodo el proyecto.5. Hay que desarrollar los proyectos con individuos motivados. Debe darse a éstos el ambiente y el apoyo que necesiten, y confiar en que harán el trabajo.6. El método más eficiente y eficaz para transmitir información a los integrantes de unequipo de desarrollo, y entre éstos, es la conversación cara a cara.7. La medida principal de avance es el software que funciona.8. Los procesos ágiles promueven el desarrollo sostenible. Los patrocinadores, desarrolladores y usuarios deben poder mantener un ritmo constante en forma indefinida.9. La atención continua a la excelencia técnica y el buen diseño mejora la agilidad.10. Es esencial la simplicidad: el arte de maximizar la cantidad de trabajo no realizado.11. Las mejores arquitecturas, requerimientos y diseños surgen de los equipos con organización propia.12. El equipo reflexiona a intervalos regulares sobre cómo ser más eficaz, para después afinar y ajustar su comportamiento en consecuencia.No todo modelo de proceso ágil aplica estos 12 principios con igual intensidad y algunos eligenignorar (o al menos soslayar) la importancia de uno o más de ellos. Sin embargo, los principiosdefinen un espíritu ágil que se mantiene en cada uno de los modelos de proceso que se presentan en este capítulo.3.3.2 La política del desarrollo ágilHay mucho debate (a veces estridente) sobre los beneficios y aplicabilidad del desarrollo desoftware ágil como oposición a los procesos más convencionales. Jim Highsmith [Hig02a] señala(en tono de burla) los extremos cuando caracteriza la posición del campo a favor de la agilidad(“agilistas”). “Los metodólogos tradicionales están atrapados en un pantano y producirán unadocumentación sin defectos en vez de un sistema funcional que satisfaga las necesidades delnegocio.” Como contrapunto, plantea (de nuevo como burla) la posición del campo de la ingeniería de software tradicional: “Los metodólogos ligeros, perdón, ‘ágiles’, son un grupo de remendones famosos que se van a llevar una sorpresa cuando intenten convertir sus juguetes ensoftware a la medida de la empresa.”Como todos los argumentos sobre la tecnología de software, este debate sobre la metodología corre el riesgo de degenerar en una guerra religiosa. Si estalla, desaparece el pensamientoracional y lo que guía la toma de decisiones son las creencias y no los hechos.Nadie está contra la agilidad. La pregunta real es: ¿cuál es la mejor forma de lograrla? De igualimportancia: ¿cómo construir software que satisfaga en el momento las necesidades de losclientes y que tenga características de calidad que permitan ampliarlo y escalarlo para que también las satisfaga en el largo plazo?No hay respuestas absolutas a ninguna de estas preguntas. Aun dentro de la escuela ágil haymuchos modelos de proceso propuestos (véase la sección 3.4), cada uno con un enfoque algodiferente para el problema de la agilidad. Dentro de cada modelo hay un conjunto de “ideas” (losagilistas las llaman “tareas del trabajo”) que representan un alejamiento significativo de la ingeniería de software tradicional. No obstante, muchos conceptos ágiles sólo son adaptaciones dealgunos que provienen de la buena ingeniería de software. En resumen: hay mucho por ganarsi se considera lo mejor de ambas escuelas, y virtualmente no se gana nada si se denigra cualquiera de los enfoques.Si el lector está interesado, consulte [Hig01], [Hig02a] y [DeM02] para ver un resumen amenode otros aspectos técnicos y políticos importantes.El software que funciona esimportante, pero no olvide quetambién debe poseer varios atributosde calidad, como ser confiable,utilizable y susceptible de recibirmantenimiento.CONSEJONo tiene que elegirse entre laagilidad y la ingeniería de software.En vez de ello, hay que definir unenfoque de ingeniería de softwareque sea ágil.CONSEJO03Pressman(055-080).indd 59 14/1/10 13:41:0960 PARTE UNO EL PROCESO DEL SOFTWARE3.3.3 Factores humanosLos defensores del desarrollo de software ágil se toman muchas molestias para enfatizar laimportancia de los “factores personales”. Como dicen Cockburn y Highsmith [Coc01a]: “El desarrollo ágil se centra en los talentos y habilidades de los individuos, y adapta el proceso a personas y equipos específicos.” El punto clave de esta afirmación es que el proceso se adapta a lasnecesidades de las personas y del equipo, no al revés.2Si los miembros del equipo de software son los que van a generar las características del proceso que van a aplicarse a la elaboración de software, entre ellos debe existir cierto número decaracterísticas clave, mismas que debe compartir el equipo ágil como tal:Competencia. En un contexto de desarrollo ágil (así como en la ingeniería de software),la “competencia” incluye el talento innato, las habilidades específicas relacionadas con elsoftware y el conocimiento general del proceso que el equipo haya elegido aplicar. La habilidad y el conocimiento del proceso pueden y deben considerarse para todas las personasque sean miembros ágiles del equipo.Enfoque común. Aunque los miembros del equipo ágil realicen diferentes tareas y aporten habilidades distintas al proyecto, todos deben centrarse en una meta: entregar al clienteen la fecha prometida un incremento de software que funcione. Para lograrlo, el equipotambién se centrará en adaptaciones continuas (pequeñas y grandes) que hagan que elproceso se ajuste a las necesidades del equipo.Colaboración. La ingeniería de software (sin importar el proceso) trata de evaluar, analizar y usar la información que se comunica al equipo de software; crear información queayudará a todos los participantes a entender el trabajo del equipo; y generar información(software de cómputo y bases de datos relevantes) que aporten al cliente valor del negocio.Para efectuar estas tareas, los miembros del equipo deben colaborar, entre sí y con todoslos participantes.Habilidad para tomar decisiones. Cualquier equipo bueno de software (incluso losequipos ágiles) debe tener libertad para controlar su destino. Esto implica que se dé autonomía al equipo: autoridad para tomar decisiones sobre asuntos tanto técnicos como delproyecto.Capacidad para resolver problemas difusos. Los gerentes de software deben reconocer que el equipo ágil tendrá que tratar en forma continua con la ambigüedad y que serásacudido de manera permanente por el cambio. En ciertos casos, el equipo debe aceptar elhecho de que el problema que resuelven ahora tal vez no sea el que se necesite resolvermañana. Sin embargo, las lecciones aprendidas de cualquier actividad relacionada con lasolución de problemas (incluso aquellas que resuelven el problema equivocado) serán benéficas para el equipo en una etapa posterior del proyecto.Confianza y respeto mutuos. El equipo ágil debe convertirse en lo que DeMarco y Lister [DeM98] llaman “pegado” (véase el capítulo 24). Un equipo pegado tiene la confianza yrespeto que son necesarios para hacer “su tejido tan fuerte que el todo es más que la sumade sus partes” [DeM98].Organización propia. En el contexto del desarrollo ágil, la organización propia implicatres cosas: 1) el equipo ágil se organiza a sí mismo para hacer el trabajo, 2) el equipo organiza el proceso que se adapte mejor a su ambiente local, 3) el equipo organiza la programación del trabajo a fin de que se logre del mejor modo posible la entrega del incremento2 Las organizaciones exitosas de ingeniería de software reconocen esta realidad sin importar el modelo de procesoque elijan.Cita:“Los métodos ágiles obtienengran parte de su agilidad porbasarse en el conocimiento tácito incorporado en el equipo,más que en escribir el conocimiento en planes.”Barry Boehm¿Qué característicasclave deben existirentre los integrantes deun equipo eficaz desoftware??Cita:“Lo que para un equipo es apenas suficiente, para otro es másque suficiente y para otro másresulta insuficiente.”Alistair CockburnPUNTOCLAVEUn equipo con organización propiatiene el control del trabajo querealiza. Establece sus propioscompromisos y define los planespara lograrlo.03Pressman(055-080).indd 60 14/1/10 13:41:09CAPÍTULO 3 DESARROLLO ÁGIL 61de software. La organización propia tiene cierto número de beneficios técnicos, pero, loque es más importante, sirve para mejorar la colaboración y elevar la moral del equipo. Enesencia, el equipo sirve como su propio gerente. Ken Schwaber [Sch02] aborda estos aspectos cuando escribe: “El equipo selecciona cuánto trabajo cree que puede realizar encada iteración, y se compromete con la labor. Nada desmotiva tanto a un equipo como quealguien establezca compromisos por él. Nada motiva más a un equipo como aceptar la responsabilidad de cumplir los compromisos que haya hecho él mismo.” 3.4 PROGRAMACIÓN EXTREMA (XP)A fin de ilustrar un proceso ágil con más detalle, daremos un panorama de la programación extrema (XP), el enfoque más utilizado del desarrollo de software ágil. Aunque las primeras actividades con las ideas y los métodos asociados a XP ocurrieron al final de la década de 1980, eltrabajo fundamental sobre la materia había sido escrito por Kent Beck [Bec04a]. Una variante deXP llamada XP industrial [IXP] se propuso en una época más reciente [Ker05]. IXP mejora la XP ytiene como objetivo el proceso ágil para ser usado específicamente en organizaciones grandes.3.4.1 Valores XPBeck [Bec04a] define un conjunto de cinco valores que establecen el fundamento para todo trabajo realizado como parte de XP: comunicación, simplicidad, retroalimentación, valentía yrespeto. Cada uno de estos valores se usa como un motor para actividades, acciones y tareasespecíficas de XP.A fin de lograr la comunicación eficaz entre los ingenieros de software y otros participantes(por ejemplo, para establecer las características y funciones requeridas para el software), XP poneel énfasis en la colaboración estrecha pero informal (verbal) entre los clientes y los desarrolladores, en el establecimiento de metáforas3 para comunicar conceptos importantes, en la retroalimentación continua y en evitar la documentación voluminosa como medio de comunicación.Para alcanzar la simplicidad, XP restringe a los desarrolladores para que diseñen sólo para lasnecesidades inmediatas, en lugar de considerar las del futuro. El objetivo es crear un diseñosencillo que se implemente con facilidad en forma de código. Si hay que mejorar el diseño, serediseñará4 en un momento posterior.La retroalimentación se obtiene de tres fuentes: el software implementado, el cliente y otrosmiembros del equipo de software. Al diseñar e implementar una estrategia de pruebas eficaz(capítulos 17 a 20), el software (por medio de los resultados de las pruebas) da retroalimentaciónal equipo ágil. XP usa la prueba unitaria como su táctica principal de pruebas. A medida que sedesarrolla cada clase, el equipo implementa una prueba unitaria para ejecutar cada operaciónde acuerdo con su funcionalidad especificada. Cuando se entrega un incremento a un cliente,las historias del usuario o casos de uso (véase el capítulo 5) que se implementan con el incremento se utilizan como base para las pruebas de aceptación. El grado en el que el softwareimplementa la salida, función y comportamiento del caso de uso es una forma de retroalimentación. Por último, conforme se obtienen nuevos requerimientos como parte de la planeacióniterativa, el equipo da al cliente una retroalimentación rápida con miras al costo y al efecto enla programación de actividades.3 En el contexto de XP, una metáfora es “una historia que cada quien —clientes, programadores y gerentes— narra,acerca de cómo funciona el sistema” [Bec04a].4 El rediseño permite que un ingeniero mejore la estructura interna de un diseño (o código fuente) sin cambiar sufuncionalidad o comportamiento externos. En esencia, el rediseño puede utilizarse para mejorar la eficiencia,disponibilidad o rendimiento de un diseño o del código que lo implementa.Mantenlo sencillo siempre que sepueda, pero reconoce que el“rediseño” continuo consume muchotiempo y recursos.CONSEJO03Pressman(055-080).indd 61 14/1/10 13:41:1062 PARTE UNO EL PROCESO DEL SOFTWAREBeck [Bec04a] afirma que la adhesión estricta a ciertas prácticas de XP requiere valentía. Untérmino más apropiado sería disciplina. Por ejemplo, es frecuente que haya mucha presión paradiseñar requerimientos futuros. La mayor parte de equipos de software sucumben a ella y sejustifican porque “diseñar para el mañana” ahorrará tiempo y esfuerzo en el largo plazo. Unequipo XP ágil debe tener la disciplina (valentía) para diseñar para hoy y reconocer que los requerimientos futuros tal vez cambien mucho, por lo que demandarán repeticiones sustancialesdel diseño y del código implementado.Al apegarse a cada uno de estos valores, el equipo ágil inculca respeto entre sus miembros,entre otros participantes y los integrantes del equipo, e indirectamente para el software en símismo. Conforme logra la entrega exitosa de incrementos de software, el equipo desarrolla másrespeto para el proceso XP.3.4.2 El proceso XPLa programación extrema usa un enfoque orientado a objetos (véase el apéndice 2) como paradigma preferido de desarrollo, y engloba un conjunto de reglas y prácticas que ocurren en elcontexto de cuatro actividades estructurales: planeación, diseño, codificación y pruebas. La figura 3.2 ilustra el proceso XP y resalta algunas de las ideas y tareas clave que se asocian concada actividad estructural. En los párrafos que siguen se resumen las actividades de XP clave.Planeación. La actividad de planeación (también llamada juego de planeación) comienza escuchando —actividad para recabar requerimientos que permite que los miembros técnicos delequipo XP entiendan el contexto del negocio para el software y adquieran la sensibilidad de lasalida y características principales y funcionalidad que se requieren—. Escuchar lleva a la creación de algunas “historias” (también llamadas historias del usuario) que describen la salida necesaria, características y funcionalidad del software que se va a elaborar. Cada historia (similara los casos de uso descritos en el capítulo 5) es escrita por el cliente y colocada en una tarjetaindizada. El cliente asigna un valor (es decir, una prioridad) a la historia con base en el valorgeneral de la característica o función para el negocio.5 Después, los miembros del equipo XPCita:“XP es la respuesta a la pregunta: ‘¿Cuán pequeño podemoshacer un gran software?’.”Anónimo¿Qué es una “historia” ? XP?WebRefEn la dirección www.extremeprogramming.org/rules.html, se encuentra unpanorama excelente de las “reglas”de XP.historias del usuario valores criterios de pruebas de aceptaciónplan de iteracióndiseño simpletarjetas CRCprueba unitariaintegración continua incremento de softwarevelocidad calculada del proyectosoluciones en puntaprototiposrediseñoprogramación por parejaspruebas de aceptaciónLanzamientodiseño codificaciónplaneaciónpruebaFIGURA 3.2El proceso de laprogramaciónextrema5 El valor de una historia también puede depender de la presencia de otra historia.03Pressman(055-080).indd 62 14/1/10 13:41:10CAPÍTULO 3 DESARROLLO ÁGIL 63evalúan cada historia y le asignan un costo, medido en semanas de desarrollo. Si se estima quela historia requiere más de tres semanas de desarrollo, se pide al cliente que la descompongaen historias más chicas y de nuevo se asigna un valor y costo. Es importante observar que encualquier momento es posible escribir nuevas historias.Los clientes y desarrolladores trabajan juntos para decidir cómo agrupar las historias en lasiguiente entrega (el siguiente incremento de software) que desarrollará el equipo XP. Una vezque se llega a un compromiso sobre la entrega (acuerdo sobre las historias por incluir, la fechade entrega y otros aspectos del proyecto), el equipo XP ordena las historias que serán desarrolladas en una de tres formas: 1) todas las historias se implementarán de inmediato (en pocassemanas), 2) las historias con más valor entrarán a la programación de actividades y se implementarán en primer lugar o 3) las historias más riesgosas formarán parte de la programación deactividades y se implementarán primero.Después de la primera entrega del proyecto (también llamada incremento de software), elequipo XP calcula la velocidad de éste. En pocas palabras, la velocidad del proyecto es el númerode historias de los clientes implementadas durante la primera entrega. La velocidad del proyectose usa para: 1) ayudar a estimar las fechas de entrega y programar las actividades para las entregas posteriores, y 2) determinar si se ha hecho un gran compromiso para todas las historiasdurante todo el desarrollo del proyecto. Si esto ocurre, se modifica el contenido de las entregaso se cambian las fechas de entrega final.A medida que avanza el trabajo, el cliente puede agregar historias, cambiar el valor de unaya existente, descomponerlas o eliminarlas. Entonces, el equipo XP reconsidera todas las entregas faltantes y modifica sus planes en consecuencia.Diseño. El diseño XP sigue rigurosamente el principio MS (mantenlo sencillo). Un diseñosencillo siempre se prefiere sobre una representación más compleja. Además, el diseño guía laimplementación de una historia conforme se escribe: nada más y nada menos. Se desalienta eldiseño de funcionalidad adicional porque el desarrollador supone que se requerirá después.6XP estimula el uso de las tarjetas CRC (véase el capítulo 7) como un mecanismo eficaz parapensar en el software en un contexto orientado a objetos. Las tarjetas CRC (clase-responsabilidad-colaborador) identifican y organizan las clases orientadas a objetos7 que son relevantespara el incremento actual de software. El equipo XP dirige el ejercicio de diseño con el uso deun proceso similar al que se describe en el capítulo 8. Las tarjetas CRC son el único producto deltrabajo de diseño que se genera como parte del proceso XP.Si en el diseño de una historia se encuentra un problema de diseño difícil, XP recomienda lacreación inmediata de un prototipo operativo de esa porción del diseño. Entonces, se implementa y evalúa el prototipo del diseño, llamado solución en punta. El objetivo es disminuir elriesgo cuando comience la implementación verdadera y validar las estimaciones originales parala historia que contiene el problema de diseño.En la sección anterior se dijo que XP estimula el rediseño, técnica de construcción que también es un método para la optimización del diseño. Fowler [Fow00] describe el rediseño delmodo siguiente:Rediseño es el proceso mediante el cual se cambia un sistema de software en forma tal que no altereel comportamiento externo del código, pero sí mejore la estructura interna. Es una manera disciplinada de limpiar el código [y modificar o simplificar el diseño interno] que minimiza la probabilidad deintroducir errores. En esencia, cuando se rediseña, se mejora el diseño del código después de habersido escrito.PUNTOCLAVELa velocidad del proyecto es unamedición sutil de la productividad delequipo.XP desalienta la importancia deldiseño, opinión con la que no todosestán de acuerdo. En realidad, hayveces en las que debe hacerseénfasis en el diseño.CONSEJOWebRefEn la dirección c2.com/cgi/wiki?planningGame, se halla un“juego de planeación” XP provechoso.6 Estos lineamientos de diseño deben seguirse en todo método de ingeniería de software, aunque hay ocasionesen los que la notación y terminología sofisticadas del diseño son un camino hacia la simplicidad.7 Las clases orientadas a objetos se estudian en el apéndice 2, en el capítulo 8 y en toda la parte 2 de este libro.WebRefEn la dirección www.refactoring.com se encuentran técnicas yherramientas de rediseño.03Pressman(055-080).indd 63 14/1/10 13:41:1064 PARTE UNO EL PROCESO DEL SOFTWAREComo el diseño XP virtualmente no utiliza notación y genera pocos, si alguno, productos deltrabajo que no sean tarjetas CRC y soluciones en punta, el diseño es visto como un artefacto entransición que puede y debe modificarse continuamente a medida que avanza la construcción.El objetivo del rediseño es controlar dichas modificaciones, sugiriendo pequeños cambios en eldiseño que “son capaces de mejorarlo en forma radical” [Fow00]. Sin embargo, debe notarse queel esfuerzo que requiere el rediseño aumenta en forma notable con el tamaño de la aplicación.Un concepto central en XP es que el diseño ocurre tanto antes como después de que comienzala codificación. Rediseñar significa que el diseño se hace de manera continua conforme se construye el sistema. En realidad, la actividad de construcción en sí misma dará al equipo XP unaguía para mejorar el diseño.Codificación. Después de que las historias han sido desarrolladas y de que se ha hecho eltrabajo de diseño preliminar, el equipo no inicia la codificación, sino que desarrolla una serie depruebas unitarias a cada una de las historias que se van a incluir en la entrega en curso (incremento de software).8 Una vez creada la prueba unitaria,9 el desarrollador está mejor capacitadopara centrarse en lo que debe implementarse para pasar la prueba. No se agrega nada extraño(MS). Una vez que el código está terminado, se le aplica de inmediato una prueba unitaria, conlo que se obtiene retroalimentación instantánea para los desarrolladores.Un concepto clave durante la actividad de codificación (y uno de los aspectos del que más sehabla en la XP) es la programación por parejas. XP recomienda que dos personas trabajen juntasen una estación de trabajo con el objeto de crear código para una historia. Esto da un mecanismo para la solución de problemas en tiempo real (es frecuente que dos cabezas piensen másque una) y para el aseguramiento de la calidad también en tiempo real (el código se revisa conforme se crea). También mantiene a los desarrolladores centrados en el problema de que setrate. En la práctica, cada persona adopta un papel un poco diferente. Por ejemplo, una de ellastal vez piense en los detalles del código de una porción particular del diseño, mientras la otra seasegura de que se siguen los estándares de codificación (parte necesaria de XP) o de que elcódigo para la historia satisfará la prueba unitaria desarrollada a fin de validar el código confrontándolo con la historia.A medida que las parejas de programadores terminan su trabajo, el código que desarrollanse integra con el trabajo de los demás. En ciertos casos, esto lo lleva a cabo a diario un equipode integración. En otros, las parejas de programadores tienen la responsabilidad de la integración. Esta estrategia de “integración continua” ayuda a evitar los problemas de compatibilidade interfaces y brinda un ambiente de “prueba de humo” (véase el capítulo 17) que ayuda a descubrir a tiempo los errores.Pruebas. Ya se dijo que la creación de pruebas unitarias antes de que comience la codificaciónes un elemento clave del enfoque de XP. Las pruebas unitarias que se crean deben implementarse con el uso de una estructura que permita automatizarlas (de modo que puedan ejecutarseen repetidas veces y con facilidad). Esto estimula una estrategia de pruebas de regresión (véaseel capítulo 17) siempre que se modifique el código (lo que ocurre con frecuencia, dada la filosofía del rediseño en XP).A medida que se organizan las pruebas unitarias individuales en un “grupo de prueba universal” [Wel99], las pruebas de la integración y validación del sistema pueden efectuarse a diario.Esto da al equipo XP una indicación continua del avance y también lanza señales de alerta si las8 Este enfoque es equivalente a saber las preguntas del examen antes de comenzar a estudiar. Vuelve mucho másfácil el estudio porque centra la atención sólo en las preguntas que se van a responder.9 La prueba unitaria, que se estudia en detalle en el capítulo 17, se centra en un componente de software individualsobre interfaz, estructuras de datos y funcionalidad del componente, en un esfuerzo por descubrir errores localesdel componente.PUNTOCLAVEEl rediseño mejora la estructurainterna de un diseño (o códigofuente) sin cambiar su funcionalidado comportamiento externo.Muchos equipos de software estánllenos de individualistas. Si laprogramación por parejas ha defuncionar con eficacia, tendrá quetrabajar para cambiar esa cultura.CONSEJO¿Qué es laprogramación porparejas??WebRefHay información útil acerca de XP en ladirección www.xprogramming.com.¿Cómo se usan laspruebas unitarias enXP??03Pressman(055-080).indd 64 14/1/10 13:41:11CAPÍTULO 3 DESARROLLO ÁGIL 65cosas marchan mal. Wells [Wel99] dice: “Corregir pequeños problemas cada cierto número dehoras toma menos tiempo que resolver problemas enormes justo antes del plazo final.”Las pruebas de aceptación XP, también llamadas pruebas del cliente, son especificadas por elcliente y se centran en las características y funcionalidad generales del sistema que son visiblesy revisables por parte del cliente. Las pruebas de aceptación se derivan de las historias de losusuarios que se han implementado como parte de la liberación del software.3.4.3 XP industrialJoshua Kerievsky [Ker05] describe la programación extrema industrial [IXP, por sus siglas en inglés] en la forma siguiente: “IXP es la evolución orgánica de XP. Está imbuida del espíritu minimalista, centrado en el cliente y orientado a las pruebas que tiene XP. IXP difiere sobre todo dela XP original en su mayor inclusión de la gerencia, el papel más amplio de los clientes y en susprácticas técnicas actualizadas”. IXP incorpora seis prácticas nuevas diseñadas para ayudar agarantizar que un proyecto XP funciona con éxito para proyectos significativos dentro de unaorganización grande.Evaluación de la factibilidad. Antes de iniciar un proyecto IXP, la organización debeefectuar una evaluación de la factibilidad. Ésta deja en claro si: 1) existe un ambiente apropiado de desarrollo que acepte IXP, 2) el equipo estará constituido por los participantesadecuados, 3) la organización tiene un programa de calidad distintivo y apoya la mejoracontinua, 4) la cultura organizacional apoyará los nuevos valores de un equipo ágil, y 5)la comunidad extendida del proyecto estará constituida de modo apropiado.Comunidad del proyecto. La XP clásica sugiere que se utilice personal apropiado paraformar el equipo ágil a fin de asegurar el éxito. La implicación es que las personas en elequipo deben estar bien capacitadas, ser adaptables y hábiles, y tener el temperamentoapropiado para contribuir al equipo con organización propia. Cuando se aplica XP a un proyecto significativo en una organización grande, el concepto de “equipo” debe adoptar laforma de comunidad. Una comunidad puede tener un tecnólogo y clientes que son fundamentales para el éxito del proyecto, así como muchos otros participantes (equipo jurídico;auditores de calidad, de tipos de manufactura o de ventas, etc.) que “con frecuencia se encuentran en la periferia en un proyecto IXP, pero que desempeñan en éste papeles importantes” [Ker05]. En IXP, los miembros de la comunidad y sus papeles deben definirse demodo explícito, así como establecer los mecanismos para la comunicación y coordinaciónentre los integrantes de la comunidad.Calificación del proyecto. El equipo de IXP evalúa el proyecto para determinar si existeuna justificación apropiada de negocios y si el proyecto cumplirá las metas y objetivos generales de la organización. La calificación también analiza el contexto del proyecto a fin dedeterminar cómo complementa, extiende o reemplaza sistemas o procesos existentes.Administración orientada a pruebas. Un proyecto IXP requiere criterios medibles paraevaluar el estado del proyecto y el avance realizado. La administración orientada a pruebasestablece una serie de “destinos” medibles [Ker05] y luego define los mecanismos para determinar si se han alcanzado o no éstos.Retrospectivas. Después de entregar un incremento de software, el equipo XP realizauna revisión técnica especializada que se llama retrospectiva y que examina “los temas,eventos y lecciones aprendidas” [Ker05] a lo largo del incremento de software y/o de la liberación de todo el software. El objetivo es mejorar el proceso IXP.Aprendizaje continuo. Como el aprendizaje es una parte vital del proceso de mejoracontinua, los miembros del equipo XP son invitados (y tal vez incentivados) a aprendernuevos métodos y técnicas que conduzcan a una calidad más alta del producto.PUNTOCLAVELas pruebas de aceptación se derivande las historias de los usuarios.¿Qué nuevas prácticasse agregan a XP paracrear IXP??Cita:“Habilidad es aquello que erescapaz de hacer. La motivacióndetermina lo que haces. La actitud determina cuán bien lohaces.”Lou Holtz03Pressman(055-080).indd 65 14/1/10 13:41:1166 PARTE UNO EL PROCESO DEL SOFTWAREAdemás de las seis nuevas prácticas analizadas, IXP modifica algunas de las existentes en XP.El desarrollo impulsado por la historia (DIH) insiste en que las historias de las pruebas de aceptación se escriban antes de generar una sola línea de código. El diseño impulsado por el dominio(DID) es una mejora sobre el concepto de la “metáfora del sistema” usado en XP. El DID [Eva03]sugiere la creación evolutiva de un modelo de dominio que “represente con exactitud cómo piensan los expertos del dominio en su materia” [Ker05]. La formación de parejas amplía el conceptode programación en pareja para que incluya a los gerentes y a otros participantes. El objetivo esmejorar la manera de compartir conocimientos entre los integrantes del equipo XP que no esténdirectamente involucrados en el desarrollo técnico. La usabilidad iterativa desalienta el diseño deuna interfaz cargada al frente y estimula un diseño que evoluciona a medida que se liberan losincrementos de software y que se estudia la interacción de los usuarios con el software.La IXP hace modificaciones más pequeñas a otras prácticas XP y redefine ciertos roles y responsabilidades para hacerlos más asequibles a proyectos significativos de las organizacionesgrandes. Para mayores detalles de IXP, visite el sitio http://industrialxp.org.3.4.4 El debate XPLos nuevos modelos y métodos de proceso han motivado análisis provechosos y en ciertas instancias debates acalorados. La programación extrema desencadena ambos. En un libro interesante que examina la eficacia de XP, Stephens y Rosenberg [Ste03] afirman que muchas prácticas de XP son benéficas, pero que otras están sobreestimadas y unas más son problemáticas.Los autores sugieren que la naturaleza codependiente de las prácticas de XP constituye tanto sufortaleza como su debilidad. Debido a que muchas organizaciones adoptan sólo un subconjuntode prácticas XP, debilitan la eficacia de todo el proceso. Los defensores contradicen esto al afirmar que la XP está en evolución continua y que muchas de las críticas que se le hacen han llevado a correcciones conforme maduran sus prácticas. Entre los aspectos que destacan algunoscríticos de la XP están los siguientes:10• Volatilidad de los requerimientos. Como el cliente es un miembro activo del equipo XP, loscambios a los requerimientos se solicitan de manera informal. En consecuencia, elalcance del proyecto cambia y el trabajo inicial tiene que modificarse para dar acomodo alas nuevas necesidades. Los defensores afirman que esto pasa sin importar el proceso quese aplique y que la XP proporciona mecanismos para controlar los vaivenes del alcance.• Necesidades conflictivas del cliente. Muchos proyectos tienen clientes múltiples, cada unocon sus propias necesidades. En XP, el equipo mismo tiene la tarea de asimilar las necesidades de distintos clientes, trabajo que tal vez esté más allá del alcance de su autoridad.• Los requerimientos se expresan informalmente. Las historias de usuario y las pruebas deaceptación son la única manifestación explícita de los requerimientos en XP. Los críticosafirman que es frecuente que se necesite un modelo o especificación más formal paragarantizar que se descubran las omisiones, inconsistencias y errores antes de que seconstruya el sistema. Los defensores contraatacan diciendo que la naturaleza cambiantede los requerimientos vuelve obsoletos esos modelos y especificaciones casi tan prontocomo se desarrollan.• Falta de un diseño formal. XP desalienta la necesidad del diseño de la arquitectura y, enmuchas instancias, sugiere que el diseño de todas las clases debe ser relativamenteinformal. Los críticos argumentan que cuando se construyen sistemas complejos, debeponerse el énfasis en el diseño con el objeto de garantizar que la estructura general delsoftware tendrá calidad y que será susceptible de recibir mantenimiento. Los defensores10 Para un estudio más detallado de ciertas críticas profundas hechas a XP, visite www.softwarereality.com/ExtremeProgramming.jsp.¿Cuáles son algunos delos aspectos que llevanal debate de XP??03Pressman(055-080).indd 66 14/1/10 13:41:11CAPÍTULO 3 DESARROLLO ÁGIL 67de XP sugieren que la naturaleza incremental del proceso XP limita la complejidad (lasencillez es un valor fundamental), lo que reduce la necesidad de un diseño extenso.El lector debe observar que todo proceso del software tiene sus desventajas, y que muchas organizaciones de software han utilizado con éxito la XP. La clave es identificar dónde tiene susdebilidades un proceso y adaptarlo a las necesidades de la organización. 3.5 OTROS MODELOS ÁGILES DE PROCESOLa historia de la ingeniería de software está salpicada de decenas de descripciones y metodologías de proceso, métodos de modelado y notaciones, herramientas y tecnología, todos ellosobsoletos. Cada uno tuvo notoriedad y luego fue eclipsado por algo nuevo y (supuestamente)mejor. Con la introducción de una amplia variedad de modelos ágiles del proceso —cada unoen lucha por la aceptación de la comunidad de desarrollo de software— el movimiento ágil estásiguiendo la misma ruta histórica.11Consideración del desarrollo ágil desoftwareLa escena: Oficina de Doug Miller.Participantes: Doug Miller, gerente de ingeniería de software;Jamie Lazar, miembro del equipo de software; Vinod Raman, integrante del equipo de software.La conversación:(Tocan a la puerta; Jamie y Vinod entran a la oficina de Doug.)Jamie: Doug, ¿tienes un minuto?Doug: Seguro, Jamie, ¿qué pasa?Jamie: Hemos estado pensando en nuestra conversación de ayersobre el proceso… ya sabes, el que vamos a elegir para este nuevoproyecto de CasaSegura.Doug: ¿Y?Vinod: Hablé con un amigo de otra compañía, y me contó sobre laprogramación extrema. Es un modelo de proceso ágil… ¿has oídode él?Doug: Sí, algunas cosas buenas y otras malas.Jamie: Bueno, a nosotros nos pareció bien. Permite el desarrollo desoftware realmente rápido, usa algo llamado programación en parejas para revisar la calidad en tiempo real… Pienso que es muybueno.Doug: Tiene muchas ideas realmente buenas. Por ejemplo, megusta el concepto de programación en parejas y la idea de que losparticipantes deben formar parte del equipo.Jamie: ¿Qué? ¿Quieren decir que mercadotecnia trabajará connosotros en el proyecto?Doug (afirmando con la cabeza): Ellos son uno de los participantes, ¿o no?Jamie: Sí… Pedirán cambios cada cinco minutos.Vinod: No necesariamente. Mi amigo dijo que hay formas de“adoptar” los cambios durante un proyecto de XP.Doug: Entonces, chicos, ¿piensan que debemos usar XP?Jamie: Definitivamente, sería bueno considerarlo.Doug: Estoy de acuerdo. E incluso si elegimos un modelo incremental como nuestro enfoque, no hay razón para no incorporar muchode lo que XP tiene que ofrecer.Vinod: Doug, dijiste hace un rato “cosas buenas y malas”. ¿Cuálesson las malas?Doug: Lo que no me gusta es la forma en la que XP desprecia elanálisis y el diseño… algo así como decir que la escritura del códigoestá donde hay acción…(Los miembros del equipo se miran entre sí y sonríen.)Doug: Entonces, ¿están de acuerdo con el enfoque XP?Jamie (habla por ambos): ¡Escribir código es lo que hacemos,jefe!Doug (ríe): Es cierto, pero me gustaría ver que dediquen un pocomenos de tiempo a escribir código y luego a repetirlo, y que pasenalgo más de tiempo en el análisis de lo que debe hacerse para diseñar una solución que funcione.Vinod: Tal vez tengamos las dos cosas, agilidad con un poco dedisciplina.Doug: Creo que podemos, Vinod. En realidad, estoy seguro de quese puede.CASASEGURACita:“Nuestra profesión pasa por lasmetodologías como un chico de14 años pasa por la ropa.”Stephen Hawrysh y JimRuprecht11 Esto no es algo malo. Antes de que uno o varios modelos se acepten como el estándar de facto, todos deben luchar por conquistar las mentes y corazones de los ingenieros de software. Los “ganadores” evolucionan hacialas mejores prácticas, mientras que los “perdedores” desaparecen o se funden con los modelos ganadores.03Pressman(055-080).indd 67 14/1/10 13:41:1268 PARTE UNO EL PROCESO DEL SOFTWAREComo se dijo en la sección anterior, el más usado de todos los modelos ágiles de proceso esla programación extrema (XP). Pero se han propuesto muchos otros y están en uso en toda laindustria. Entre ellos se encuentran los siguientes:• Desarrollo adaptativo de software (DAS)• Scrum• Método de desarrollo de sistemas dinámicos (MDSD)• Cristal• Desarrollo impulsado por las características (DIC)• Desarrollo esbelto de software (DES)• Modelado ágil (MA)• Proceso unificado ágil (PUA)En las secciones que siguen se presenta un panorama muy breve de cada uno de estos modeloságiles del proceso. Es importante notar que todos los modelos de proceso ágil se apegan (enmayor o menor grado) al Manifiesto para el desarrollo ágil de software y a los principios descritosen la sección 3.3.1. Para mayores detalles, consulte las referencias mencionadas en cada subsección o ingrese en la entrada “desarrollo de software ágil” de Wikipedia.123.5.1 Desarrollo adaptativo de software (DAS)El desarrollo adaptativo de software (DAS) fue propuesto por Jim Highsmith [Hig00] como unatécnica para elaborar software y sistemas complejos. Los fundamentos filosóficos del DAS secentran en la colaboración humana y en la organización propia del equipo.Highsmith argumenta que un enfoque de desarrollo adaptativo basado en la colaboración es“tanto una fuente de orden en nuestras complejas interacciones, como de disciplina e ingeniería”. Él define un “ciclo de vida” del DAS (véase la figura 3.3) que incorpora tres fases: especulación, colaboración y aprendizaje.12 Consulte http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.planeación adaptativa del ciclo enunciado de la misión restricciones del proyecto requerimientos básicosplan de entrega en el tiempocomponentes implementados o probados grupos de enfoque para recibir retroalimentación revisiones técnicas formalesanálisis post mórtemRecabar requerimientos JAD miniespecificacionesincremento de softwareajustes para los ciclos posterioresEntregacolaboraciónespeculaciónaprendizajeFIGURA 3.3Desarrolloadaptativode softwareWebRefEn la dirección www.adaptivesd.com hay referencias útiles sobre elDAS.03Pressman(055-080).indd 68 14/1/10 13:41:12CAPÍTULO 3 DESARROLLO ÁGIL 69Durante la especulación, se inicia el proyecto y se lleva a cabo la planeación adaptativa delciclo. La especulación emplea la información de inicio del proyecto —enunciado de misión delos clientes, restricciones del proyecto (por ejemplo, fechas de entrega o descripciones de usuario) y requerimientos básicos— para definir el conjunto de ciclos de entrega (incrementos desoftware) que se requerirán para el proyecto.No importa lo completo y previsor que sea el plan del ciclo, será inevitable que cambie. Conbase en la información obtenida al terminar el primer ciclo, el plan se revisa y se ajusta, de modoque el trabajo planeado se acomode mejor a la realidad en la que trabaja el equipo DAS.Las personas motivadas usan la colaboración de manera que multiplica su talento y producción creativa más allá de sus números absolutos. Este enfoque es un tema recurrente en todoslos métodos ágiles. Sin embargo, la colaboración no es fácil. Incluye la comunicación y el trabajoen equipo, pero también resalta el individualismo porque la creatividad individual desempeñaun papel importante en el pensamiento colaborativo. Es cuestión, sobre todo, de confianza. Laspersonas que trabajan juntas deben confiar una en otra a fin de: 1) criticarse sin enojo, 2) ayudarse sin resentimiento, 3) trabajar tan duro, o más, que como de costumbre, 4) tener el conjunto de aptitudes para contribuir al trabajo, y 5) comunicar los problemas o preocupaciones demanera que conduzcan a la acción efectiva.Conforme los miembros de un equipo DAS comienzan a desarrollar los componentes queforman parte de un ciclo adaptativo, el énfasis se traslada al “aprendizaje” de todo lo que hayen el avance hacia la terminación del ciclo. En realidad, Highsmith [Hig00] afirma que los desarrolladores de software sobreestiman con frecuencia su propia comprensión (de la tecnología,del proceso y del proyecto) y que el aprendizaje los ayudará a mejorar su nivel de entendimientoreal. Los equipos DAS aprenden de tres maneras: grupos de enfoque (véase el capítulo 5), revisiones técnicas (véase el capítulo 14) y análisis post mórtem del proyecto.La filosofía DAS tiene un mérito, sin importar el modelo de proceso que se use. El énfasisgeneral que hace el DAS en la dinámica de los equipos con organización propia, la colaboracióninterpersonal y el aprendizaje individual y del equipo generan equipos para proyectos de software que tienen una probabilidad de éxito mucho mayor.3.5.2 ScrumScrum (nombre que proviene de cierta jugada que tiene lugar durante un partido de rugby)13 esun método de desarrollo ágil de software concebido por Jeff Sutherland y su equipo de desarrollo a principios de la década de 1990. En años recientes, Schwaber y Beedle [Sch01a] han desarrollado más los métodos Scrum.Los principios Scrum son congruentes con el manifiesto ágil y se utilizan para guiar actividades de desarrollo dentro de un proceso de análisis que incorpora las siguientes actividades estructurales: requerimientos, análisis, diseño, evolución y entrega. Dentro de cada actividadestructural, las tareas del trabajo ocurren con un patrón del proceso (que se estudia en el párrafosiguiente) llamado sprint. El trabajo realizado dentro de un sprint (el número de éstos que requiere cada actividad estructural variará en función de la complejidad y tamaño del producto)se adapta al problema en cuestión y se define —y con frecuencia se modifica— en tiempo realpor parte del equipo Scrum. El flujo general del proceso Scrum se ilustra en la figura 3.4.Scrum acentúa el uso de un conjunto de patrones de proceso del software [Noy02] que handemostrado ser eficaces para proyectos con plazos de entrega muy apretados, requerimientoscambiantes y negocios críticos. Cada uno de estos patrones de proceso define un grupo de acciones de desarrollo:La colaboración eficaz con el clientesólo ocurrirá si evita cualquier actituddel tipo “nosotros y ellos”.CONSEJO13 Se forma un grupo de jugadores alrededor del balón y todos trabajan juntos (a veces con violencia) para moverloa través del campo.PUNTOCLAVEEl DAS pone el énfasis en elaprendizaje como elemento clavepara lograr un equipo con“organización propia”.WebRefEn la dirección www.controlchaos.com hay información útil sobre Scrum.PUNTOCLAVEScrum incorpora un conjunto depatrones del proceso que ponen elénfasis en las prioridades delproyecto, las unidades de trabajoagrupadas, la comunicación y laretroalimentación frecuente con elcliente.03Pressman(055-080).indd 69 14/1/10 13:41:1270 PARTE UNO EL PROCESO DEL SOFTWARERetraso: lista de prioridades de los requerimientos o características del proyecto que dan alcliente un valor del negocio. Es posible agregar en cualquier momento otros aspectos al retraso (ésta es la forma en la que se introducen los cambios). El gerente del proyecto evalúa elretraso y actualiza las prioridades según se requiera.Sprints: consiste en unidades de trabajo que se necesitan para alcanzar un requerimientodefinido en el retraso que debe ajustarse en una caja de tiempo14 predefinida (lo común son 30días). Durante el sprint no se introducen cambios (por ejemplo, aspectos del trabajo retrasado). Así, el sprint permite a los miembros del equipo trabajar en un ambiente de corto plazopero estable.Reuniones Scrum: son reuniones breves (de 15 minutos, por lo general) que el equipoScrum efectúa a diario. Hay tres preguntas clave que se pide que respondan todos los miembros del equipo [Noy02]:• ¿Qué hiciste desde la última reunión del equipo?• ¿Qué obstáculos estás encontrando?• ¿Qué planeas hacer mientras llega la siguiente reunión del equipo?Un líder del equipo, llamado maestro Scrum, dirige la junta y evalúa las respuestas de cada persona. La junta Scrum ayuda al equipo a descubrir los problemas potenciales tan pronto comosea posible. Asimismo, estas juntas diarias llevan a la “socialización del conocimiento” [Bee99],con lo que se promueve una estructura de equipo con organización propia.Demostraciones preliminares: entregar el incremento de software al cliente de modo que lafuncionalidad que se haya implementado pueda demostrarse al cliente y éste pueda evaluarla.cada24 horas30 díasScrum: reunión diaria de 15 minutos.Los miembros del equipo respondena preguntas básicas:1) ¿Qué hiciste desde la última reunión Scrum?2) ¿Tienes algún obstáculo?3) ¿Qué harás antes de la próxima reunión?Retraso del sprint:Característica(s)asignadas parael sprintRetraso del productoCaracterísticas del producto que desea el cliente con prioridadAspectoscon retrasoampliadospor el equipoAl final del sprintse demuestra la nuevafuncionalidadFIGURA 3.4Flujo del procesoScrum14 Una caja de tiempo es un término de la administración de proyectos (véase la parte 4 de este libro) que indica eltiempo que se ha asignado para cumplir alguna tarea.03Pressman(055-080).indd 70 14/1/10 13:41:12CAPÍTULO 3 DESARROLLO ÁGIL 71Es importante notar que las demostraciones preliminares no contienen toda la funcionalidadplaneada, sino que éstas se entregarán dentro de la caja de tiempo establecida.Beedle y sus colegas [Bee99] presentan un análisis exhaustivo de estos patrones en el que dicen:“Scrum supone de entrada la existencia de caos…” Los patrones de proceso Scrum permiten queun equipo de software trabaje con éxito en un mundo en el que es imposible eliminar la incertidumbre.3.5.3 Método de desarrollo de sistemas dinámicos (MDSD)El método de desarrollo de sistemas dinámicos (MDSD) [Sta97] es un enfoque de desarrollo ágilde software que “proporciona una estructura para construir y dar mantenimiento a sistemas quecumplan restricciones apretadas de tiempo mediante la realización de prototipos incrementalesen un ambiente controlado de proyectos” [CCS02]. La filosofía MDSD está tomada de una versión modificada de la regla de Pareto: 80 por ciento de una aplicación puede entregarse en 20por ciento del tiempo que tomaría entregarla completa (100 por ciento).El MDSD es un proceso iterativo de software en el que cada iteración sigue la regla de 80 porciento. Es decir, se requiere sólo suficiente trabajo para cada incremento con objeto de facilitarel paso al siguiente. Los detalles restantes se terminan más tarde, cuando se conocen los requerimientos del negocio y se han pedido y efectuado cambios.El grupo DSDM Consortium (www.dsdm.org) es un conglomerado mundial de compañíasque adoptan colectivamente el papel de “custodios” del método. El consorcio ha definido unmodelo de proceso ágil, llamado ciclo de vida MDSD, que define tres ciclos iterativos distintos,precedidos de dos actividades adicionales al ciclo de vida:Estudio de factibilidad: establece los requerimientos y restricciones básicas del negocio, asociados con la aplicación que se va a construir, para luego evaluar si la aplicación es un candidato viable para aplicarle el proceso MDSD.Estudio del negocio: establece los requerimientos e información funcionales que permitiránla aplicación para dar valor al negocio; asimismo, define la arquitectura básica de la aplicación e identifica los requerimientos para darle mantenimiento.Iteración del modelo funcional: produce un conjunto de prototipos incrementales que demuestran al cliente la funcionalidad. (Nota: todos los prototipos de MDSD están pensados paraque evolucionen hacia la aplicación que se entrega.) El objetivo de este ciclo iterativo es recabar requerimientos adicionales por medio de la obtención de retroalimentación de los usuarios cuando practican con el prototipo.Diseño e iteración de la construcción: revisita los prototipos construidos durante la iteracióndel modelo funcional a fin de garantizar que en cada iteración se ha hecho ingeniería en formaque permita dar valor operativo del negocio a los usuarios finales; la iteración del modelo funcional y el diseño e iteración de la construcción ocurren de manera concurrente.Implementación: coloca el incremento más reciente del software (un prototipo “operacional”) en el ambiente de operación. Debe notarse que: 1) el incremento tal vez no sea el de100% final, o 2) quizá se pidan cambios cuando el incremento se ponga en su lugar. En cualquier caso, el trabajo de desarrollo MDSD continúa y vuelve a la actividad de iteración del modelo funcional.El MDSD se combina con XP (véase la sección 3.4) para dar un enfoque de combinación quedefine un modelo sólido del proceso (ciclo de vida MDSD) con las prácticas detalladas (XP)que se requieren para elaborar incrementos de software. Además, los conceptos DAS se adaptan a un modelo combinado del proceso.PUNTOCLAVEEl MDSD es una estructura deproceso que adopta las tácticas deotro enfoque ágil, como XP.WebRefEn la dirección www.dsdm.org hayrecursos útiles para el MDSD.03Pressman(055-080).indd 71 14/1/10 13:41:1372 PARTE UNO EL PROCESO DEL SOFTWARE3.5.4 CristalAlistar Cockburn [Coc05] creó la familia Cristal de métodos ágiles15 a fin de obtener un enfoquede desarrollo de software que premia la “maniobrabilidad” durante lo que Cockburn caracterizacomo “un juego cooperativo con recursos limitados, de invención y comunicación, con el objetivo primario de entregar software útil que funcione y con la meta secundaria de plantear el siguiente juego” [Coc02].Para lograr la maniobrabilidad, Cockburn y Highsmith definieron un conjunto de metodologías, cada una con elementos fundamentales comunes a todos, y roles, patrones de proceso,producto del trabajo y prácticas que son únicas para cada uno. La familia Cristal en realidad esun conjunto de ejemplos de procesos ágiles que han demostrado ser efectivos para diferentestipos de proyectos. El objetivo es permitir que equipos ágiles seleccionen al miembro de la familia Cristal más apropiado para su proyecto y ambiente.3.5.5 Desarrollo impulsado por las características (DIC)El desarrollo impulsado por las características (DIC) lo concibió originalmente Peter Coad y suscolegas [Coa99] como modelo práctico de proceso para la ingeniería de software orientada aobjetos. Stephen Palmer y John Felsing [Pal02] ampliaron y mejoraron el trabajo de Coad con ladescripción de un proceso adaptativo y ágil aplicable a proyectos de software de tamaño moderado y grande.Igual que otros proyectos ágiles, DIC adopta una filosofía que: 1) pone el énfasis en la colaboración entre los integrantes de un equipo DIC; 2) administra la complejidad de los problemas ydel proyecto con el uso de la descomposición basada en las características, seguida de la integración de incrementos de software, y 3) comunica los detalles técnicos en forma verbal, gráficay con medios basados en texto. El DIC pone el énfasis en las actividades de aseguramiento dela calidad del software mediante el estímulo de la estrategia de desarrollo incremental, el usode inspecciones del diseño y del código, la aplicación de auditorías de aseguramiento de la calidad del software (véase el capítulo 16), el conjunto de mediciones y el uso de patrones (para elanálisis, diseño y construcción).En el contexto del DIC, una característica “es una función valiosa para el cliente que puedeimplementarse en dos semanas o menos” [Coa99]. El énfasis en la definición de característicasproporciona los beneficios siguientes:• Debido a que las características son bloques pequeños de funcionalidad que se entrega,los usuarios las describen con más facilidad, entienden cómo se relacionan entre sí y lasrevisan mejor en busca de ambigüedades, errores u omisiones.• Las características se organizan por jerarquía de grupos relacionados con el negocio.• Como una característica es el incremento de software DIC que se entrega, el equipodesarrolla características operativas cada dos semanas.• El diseño y representación en código de las características son más fáciles de inspeccionar con eficacia porque éstas son pequeñas.• La planeación, programación de actividades y seguimiento son determinadas por lajerarquía de características, y no por un conjunto de tareas de ingeniería de softwareadoptadas en forma arbitraria.Coad y sus colegas [Coa99] sugieren el esquema siguiente para definir una característica:<acción> el <resultado> <a|por|de|para> un <objeto>15 El nombre “cristal” se deriva de los cristales de minerales, cada uno de los cuales tiene propiedades específicasde color, forma y dureza.PUNTOCLAVECristal es una familia de modelos deproceso con el mismo “códigogenético” pero diferentes métodospara adaptarse a las característicasdel proyecto.WebRefEn la dirección www.featuredrivendevelopment.com/ se encuentra una ampliavariedad de artículos y presentacionessobre el DIC.03Pressman(055-080).indd 72 14/1/10 13:41:13CAPÍTULO 3 DESARROLLO ÁGIL 73donde <objeto> es “una persona, lugar o cosa (incluso roles, momentos del tiempo o intervalostemporales, o descripciones parecidas a las entradas de un catálogo)”. Algunos ejemplos decaracterísticas para una aplicación de comercio electrónico son los siguientes:Agregar el producto al carrito de comprasMostrar las especificaciones técnicas del productoGuardar la información de envío para el clienteUn conjunto de características agrupa las que son similares en categorías relacionadas con elnegocio y se define así:<acción><ndo> un <objeto>Por ejemplo: Haciendo una venta del producto es un conjunto de características que agruparía lasque ya se mencionaron y otras más.El enfoque DIC define cinco actividades estructurales “colaborativas” [Coa99] (en el enfoqueDIC se llaman “procesos”), como se muestra en la figura 3.5.El DIC pone más énfasis que otros métodos ágiles en los lineamientos y técnicas para la administración de proyectos. A medida que éstos aumentan su tamaño y complejidad, no es raroque la administración de proyectos ad hoc sea inadecuada. Para los desarrolladores, sus gerentes y otros participantes, es esencial entender el estado del proyecto, es decir, los avances realizados y los problemas que han surgido. Si la presión por cumplir el plazo de entrega es mucha,tiene importancia crítica determinar si la entrega de los incrementos del software está programada en forma adecuada. Para lograr esto, el DIC define seis puntos de referencia durante eldiseño e implementación de una característica: “recorrido por el diseño, diseño, inspeccióndel diseño, código, inspección del código, decisión de construir” [Coa99].3.5.6 Desarrollo esbelto de software (DES)El desarrollo esbelto de software (DES) adapta los principios de la manufactura esbelta al mundode la ingeniería de software. Los principios de esbeltez que inspiran al proceso DES se resumencomo sigue ([Pop03], [Pop06a]): eliminar el desperdicio, generar calidad, crear conocimiento, aplazar el compromiso, entregar rápido, respetar a las personas y optimizar al todo.Es posible adaptar cada uno de estos principios al proceso del software. Por ejemplo, eliminarel desperdicio en el contexto de un proyecto de software ágil significa [Das05]: 1) no agregarcaracterísticas o funciones extrañas, 2) evaluar el costo y el efecto que tendrá en la programación de actividades cualquier nuevo requerimiento solicitado, 3) eliminar cualesquiera etapassuperfluas del proceso, 4) establecer mecanismos para mejorar la forma en la que los miembrosDesarrollarun modelogeneralElaboraruna listade característicasPlansegúncaracterísticasDiseñosegúncaracterísticasConstruirsegúncaracterísticas(más formaque contenido)Lista de características agrupadasen conjuntosy áreas temáticasPlan de desarrolloPropietarios de clasePropietariosde conjuntos decaracterísticasPaquetede diseño(secuencias)Función terminadacon valor parael clienteFIGURA 3.5Desarrolloimpulsado por lascaracterísticas[Coa99] (conpermiso)03Pressman(055-080).indd 73 14/1/10 13:41:1374 PARTE UNO EL PROCESO DEL SOFTWAREdel equipo obtienen información, 5) asegurar que las pruebas detecten tantos errores como seaposible, 6) reducir el tiempo requerido para pedir y obtener una decisión que afecta al softwareo al proceso que se aplica para crearlo, y 7) simplificar la manera en la que se transmite la información a todos los participantes involucrados en el proceso.Para un análisis detallado del DES y para conocer lineamientos prácticos a fin de implementar el proceso, debe consultarse [Pop06a] y [Pop06b].3.5.7 Modelado ágil (MA)Hay muchas situaciones en las que los ingenieros de software deben construir sistemas grandesde importancia crítica para el negocio. El alcance y complejidad de tales sistemas debe modelarse de modo que: 1) todos los actores entiendan mejor cuáles son las necesidades que debensatisfacerse, 2) el problema pueda dividirse con eficacia entre las personas que deben resolverlo,y 3) se asegure la calidad a medida que se hace la ingeniería y se construye el sistema.En los últimos 30 años se ha propuesto una gran variedad de métodos de modelado y notación para la ingeniería de software con objeto de hacer el análisis y el diseño (tanto en la arquitectura como en los componentes). Estos métodos tienen su mérito, pero se ha demostrado queson difíciles de aplicar y sostener (en muchos proyectos). Parte del problema es el “peso” dedichos métodos de modelación. Con esto se hace referencia al volumen de la notación que serequiere, al grado de formalismo sugerido, al tamaño absoluto de los modelos para proyectosgrandes y a la dificultad de mantener el(los) modelo(s) conforme suceden los cambios. Sin embargo, el análisis y el modelado del diseño tienen muchos beneficios para los proyectos grandes,aunque no fuera más que porque hacen a esos proyectos intelectualmente más manejables.¿Hay algún enfoque ágil para el modelado de la ingeniería de software que brinde una alternativa?En el “sitio oficial de modelado ágil”, Scott Ambler [Amb02a] describe el modelado ágil (MA)del modo siguiente:El modelado ágil (MA) es una metodología basada en la práctica para modelar y documentar coneficacia los sistemas basados en software. En pocas palabras, es un conjunto de valores, principios yprácticas para hacer modelos de software aplicables de manera eficaz y ligera a un proyecto de desarrollo de software. Los modelos ágiles son más eficaces que los tradicionales porque son sólo buenos,sin pretender ser perfectos.El modelado ágil adopta todos los valores del manifiesto ágil. La filosofía de modelado ágilafirma que un equipo ágil debe tener la valentía para tomar decisiones que impliquen rechazarun diseño y reconstruirlo. El equipo también debe tener la humildad de reconocer que los tecnólogos no tienen todas las respuestas y que los expertos en el negocio y otros participantesdeben ser respetados e incluidos.Aunque el MA sugiere una amplia variedad de principios de modelado “fundamentales” y“suplementarios”, aquellos que son exclusivos del MA son los siguientes [Amb02a]:Modelo con un propósito. Un desarrollador que use el MA debe tener en mente unameta específica (por ejemplo, comunicar información al cliente o ayudarlo a entender mejor algún aspecto del software) antes de crear el modelo. Una vez identificada la meta parael modelo, el tipo y nivel de detalle de la notación por usar serán más obvios.Uso de modelos múltiples. Hay muchos modelos y notaciones diferentes que puedenusarse para describir el software. Para la mayoría de proyectos sólo es esencial un pequeñosubconjunto. El MA sugiere que para dar la perspectiva necesaria, cada modelo debe presentar un diferente aspecto del sistema y que sólo deben utilizarse aquellos modelos queden valor al público al que se dirigen.Cita:“El otro día fui a la farmacia poruna medicina para el resfriado… no fue fácil. Había todauna pared cubierta de productos. Al recorrerla vi uno que erade acción rápida, pero otro queera de larga duración… ¿Quées más importante, el presenteo el futuro?”Jerry SeinfeldWebRefEn la dirección www.agilemodeling.com hayinformación amplia sobre elmodelado ágil.03Pressman(055-080).indd 74 14/1/10 13:41:14CAPÍTULO 3 DESARROLLO ÁGIL 75Viajar ligero. Conforme avanza el trabajo de ingeniería de software, conserve sólo aquellos modelos que agreguen valor a largo plazo y elimine los demás. Todo producto del trabajo que se conserve debe recibir mantenimiento cuando haya cambios. Esto representauna labor que hace lento al equipo. Ambler [Amb02a] afirma que “cada vez que se decideconservar un modelo, se pierde agilidad en nombre de la conveniencia de tener disponibleesa información en forma abstracta para el equipo (y de ese modo mejorar potencialmentela comunicación dentro del equipo, así como con los participantes)”.El contenido es más importante que la representación. El modelado debe transmitirinformación al público al que se dirige. Un modelo con sintaxis perfecta que transmita pococontenido útil no es tan valioso como otro que tenga notación defectuosa, pero que, noobstante, provea contenido de valor para los usuarios.Conocer los modelos y herramientas que se utilizan en su creación. Entender lasfortalezas y debilidades de cada modelo y las herramientas que se emplean para crearlos.Adaptación local. El enfoque de modelado debe adaptarse a las necesidades del equipoágil.Un segmento importante de la comunidad de ingeniería de software ha adoptado el lenguaje deunificado de modelado (UML, por sus siglas en inglés)16 como el método preferido para representar modelos del análisis y del diseño. El proceso unificado (véase el capítulo 2) fue desarrollado para proveer una estructura para la aplicación del UML. Scott Ambler [Amb06] desarrollóuna versión simplificada del PU que integra su filosofía de modelado ágil.3.5.8 El proceso unificado ágil (PUA)El proceso unificado ágil (PUA) adopta una filosofía “en serie para lo grande” e “iterativa para lopequeño” [Amb06] a fin de construir sistemas basados en computadora. Al adoptar las actividades en fase clásicas del PU —concepción, elaboración, construcción y transición—, el PUA brindaun revestimiento en serie (por ejemplo, una secuencia lineal de actividades de ingeniería desoftware) que permite que el equipo visualice el flujo general del proceso de un proyecto de software. Sin embargo, dentro de cada actividad, el equipo repite con objeto de alcanzar la agilidady entregar tan rápido como sea posible incrementos de software significativos a los usuariosfinales. Cada iteración del PUA aborda las actividades siguientes [Amb06]:• Modelado. Se crean representaciones de UML de los dominios del negocio y el problema.No obstante, para conservar la agilidad, estos modelos deben ser “sólo suficientementebuenos” [Amb06] para permitir que el equipo avance.• Implementación. Los modelos se traducen a código fuente.• Pruebas. Igual que con la XP, el equipo diseña y ejecuta una serie de pruebas paradetectar errores y garantizar que el código fuente cumple sus requerimientos.• Despliegue. Como en la actividad general del proceso que se estudió en los capítulos 1 y2, el despliegue en este contexto se centra en la entrega de un incremento de softwarey en la obtención de retroalimentación de los usuarios finales.• Configuración y administración del proyecto. En el contexto del PUA, la administración dela configuración (véase el capítulo 22) incluye la administración del cambio y el riesgo, yel control de cualesquiera productos del trabajo persistentes17 que produzca el equipo.“Viajar ligero” es una filosofíaapropiada para todo el trabajo deingeniería de software. Construir sóloaquellos modelos que agreguenvalor… ni más ni menos.CONSEJO16 En el apéndice 1 se presenta un método breve para aprender UML.17 Un producto del trabajo persistente es un modelo o documento o caso de prueba producido por el equipo y que seconservará durante un periodo indeterminado. No se eliminará una vez entregado el incremento de software.03Pressman(055-080).indd 75 14/1/10 13:41:1476 PARTE UNO EL PROCESO DEL SOFTWARELa administración del proyecto da seguimiento y controla el avance del equipo ycoordina sus actividades.• Administración del ambiente. La administración del ambiente coordina una infraestructura del proceso que incluye estándares, herramientas y otra tecnología de apoyo de laque dispone el equipo.Aunque el PUA tiene conexiones históricas y técnicas con el lenguaje unificado de modelado, esimportante observar que el modelado UML puede usarse junto con cualesquiera de los modelosde proceso ágil descritos en la sección 3.5.18 Las herramientas mencionadas aquí no son obligatorias, sólo son una muestra en esta categoría. En la mayoríade casos, sus nombres son marcas registradas por sus respectivos desarrolladores.Desarrollo ágilObjetivo: El objetivo de las herramientas de desarrolloágil es ayudar en uno o más aspectos de éste, con énfasisen facilitar la elaboración rápida de software funcional. Estas herramientas también pueden emplearse cuando se aplican modelos deproceso prescriptivo (véase el capítulo 2).Mecánica: Las herramientas de mecánica varían. En general, lasherramientas ágiles incluyen el apoyo automatizado para la planeación del proyecto, el desarrollo de casos y la obtención de requerimientos, el diseño rápido, la generación de código y la realización depruebas.Herramientas representativas:18Nota: Debido a que el desarrollo ágil es un tema de moda, la mayoría de los vendedores de herramientas de software tratan de colocar herramientas que lo apoyan. Las que se mencionan a continuación tienen características que las hacen particularmente útilespara los proyectos ágiles.OnTime, desarrollada por Axosoft (www.axosoft.com), prestaapoyo a la administración de un proceso ágil para distintas actividades técnicas dentro del proceso.Ideogramic UML, desarrollada por Ideogramic (www.ideogramic.com), es un conjunto de herramientas UML desarrolladas específicamente para usarlas dentro de un proceso ágil.Together Tool Set, distribuido por Borland (www.borland.com),proporciona un grupo de herramientas para apoyar muchas actividades técnicas dentro de XP y otros procesos ágiles.HERRAMIENTAS DE SOFTWARE 3.6 CONJUNTO DE HERRAMIENTAS PARA EL PROCESO ÁGILAlgunos defensores de la filosofía ágil afirman que las herramientas automatizadas de software(por ejemplo, las de diseño) deben verse como un complemento menor de las actividades delequipo, y no como algo fundamental para el éxito. Sin embargo, Alistair Cockburn [Coc04] sugiere que las herramientas tienen un beneficio y que “los equipos ágiles favorecen el uso deherramientas que permiten el flujo rápido de entendimiento. Algunas de estas herramientas sonsociales y comienzan incluso en la etapa de reclutamiento. Otras son tecnológicas y ayudan aque los equipos distribuidos simulen su presencia física. Muchas herramientas son físicas ypermiten que las personas las manipulen en talleres”.Prácticamente todos los modelos de proceso ágil son elementos clave en la contratación delpersonal adecuado (reclutamiento), la colaboración en equipo, la comunicación con los participantes y la administración indirecta; por eso, Cockburn afirma que las “herramientas” que seabocan a dichos aspectos son factores críticos para el éxito de la agilidad. Por ejemplo, una“herramienta” de reclutamiento tal vez sea el requerimiento de que un prospecto a miembro delequipo pase algunas horas programando en pareja con alguien que ya es integrante del equipo.El “ajuste” se evalúa de inmediato.Las “herramientas” de colaboración y comunicación por lo general son de baja tecnología eincorporan cualquier mecanismo (“proximidad física, pizarrones, tableros, tarjetas y notas adPUNTOCLAVEEl “conjunto de herramientas” queda apoyo a los procesos ágiles secentra más en aspectos de lapersona que en los de la tecnología.03Pressman(055-080).indd 76 14/1/10 13:41:14CAPÍTULO 3 DESARROLLO ÁGIL 77heribles” [Coc04] que provea información y coordinación entre los desarrolladores ágiles. Lacomunicación activa se logra por medio de la dinámica del equipo (por ejemplo, la programación en parejas), mientras que la comunicación pasiva se consigue con “radiadores de información” (un tablero que muestre el estado general de de los distintos componentes de un incremento). Las herramientas de administración de proyectos no ponen el énfasis en la gráfica deGantt y la sustituyen con otras de valor agregado o “gráficas de pruebas creadas versus pasadas;otras herramientas ágiles se utilizan para optimizar el ambiente en el que trabaja el equipo ágil(por ejemplo, áreas más eficientes para reunirse), mejoran la cultura del equipo por medio decultivar las interacciones sociales (equipos con algo en común), dispositivos físicos (pizarroneselectrónicos) y el mejoramiento del proceso (por ejemplo, la programación por parejas o la cajade tiempo)” [Coc04].¿Algunas de las mencionadas son en verdad herramientas? Sí, lo son, si facilitan el trabajoefectuado por un miembro del equipo ágil y mejoran la calidad del producto final. 3.7 RESUMENEn una economía moderna, las condiciones del mercado cambian con rapidez, los clientes yusuarios finales necesitan evolucionar y surgen nuevas amenazas competitivas sin aviso previo.Los profesionales deben enfocar la ingeniería de software en forma que les permita mantenerseágiles para definir procesos maniobrables, adaptativos y esbeltos que satisfagan las necesidadesde los negocios modernos.Una filosofía ágil para la ingeniería de software pone el énfasis en cuatro aspectos clave: laimportancia de los equipos con organización propia que tienen el control sobre el trabajo querealizan, la comunicación y colaboración entre los miembros del equipo y entre los profesionales y sus clientes, el reconocimiento de que el cambio representa una oportunidad y la insistencia en la entrega rápida de software que satisfaga al consumidor. Los modelos de proceso ágilhan sido diseñados para abordar cada uno de estos aspectos.La programación extrema (XP) es el proceso ágil de más uso. Organizada con cuatro actividades estructurales: planeación, diseño, codificación y pruebas, la XP sugiere cierto número detécnicas innovadoras y poderosas que permiten a un equipo ágil generar entregas frecuentesde software que posee características y funcionalidad que han sido descritas y clasificadas según su prioridad por los participantes.Otros modelos de proceso ágil también insisten en la colaboración humana y en la organización propia del equipo, pero definen sus actividades estructurales y seleccionan diferentes puntos de importancia. Por ejemplo, el DAS utiliza un proceso iterativo que incluye un ciclo deplaneación adaptativa, métodos relativamente rigurosos para recabar requerimientos, y un ciclode desarrollo iterativo que incorpora grupos de consumidores y revisiones técnicas formalescomo mecanismos de retroalimentación en tiempo real. El Scrum pone el énfasis en el uso deun conjunto de patrones de software que han demostrado ser eficaces para proyectos que tienenplazos de entrega apretados, requerimientos cambiantes o que se emplean en negocios críticos.Cada patrón de proceso define un conjunto de tareas de desarrollo y permite al equipo Scrumconstruir un proceso que se adapte a las necesidades del proyecto. El método de desarrollo desistemas dinámicos (MDSD) resalta el uso de la programación con caja de tiempo y sugiere queen cada incremento de software sólo se requiere el trabajo suficiente que facilite el paso al incremento que sigue. Cristal es una familia de modelos de proceso ágil que se adaptan a las características específicas del proyecto.El desarrollo impulsado por las características (DIC) es algo más “formal” que otros métodoságiles, pero conserva su agilidad al centrar al equipo del proyecto en el desarrollo de características, funciones valiosas para el cliente que pueden implementarse en dos semanas o menos. El03Pressman(055-080).indd 77 14/1/10 13:41:1478 PARTE UNO EL PROCESO DEL SOFTWAREdesarrollo esbelto de software (DES) ha adaptado los principios de la manufactura esbelta almundo de la ingeniería de software. El modelado ágil (MA) sugiere que el modelado es esencialpara todos los sistemas, pero que la complejidad, tipo y tamaño del modelo deben ajustarse alsoftware que se va a elaborar. El proceso unificado ágil (PUA) adopta una filosofía “serial en logrande” e “iterativo en lo pequeño” para la elaboración de software. PROBLEMAS Y PUNTOS POR EVALUAR3.1. Vuelva a leer el “Manifiesto para el desarrollo ágil de software” al principio de este capítulo. ¿Puedepensar en una situación en la que uno o más de los cuatro “valores” pudieran causar problemas al equipo desoftware?3.2. Describa con sus propias palabras la agilidad (para proyectos de software).3.3. ¿Por qué un proceso iterativo hace más fácil administrar el cambio? ¿Es iterativo todo proceso ágilanalizado en este capítulo? ¿Es posible terminar un proyecto en sólo una iteración y aún así conseguir quesea ágil? Explique sus respuestas.3.4. ¿Podría describirse cada uno de los procesos ágiles con el uso de las actividades estructurales generales mencionadas en el capítulo 2? Construya una tabla que mapee las actividades generales en las actividades definidas para cada proceso ágil.3.5. Proponga un “principio de agilidad” más que ayudaría al equipo de ingeniería de software a ser aún másmaniobrable.3.6. Seleccione un principio de agilidad mencionado en la sección 3.3.1 y trate de determinar si está incluidoen cada uno de los modelos de proceso presentados en este capítulo. [Nota: sólo se presentó el panoramageneral de estos modelos de proceso, por lo que tal vez no fuera posible determinar si un principio está incluido en uno o más de ellos, a menos que el lector hiciera una investigación (lo que no se requiere para esteproblema)].3.7. ¿Por qué cambian tanto los requerimientos? Después de todo, ¿la gente no sabe lo que quiere?3.8. La mayoría de modelos de proceso ágil recomiendan la comunicación cara a cara. No obstante, losmiembros del equipo de software y sus clientes tal vez estén alejados geográficamente. ¿Piensa usted queesto implica que debe evitarse la separación geográfica? ¿Se le ocurren formas de resolver este problema?3.9. Escriba una historia de usuario XP que describa la característica de “lugares favoritos” o “marcadores”disponible en la mayoría de navegadores web.3.10. ¿Qué es una solución en punta en XP?3.11. Describa con sus propias palabras los conceptos de rediseño y programación en parejas de XP.3.12. Haga otras lecturas y describa lo que es una caja de tiempo. ¿Cómo ayuda a un equipo DAS para queentregue incrementos de software en un corto periodo?3.13. ¿Se logra el mismo resultado con la regla de 80% del MDSD y con el enfoque de la caja de tiempo delDAS?3.14. Con el formato de patrón de proceso presentado en el capítulo 2, desarrolle uno para cualquiera delos patrones Scrum presentados en la sección 3.5.2.3.15. ¿Por qué se le llama a Cristal familia de métodos ágiles?3.16. Con el formato de característica DIC descrito en la sección 3.5.5, defina un conjunto de característicaspara un navegador web. Luego desarrolle un conjunto de características para el primer conjunto.3.17. Visite el sitio oficial de modelación ágil y elabore la lista completa de todos los principios fundamentales y secundarios del MA.3.18. El conjunto de herramientas propuestas en la sección 3.6 da apoyo a muchos de los aspectos “suaves”de los métodos ágiles. Debido a que la comunicación es tan importante, recomiende un conjunto de herramientas reales que podría utilizarse para que los participantes de un equipo ágil se comuniquen mejor.03Pressman(055-080).indd 78 14/1/10 13:41:15CAPÍTULO 3 DESARROLLO ÁGIL 79 LECTURAS ADICIONALES Y FUENTES DE INFORMACIÓNLa filosofía general y principios que subyacen al desarrollo de software ágil se estudian a profundidad enmuchos de los libros mencionados a lo largo de este capítulo. Además, los textos de Shaw y Warden (The Artof Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Construction, Springer, 2005) y Carmichael y Haywood (Better Software Faster, Prentice-Hall, 2002) presentan análisis útiles del tema. Aguanno(Managing Agile Projects, Multi-Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products, Addison-Wesley, 2004) y Larman (Agile and Iterative Development: A Manager’s Guide, Addison-Wesley, 2003) presentan el punto de vista de la administración y consideran ciertos aspectos de la administración de proyectos. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) exponeuna encuesta acerca de los principios, procesos y prácticas ágiles. Booch y sus colegas (Balancing Agility andDiscipline, Addison-Wesley, 2004) hacen un análisis fructífero del delicado equilibrio entre agilidad y disciplina.Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) explica los principios,patrones y prácticas que se requieren para desarrollar “código limpio” en un ambiente de ingeniería de software ágil. Leffingwell (Scaling Software Agility: Best Practices for Large Enterprises, Addison-Wesley, 2007)estudia estrategias para ampliar las prácticas ágiles en proyectos grandes. Lippert y Rook (Refactoring in LargeSoftware Projects: Performing Complex Restructurings Succesfully, Wiley, 2006) analizan el uso del rediseñocuando se aplica a sistemas grandes y complejos. Stamelos y Sfetsos (Agile Software Development QualityAssurance, IGI Global, 2007) analizan las técnicas SQA que forman la filosofía ágil.En la última década se han escrito decenas de libros sobre programación extrema. Beck (Extreme Programming Explained: Embrace Change, 2a. ed., Addison-Wesley, 2004) sigue siendo la referencia definitiva al respecto. Además, Jeffries y sus colegas (Extreme Programming Installed, Addison-Wesley, 2000), Succi y Marchesi (Extreme Programming Examined, Addison-Wesley, 2001), Newkirk y Martin (Extreme Programming inPractice, Addison-Wesley, 2001) y Auer y sus colegas (Extreme Programming Applied: Play to Win, AddisonWesley, 2001) hacen un análisis detallado de XP y dan una guía para aplicarla de la mejor forma. McBreen(Questioning Extreme Programming, Addison-Wesley, 2003) adopta un enfoque crítico sobre XP, y definecuándo y dónde es apropiada. Un estudio profundo de la programación por parejas se presenta en McBreen(Pair Programming Illuminated, Addison-Wesley, 2003).Highsmith [Hig00] analiza con detalle el DAS. Schwaber (The Enterprise and Scrum, Microsoft Press, 2007)estudia el empleo de Scrum para proyectos que tienen un efecto grande en los negocios. Los detalles deScrum los estudian Schwaber y Beedle (Agile Software Development with SCRUM, Prentice-Hall, 2001). Algunos tratamientos útiles del MDSD han sido escritos por DSDM Consortium (DSDM: Business Focused Development, 2a. ed., Pearson Education, 2003) y Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997).Cockburn (Crystal Clear, Addison-Wesley, 2005) presenta un panorama excelente de la familia de procesosCristal. Palmer y Felsing [Pal02] dan un tratamiento detallado del DIC. Carmichael y Haywood (Better SoftwareFaster, Prentice-Hall, 2002) proporcionan otro análisis útil del DIC, que incluye un recorrido, paso a paso, porla mecánica del proceso. Poppendieck y Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison-Wesley, 2003) dan lineamientos para la administración y el control de proyectoságiles. Ambler y Jeffries (Agile Modeling, Wiley, 2002) estudian el MA con cierta profundidad.En internet existe una amplia variedad de fuentes de información sobre el desarrollo de software ágil. Enel sitio web del libro hay una lista actualizada de referencias en la Red Mundial que son relevantes para elproceso ágil, en la dirección: www.mhhe.com/engcs/compsci/pressman/professional/olc/ser.htm.03Pressman(055-080).indd 79 14/1/10 13:41:1503Pressman(055-080).indd 80 14/1/10 13:41:1581MODELADOPARTEDosEn esta parte de la obra, aprenderá sobre los principios, conceptos ymétodos que se usan para crear requerimientos de alta calidady para diseñar modelos. En los capítulos que siguen se abordan preguntas como las siguientes:• ¿Qué conceptos y principios guían la práctica de la ingeniería de software?• ¿Qué son los requerimientos de ingeniería y cuáles son los conceptossubyacentes que llevan a un buen análisis de requerimientos?• ¿Cómo se crean los requerimientos del modelo y cuáles son sus elementos?• ¿Cuáles son los elementos de un buen diseño?• ¿Cómo establece el diseño de la arquitectura una estructura paratodas las demás acciones de diseño y qué modelos se utilizan?• ¿Cómo se diseñan componentes de software de alta calidad?• ¿Qué conceptos, modelos y métodos se aplican al diseñar una interfaz de usuario?• ¿Qué es el diseño basado en patrones?• ¿Qué estrategias y métodos especializados se emplean para diseñarwebapps?Una vez que se respondan estas preguntas, el lector estará mejor preparado para aplicar en la práctica la ingeniería de software.04Pressman(081-100).indd 81 26/1/10 17:31:5582CAPÍTULO4 PRINCIPIOS QUE GUÍANLA PRÁCTICAC ONCEPTOS CLAVEPrincipios fundamentales . . . . 83Principios que gobiernanlo siguiente: codificación. . . . . . . . . . . . . 94 comunicación. . . . . . . . . . . . 86 despliegue . . . . . . . . . . . . . 96 diseño . . . . . . . . . . . . . . . . 92 modelado . . . . . . . . . . . . . . 90 planeación . . . . . . . . . . . . . 88 pruebas . . . . . . . . . . . . . . . 95 requerimientos . . . . . . . . . . 91¿Qué es? La práctica de la ingeniería desoftware es un conjunto amplio de principios,conceptos, métodos y herramientas que debenconsiderarse al planear y desarrollar software.¿Quién lo hace? Los profesionales (ingenieros de software)y sus gerentes realizan varias tareas de ingeniería de software.¿Por qué es importante? El proceso de software proporciona a todos los involucrados en la creación de un sistemao producto basado en computadora un mapa para llegarcon éxito al destino. La práctica proporciona los detallesque se necesitarán para circular por la carretera. Indicadónde se localizan los puentes, los caminos cerrados y lasbifurcaciones. Ayuda a entender los conceptos y principiosque deben entenderse y seguirse a fin de llegar con seguridad y rapidez. Enseña a manejar, dónde disminuir la velocidad y en qué lugares acelerar. En el contexto de la ingeniería de software, la práctica es lo que se hace día tras díaconforme el software evoluciona de idea a realidad.¿Cuáles son los pasos? Son tres los elementos de lapráctica que se aplican sin importar el modelo de procesoque se elija. Se trata de: principios, conceptos y métodos.Un cuarto elemento de la práctica —las herramientas— daapoyo a la aplicación de los métodos.¿Cuál es el producto final? La práctica incluye las actividades técnicas que generan todos los productos del trabajo definidos por el modelo del proceso de software quese haya escogido.¿Cómo me aseguro de que lo hice bien? En primerlugar, hay que tener una comprensión sólida de los principios que se aplican al trabajo (por ejemplo, el diseño) encuestión. Después, asegúrese de que se escogió el métodoapropiado para el trabajo, use herramientas automatizadas cuando sean adecuadas para la tarea y sea firmerespecto de la necesidad de técnicas de aseguramiento dela calidad de los productos finales que se generen.U N AMIRADARÁPIDA1 Algunos escritores afirman que cualquiera de estos términos excluye a los otros. En realidad, la ingeniería desoftware es las tres cosas.En un libro que explora las vidas y pensamientos de los ingenieros de software, Ellen Ullman [Ull97] ilustra una parte de su vida con el relato de lo que piensa un profesional delsoftware cuando está bajo presión:No tengo idea de la hora que es. En esta oficina no hay ventanas ni reloj, sólo la pantalla de un hornode microondas que parpadea su LED de color rojo: 12:00, 12:00, 12:00. Joel y yo hemos estado programando durante varios días. Tenemos una falla, endemoniada y testaruda. Así que nos sentimosbien con el pulso rojo sin tiempo, como si fuera un pasmo de nuestros cerebros, de algún modo sincronizados al mismo ritmo del parpadeo…¿En qué estamos trabajando? Los detalles se me escapan. Tal vez ayudamos a personas pobres yenfermas o mejoramos un conjunto de rutinas de bajo nivel de un protocolo de base de datos distribuida, no me importa. Debería importarme; en otra parte de mi ser —más tarde, quizá cuando salgade este cuarto lleno de computadoras— me preocuparé mucho de por qué y para quién y con quépropósito estoy escribiendo software. Pero ahora, no. He cruzado una membrana tras la que el mundoreal y sus asuntos ya no importan. Soy ingeniera de software.La anterior es una imagen tenebrosa de la práctica de la ingeniería de software, pero si sedetienen un poco a pensarlo, muchos de los lectores de este libro se verán reflejados en ella.Las personas que elaboran software de cómputo practican el arte, artesanía o disciplina1conocida como ingeniería de software. Pero, ¿qué es la “práctica” de la ingeniería de software?En un sentido general, es un conjunto de conceptos, principios, métodos y herramientas a losque un ingeniero de software recurre en forma cotidiana. La práctica permite que los gerentes04Pressman(081-100).indd 82 26/1/10 17:31:56CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 83 4.1 CONOCIMIENTO DE LA INGENIERÍA DE SOFTWAREEn un editorial publicado hace diez años en IEEE Software, Steve McConnell [McC99] hizo elsiguiente comentario:Muchos trabajadores del software piensan que el conocimiento de la ingeniería de software casi exclusivamente consiste en tecnologías específicas: Java, Perl, html, C++, Linux, Windows NT, etc. Paraprogramar computadoras es necesario conocer los detalles tecnológicos específicos. Si alguien pideal lector que escriba un programa en C++, tiene que saber algo sobre este lenguaje a fin de que elprograma funcione.Es frecuente escuchar que el conocimiento del desarrollo de software tiene una vida media de tresaños, lo que significa que la mitad de lo que es necesario saber hoy será obsoleto dentro de tres años.En el dominio del conocimiento relacionado con la tecnología es probable que eso se cumpla. Perohay otra clase de conocimiento de desarrollo de software —algo que el autor considera como los“principios de la ingeniería de software”— que no tiene una vida media de tres años. Es factible quedichos principios sirvan al programador profesional durante toda su carrera.McConnell continúa y plantea que el cuerpo de conocimientos de la ingeniería de software(alrededor del año 2000) ha evolucionado para convertirse en un “núcleo estable” que representa cerca de “75% del conocimiento necesario para desarrollar un sistema complejo”. Pero,¿qué es lo que hay dentro de ese núcleo estable?Como dice McConnell, los principios fundamentales —ideas elementales que guían a los ingenieros de software en el trabajo que realizan— dan ahora un fundamento a partir del cualpueden aplicarse y evaluarse los modelos, métodos y herramientas de ingeniería. 4.2 PRINCIPIOS FUNDAMENTALESLa práctica de la ingeniería de software está guiada por un conjunto de principios fundamentales que ayudan en la aplicación del proceso de software significativo y en la ejecución de métodos eficaces de ingeniería de software. En el nivel del proceso, los principios fundamentalesestablecen un fundamento filosófico que guía al equipo de software cuando realiza actividades estructurales y actividades sombrilla, cuando navega por el flujo del proceso y elabora unconjunto de productos del trabajo de la ingeniería de software. En el nivel de la práctica, losprincipios fundamentales definen un conjunto de valores y reglas que sirven como guía cuandose analiza un problema, se diseña una solución, se implementa y prueba ésta y cuando, alfinal, se entrega el software a la comunidad de usuarios.En el capítulo 1 se identificó un conjunto de principios generales que amplían el proceso ypráctica de la ingeniería de software: 1) agregar valor para los usuarios finales, 2) mantenerlosencillo, 3) fijar la visión (del producto y el proyecto), 4) reconocer que otros consumen (y debenentender) lo que usted produce, 5) abrirse al futuro, 6) planear la reutilización y 7) ¡pensar!Aunque estos principios generales son importantes, se caracterizan en un nivel tan alto de abstracción que en ocasiones son difíciles de traducir en la práctica cotidiana de la ingeniería deadministren proyectos de software y que los ingenieros de software elaboren programas decómputo. La práctica da al modelo del proceso de software el saber técnico y administrativopara realizar el trabajo. La práctica transforma un enfoque caprichoso y disperso en algo másorganizado, más eficaz y con mayor probabilidad de alcanzar el éxito.A lo largo de lo que resta del libro se estudiarán distintos aspectos de la práctica de la ingeniería de software. En este capítulo, la atención se pone en los principios y conceptos que laguían en lo general.Cita:“En teoría no hay diferenciaentre la teoría y la práctica.Pero en la práctica sí la hay.”Jan van de Snepscheut04Pressman(081-100).indd 83 26/1/10 17:31:5684 PARTE DOS MODELADOsoftware. En las subsecciones que siguen se analizan con más detalle los principios fundamentales que guían el proceso y la práctica.4.2.1 Principios que guían el procesoEn la parte 1 de este libro se estudia la importancia del proceso de software y se describen losabundantes modelos de proceso que se han propuesto para hacer el trabajo de ingeniería desoftware. Sin que importe que un modelo sea lineal o iterativo, prescriptivo o ágil, puede caracterizarse con el empleo de la estructura general del proceso aplicable a todos los modelos deproceso. Los siguientes principios fundamentales se aplican a la estructura y, por extensión, atodo proceso de software:Principio 1. Ser ágil. Ya sea que el modelo de proceso que se elija sea prescriptivo oágil, son los principios básicos del desarrollo ágil los que deben gobernar el enfoque. Todoaspecto del trabajo que se haga debe poner el énfasis en la economía de acción: en mantener el enfoque técnico tan sencillo como sea posible, hacer los productos del trabajo que segeneran tan concisos como se pueda y tomar las decisiones localmente, siempre que seaposible.Principio 2. En cada etapa, centrarse en la calidad. La condición de salida para todaactividad, acción y tarea del proceso debe centrarse en la calidad del producto del trabajoque se ha generado.Principio 3. Estar listo para adaptar. El proceso no es una experiencia religiosa, en élno hay lugar para el dogma. Cuando sea necesario, adapte su enfoque a las restriccionesimpuestas por el problema, la gente y el proyecto en sí.Principio 4. Formar un equipo eficaz. El proceso y práctica de la ingeniería de software son importantes, pero el objetivo son las personas. Forme un equipo con organización propia en el que haya confianza y respeto mutuos.Principio 5. Establecer mecanismos para la comunicación y coordinación. Los proyectos fallan porque la información importante cae en las grietas o porque los participantesno coordinan sus esfuerzos para crear un producto final exitoso. Éstos son aspectos de laadministración que deben enfrentarse.Principio 6. Administrar el cambio. El enfoque puede ser formal o informal, pero deben establecerse mecanismos para administrar la forma en la que los cambios se solicitan,evalúan, aprueban e implementan.Principio 7. Evaluar el riesgo. Son muchas las cosas que pueden salir mal cuando sedesarrolla software. Es esencial establecer planes de contingencia.Principio 8. Crear productos del trabajo que agreguen valor para otros. Sólo genereaquellos productos del trabajo que agreguen valor para otras actividades, acciones o tareasdel proceso. Todo producto del trabajo que se genere como parte de la práctica de ingeniería de software pasará a alguien más. La lista de las funciones y características requeridasse dará a la persona (o personas) que desarrollará(n) un diseño, el diseño pasará a quienesgeneran código y así sucesivamente. Asegúrese de que el producto del trabajo imparte lainformación necesaria sin ambigüedades u omisiones.La parte 4 de este libro se centra en aspectos de la administración del proyecto y del proceso,y analiza en detalle varios aspectos de cada uno de dichos principios.4.2.2 Principios que guían la prácticaLa práctica de la ingeniería de software tiene un solo objetivo general: entregar a tiempo software operativo de alta calidad que contenga funciones y características que satisfagan las neTodo proyecto y equipo son únicos.Esto significa que debe adaptar elproceso para que se ajuste mejor asus necesidades.CONSEJOCita:“La verdad es que siempre sesabe lo que es correcto hacer. Laparte difícil es hacerlo.”General H. NormanSchwarzkopf04Pressman(081-100).indd 84 26/1/10 17:31:57CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 85cesidades de todos los participantes. Para lograrlo, debe adoptarse un conjunto de principiosfundamentales que guíen el trabajo técnico. Estos principios tienen mérito sin que importen losmétodos de análisis y diseño que se apliquen, ni las técnicas de construcción (por ejemplo, ellenguaje de programación o las herramientas automatizadas) que se usen o el enfoque de verificación y validación que se elija. Los siguientes principios fundamentales son vitales para lapráctica de la ingeniería de software:Principio 1. Divide y vencerás. Dicho en forma más técnica, el análisis y el diseño siempre deben enfatizar la separación de entidades (SdE). Un problema grande es más fácil deresolver si se divide en un conjunto de elementos (o entidades). Lo ideal es que cada entidad entregue funcionalidad distinta que pueda desarrollarse, y en ciertos casos validarse,independientemente de otras entidades.Principio 2. Entender el uso de la abstracción. En su parte medular, una abstracciónes una simplificación de algún elemento complejo de un sistema usado para comunicar significado en una sola frase. Cuando se usa la abstracción hoja de cálculo, se supone que secomprende lo que es una hoja de cálculo, la estructura general de contenido que presenta ylas funciones comunes que se aplican a ella. En la práctica de la ingeniería de software, seusan muchos niveles diferentes de abstracción, cada uno de los cuales imparte o implicasignificado que debe comunicarse. En el trabajo de análisis y diseño, un equipo de softwarenormalmente comienza con modelos que representan niveles elevados de abstracción (porejemplo, una hoja de cálculo) y poco a poco los refina en niveles más bajos de abstracción(como una columna o la función SUM).Joel Spolsky [Spo02] sugiere que “todas las abstracciones no triviales hasta cierto puntoson esquivas”. El objetivo de una abstracción es eliminar la necesidad de comunicar detalles. Pero, en ocasiones, los efectos problemáticos precipitados por estos detalles se “filtran” por todas partes. Sin la comprensión de los detalles, no puede diagnosticarse con facilidad la causa de un problema.Principio 3. Buscar la coherencia. Ya sea que se esté creando un modelo de los requerimientos, se desarrolle un diseño de software, se genere código fuente o se elaboren casosde prueba, el principio de coherencia sugiere que un contexto familiar hace que el softwaresea más fácil de usar. Como ejemplo, considere el diseño de una interfaz de usuario parauna webapp. La colocación consistente de opciones de menú, el uso de un esquema coherencia de color y el uso coherencia de íconos reconocibles ayudan a hacer que la interfazsea muy buena en el aspecto ergonómico.Principio 4. Centrarse en la transferencia de información. El software tiene que vercon la transferencia de información: de una base de datos a un usuario final, de un sistemaheredado a una webapp, de un usuario final a una interfaz gráfica de usuario (GUI, por sussiglas en inglés), de un sistema operativo a una aplicación, de un componente de softwarea otro… la lista es casi interminable. En todos los casos, la información fluye a través deuna interfaz, y como consecuencia hay posibilidades de cometer errores, omisiones o ambigüedades. Este principio implica que debe ponerse atención especial al análisis, diseño,construcción y prueba de las interfaces.Principio 5. Construir software que tenga modularidad eficaz. La separación de entidades (principio 1) establece una filosofía para el software. La modularidad proporciona unmecanismo para llevar a cabo dicha filosofía. Cualquier sistema complejo puede dividirseen módulos (componentes), pero la buena práctica de la ingeniería de software demandamás. La modularidad debe ser eficaz. Es decir, cada módulo debe centrarse exclusivamenteen un aspecto bien delimitado del sistema: debe ser cohesivo en su función o restringido enel contenido que representa. Además, los módulos deben estar interconectados en formaPUNTOCLAVELos problemas son más fáciles deresolver cuando se subdividen enentidades separadas, distintas entresí, solucionables individualmente yverificables.04Pressman(081-100).indd 85 26/1/10 17:31:5786 PARTE DOS MODELADOrelativamente sencilla: cada módulo debe tener poco acoplamiento con otros módulos,fuentes de datos y otros aspectos ambientales.Principio 6. Buscar patrones. Brad Appleton [App00] sugiere que:El objetivo de los patrones dentro de la comunidad de software es crear un cúmulo de bibliografíaque ayude a los desarrolladores de software a resolver problemas recurrentes que surgen a lo largodel desarrollo. Los patrones ayudan a crear un lenguaje compartido para comunicar perspectiva yexperiencia acerca de dichos patrones y sus soluciones. La codificación formal de estas solucionesy sus relaciones permite acumular con éxito el cuerpo de conocimientos que define nuestra comprensión de las buenas arquitecturas que satisfacen las necesidades de sus usuarios.Principio 7. Cuando sea posible, representar el problema y su solución desde variasperspectivas diferentes. Cuando un problema y su solución se estudian desde variasperspectivas distintas, es más probable que se tenga mayor visión y que se detecten loserrores y omisiones. Por ejemplo, un modelo de requerimientos puede representarse con elempleo de un punto de vista orientado a los datos, a la función o al comportamiento(véanse los capítulos 6 y 7). Cada uno brinda un punto de vista diferente del problema y desus requerimientos.Principio 8. Tener en mente que alguien dará mantenimiento al software. El software será corregido en el largo plazo, cuando se descubran sus defectos, se adapte a loscambios de su ambiente y se mejore en el momento en el que los participantes pidan máscapacidades. Estas actividades de mantenimiento resultan más fáciles si se aplica una práctica sólida de ingeniería de software a lo largo del proceso de software.Estos principios no son todo lo que se necesita para elaborar software de alta calidad, peroestablecen el fundamento para todos los métodos de ingeniería de software que se estudian eneste libro. 4.3 PRINCIPIOS QUE GUÍAN TODA ACTIVIDAD ESTRUCTURALEn las secciones que siguen se consideran los principios que tienen mucha relevancia para eléxito de cada actividad estructural genérica, definida como parte del proceso de software. Enmuchos casos, los principios que se estudian para cada una de las actividades estructurales sonun refinamiento de los principios presentados en la sección 4.2. Tan sólo son principios fundamentales planteados en un nivel más bajo de abstracción.4.3.1 Principios de comunicaciónAntes de que los requerimientos del cliente se analicen, modelen o especifiquen, deben recabarse a través de la actividad de comunicación. Un cliente tiene un problema que parece abordable mediante una solución basada en computadora. Usted responde a la solicitud de ayudadel cliente. Ha comenzado la comunicación. Pero es frecuente que el camino que lleva de lacomunicación a la comprensión esté lleno de agujeros.La comunicación efectiva (entre colegas técnicos, con el cliente y otros participantes, y conlos gerentes de proyecto) se encuentra entre las actividades más difíciles que deben enfrentarse.En este contexto, aquí se estudian principios de comunicación aplicados a la comunicación conel cliente. Sin embargo, muchos de ellos se aplican por igual en todas las formas de comunicación que ocurren dentro de un proyecto de software.Principio 1. Escuchar. Trate de centrarse en las palabras del hablante en lugar de formular su respuesta a dichas palabras. Si algo no está claro, pregunte para aclararlo, peroevite las interrupciones constantes. Si una persona habla, nunca parezca usted beligeranteen sus palabras o actos (por ejemplo, con giros de los ojos o movimientos de la cabeza).Use patrones (véase el capítulo 12)a fin de acumular conocimiento yexperiencia para las futurasgeneraciones de ingenieros desoftware.CONSEJOCita:“El ingeniero ideal es una mezcla… no es un científico, no esun matemático, no es un sociólogo ni un escritor; pero pararesolver problemas de ingeniería utiliza conocimiento ytécnicas de algunas o de todasesas disciplinas.”N. W. Dougherty04Pressman(081-100).indd 86 26/1/10 17:31:57CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 87Principio 2. Antes de comunicarse, prepararse. Dedique algún tiempo a entender elproblema antes de reunirse con otras personas. Si es necesario, haga algunas investigaciones para entender el vocabulario propio del negocio. Si tiene la responsabilidad de conducir la reunión, prepare una agenda antes de que ésta tenga lugar.Principio 3. Alguien debe facilitar la actividad. Toda reunión de comunicación debetener un líder (facilitador) que: 1) mantenga la conversación en movimiento hacia una dirección positiva, 2) sea un mediador en cualquier conflicto que ocurra y 3) garantice que sesigan otros principios.Principio 4. Es mejor la comunicación cara a cara. Pero por lo general funciona mejor cuando está presente alguna otra representación de la información relevante. Por ejemplo, un participante quizá genere un dibujo o documento en “borrador” que sirva comocentro de la discusión.Principio 5. Tomar notas y documentar las decisiones. Las cosas encuentran el modode caer en las grietas. Alguien que participe en la comunicación debe servir como “secretario” y escribir todos los temas y decisiones importantes.Principio 6. Perseguir la colaboración. La colaboración y el consenso ocurren cuandoel conocimiento colectivo de los miembros del equipo se utiliza para describir funciones ocaracterísticas del producto o sistema. Cada pequeña colaboración sirve para generar confianza entre los miembros del equipo y crea un objetivo común para el grupo.Principio 7. Permanecer centrado; hacer módulos con la discusión. Entre más personas participen en cualquier comunicación, más probable es que la conversación salte deun tema a otro. El facilitador debe formar módulos de conversación para abandonar untema sólo después de que se haya resuelto (sin embargo, considere el principio 9).Principio 8. Si algo no está claro, hacer un dibujo. La comunicación verbal tiene suslímites. Con frecuencia, un esquema o dibujo arroja claridad cuando las palabras no bastanpara hacer el trabajo.Principio 9. a) Una vez que se acuerde algo, avanzar. b) Si no es posible ponerse deacuerdo en algo, avanzar. c) Si una característica o función no está clara o nopuede aclararse en el momento, avanzar. La comunicación, como cualquier actividadde ingeniería de software, requiere tiempo. En vez de hacer iteraciones sin fin, las personasque participan deben reconocer que hay muchos temas que requieren análisis (véase elprincipio 2) y que “avanzar” es a veces la mejor forma de tener agilidad en la comunicación.Principio 10. La negociación no es un concurso o un juego. Funciona mejor cuandolas dos partes ganan. Hay muchas circunstancias en las que usted y otros participantesdeben negociar funciones y características, prioridades y fechas de entrega. Si el equipo haCita:“Las preguntas directas y lasrespuestas directas son el camino más corto hacia las mayoresperplejidades.”Mark TwainAntes de comunicarse, asegúrese deque entiende el punto de vista de laotra parte, conozca un poco susnecesidades y después escuche.CONSEJO¿Qué pasa si no puedellegarse a un acuerdocon el cliente en algúnaspecto relacionado conel proyecto??Los ingenieros de software se comunican con muchos participantes diferentes, pero los clientes y los usuarios finalesson quienes tienen el efecto más significativo en el trabajo técnico quese desarrollará. En ciertos casos, el cliente y el usuario final son lamisma persona, pero para muchos proyectos son individuos distintosque trabajan para diferentes gerentes en distintas organizaciones denegocios.Un cliente es la persona o grupo que 1) solicitó originalmente quese construyera el software, 2) define los objetivos generales del negocio para el software, 3) proporciona los requerimientos básicos delproducto y 4) coordina la obtención de fondos para el proyecto. Enun negocio de productos o sistema, es frecuente que el cliente sea eldepartamento de mercadotecnia. En un ambiente de tecnologías de lainformación (TI), el cliente tal vez sea un componente o departamentodel negocio.Un usuario final es la persona o grupo que 1) usará en realidadel software que se elabore para lograr algún propósito del negocioy 2) definirá los detalles de operación del software de modo que sealcance el propósito del negocio.INFORMACIÓNLa diferencia entre los clientes y los usuarios finales04Pressman(081-100).indd 87 26/1/10 17:31:5888 PARTE DOS MODELADOcolaborado bien, todas las partes tendrán un objetivo común. Aun así, la negociación demandará el compromiso de todas las partes.4.3.2 Principios de planeaciónLa actividad de comunicación ayuda a definir las metas y objetivos generales (por supuesto,sujetos al cambio conforme pasa el tiempo). Sin embargo, la comprensión de estas metas yobjetivos no es lo mismo que definir un plan para lograrlo. La actividad de planeación incluyeun conjunto de prácticas administrativas y técnicas que permiten que el equipo de softwaredefina un mapa mientras avanza hacia su meta estratégica y sus objetivos tácticos.Créalo, es imposible predecir con exactitud cómo se desarrollará un proyecto de software. Noexiste una forma fácil de determinar qué problemas técnicos se encontrarán, qué informaciónimportante permanecerá oculta hasta que el proyecto esté muy avanzado, qué malos entendidos habrá o qué aspectos del negocio cambiarán. No obstante, un buen equipo de software debeplanear con este enfoque.Hay muchas filosofías de planeación.2 Algunas personas son “minimalistas” y afirman que esfrecuente que el cambio elimine la necesidad de hacer un plan detallado. Otras son “tradicionalistas” y dicen que el plan da un mapa eficaz y que entre más detalles tenga menos probable seráque el equipo se pierda. Otros más son “agilistas” y plantean que tal vez sea necesario un “juegode planeación” rápido, pero que el mapa surgirá a medida que comience el “trabajo real” con elsoftware.¿Qué hacer? En muchos proyectos, planear en exceso consume tiempo y es estéril (porqueson demasiadas las cosas que cambian), pero planear poco es una receta para el caos. Igual quela mayoría de cosas de la vida, la planeación debe ser tomada con moderación, suficiente paraque dé una guía útil al equipo, ni más ni menos. Sin importar el rigor con el que se haga la planeación, siempre se aplican los principios siguientes:La escena: Lugar de trabajo del equipo de ingeniería de software.Participantes: Jamie Lazar, Vinod Roman y Ed Robins, miembrosdel equipo de software.La conversación:Ed: ¿Qué has oído sobre el proyecto CasaSegura?Vinod: La reunión de arranque está programada para la semanasiguiente.Jamie: Traté de investigar algo, pero no salió bien.Ed: ¿Qué quieres decir?Jamie: Bueno, llamé a Lisa Pérez. Ella es la encargada de mercadotecnia en esto.Vinod: ¿Y…?Jamie: Yo quería que me dijera las características y funciones deCasaSegura… esa clase de cosas. En lugar de ello, comenzó ahacerme preguntas sobre sistemas de seguridad, de vigilancia… Nosoy experto en eso.Vinod: ¿Qué te dice eso?(Jamie se encoge de hombros.)Vinod: Será que mercadotecnia quiere que actuemos como consultores y mejor que hagamos alguna tarea sobre esta área de productos antes de nuestra junta de arranque. Doug dijo que quería que“colaboráramos” con nuestro cliente, así que será mejor que aprendamos cómo hacerlo.Ed: Tal vez hubiera sido mejor ir a su oficina. Las llamadas por teléfono simplemente no sirven para esta clase de trabajos.Jamie: Están en lo correcto. Tenemos que actuar juntos o nuestrasprimeras comunicaciones serán una batalla.Vinod: Yo vi a Doug leyendo un libro acerca de “requerimientos deingeniería”. Apuesto a que enlista algunos principios de buenacomunicación. Voy a pedírselo prestado.Jamie: Buena idea… luego nos enseñas.Vinod (sonríe): Sí, de acuerdo.CASASEGURAErrores de comunicación2 En la parte 4 de este libro hay un análisis detallado de la planeación y administración de proyectos de software.Cita:“Al prepararme para una batalla siempre descubro que losplanes son inútiles, pero que laplaneación es indispensable.”General Dwight D.EisenhowerWebRefEn la dirección www.4pm.com/repository.htm, hay excelentesmateriales informativos sobre laplaneación y administración deproyectos.04Pressman(081-100).indd 88 26/1/10 17:31:58CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 89Principio 1. Entender el alcance del proyecto. Es imposible usar el mapa si no se sabea dónde se va. El alcance da un destino al equipo de software.Principio 2. Involucrar en la actividad de planeación a los participantes delsoftware. Los participantes definen las prioridades y establecen las restricciones del proyecto. Para incluir estas realidades, es frecuente que los ingenieros de software deban negociar la orden de entrega, los plazos y otros asuntos relacionados con el proyecto.Principio 3. Reconocer que la planeación es iterativa. Un plan para el proyecto nuncaestá grabado en piedra. Para cuando el trabajo comience, es muy probable que las cosashayan cambiado. En consecuencia, el plan deberá ajustarse para incluir dichos cambios.Además, los modelos de proceso iterativo incrementales dictan que debe repetirse la planeación después de la entrega de cada incremento de software, con base en la retroalimentación recibida de los usuarios.Principio 4. Estimar con base en lo que se sabe. El objetivo de la estimación es obtener un índice del esfuerzo, costo y duración de las tareas, con base en la comprensión quetenga el equipo sobre el trabajo que va a realizar. Si la información es vaga o poco confiable, entonces las estimaciones tampoco serán confiables.Principio 5. Al definir el plan, tomar en cuenta los riesgos. Si ha identificado riesgosque tendrían un efecto grande y es muy probable que ocurran, entonces es necesario elaborar planes de contingencia. Además, el plan del proyecto (incluso la programación de actividades) deberá ajustarse para que incluya la posibilidad de que ocurran uno o más de dichos riesgos.Principio 6. Ser realista. Las personas no trabajan 100% todos los días. En cualquier comunicación humana hay ruido. Las omisiones y ambigüedad son fenómenos de la vida. Loscambios ocurren. Aun los mejores ingenieros de software cometen errores. Éstas y otrasrealidades deben considerarse al establecer un proyecto.Principio 7. Ajustar la granularidad cuando se defina el plan. La granularidad se refiere al nivel de detalle que se adopta cuando se desarrolla un plan. Un plan con “muchagranularidad” proporciona detalles significativos en las tareas para el trabajo que se planea,en incrementos durante un periodo relativamente corto (por lo que el seguimiento y controlsuceden con frecuencia). Un plan con “poca granularidad” da tareas más amplias para eltrabajo que se planea, para plazos más largos. En general, la granularidad va de poca amucha conforme el tiempo avanza. En las siguientes semanas o meses, el proyecto se planea con detalles significativos. Las actividades que no ocurrirán en muchos meses no requieren mucha granularidad (hay demasiadas cosas que pueden cambiar).Principio 8. Definir cómo se trata de asegurar la calidad. El plan debe identificar laforma en la que el equipo de software busca asegurar la calidad. Si se realizan revisionestécnicas,3 deben programarse. Si durante la construcción va a utilizarse programación porparejas (véase el capítulo 3), debe definirse en forma explícita en el plan.Principio 9. Describir cómo se busca manejar el cambio. Aun la mejor planeaciónpuede ser anulada por el cambio sin control. Debe identificarse la forma en la que van a recibirse los cambios a medida que avanza el trabajo de la ingeniería de software. Por ejemplo, ¿el cliente tiene la posibilidad de solicitar un cambio en cualquier momento? Si se solicita uno, ¿está obligado el equipo a implementarlo de inmediato? ¿Cómo se evalúan elefecto y el costo del cambio?Cita:“El éxito es más una función delsentido común coherente quedel genio.”An WangPUNTOCLAVEEl término granularidad se refiere aldetalle con el que se representan oefectúan algunos elementos de laplaneación.3 Las revisiones técnicas se estudian en el capítulo 15.04Pressman(081-100).indd 89 26/1/10 17:31:5990 PARTE DOS MODELADOPrincipio 10. Dar seguimiento al plan con frecuencia y hacer los ajustes que serequieran. Los proyectos de software se atrasan respecto de su programación. Por tanto,tiene sentido evaluar diariamente el avance, en busca de áreas y situaciones problemáticasen las que las actividades programadas no se apeguen al avance real. Cuando se detectendesviaciones, hay que ajustar el plan en consecuencia.Para ser más eficaz, cada integrante del equipo de software debe participar en la actividad deplaneación. Sólo entonces sus miembros “firmarán” el plan.4.3.3 Principios de modeladoSe crean modelos para entender mejor la entidad real que se va a construir. Cuando ésta es física(por ejemplo, un edificio, un avión, una máquina, etc.), se construye un modelo de forma idéntica pero a escala. Sin embargo, cuando la entidad que se va a construir es software, el modelodebe adoptar una forma distinta. Debe ser capaz de representar la información que el softwaretransforma, la arquitectura y las funciones que permiten que esto ocurra, las características quedesean los usuarios y el comportamiento del sistema mientras la transformación tiene lugar. Losmodelos deben cumplir estos objetivos en diferentes niveles de abstracción, en primer lugar conla ilustración del software desde el punto de vista del cliente y después con su representaciónen un nivel más técnico.En el trabajo de ingeniería de software se crean dos clases de modelos: de requerimientos yde diseño. Los modelos de requerimientos (también conocidos como modelos de análisis) representan los requerimientos del cliente mediante la ilustración del software en tres dominios diferentes: el de la información, el funcional y el de comportamiento. Los modelos de diseño representan características del software que ayudan a los profesionales a elaborarlo con eficacia:arquitectura, interfaz de usuario y detalle en el nivel de componente.En su libro sobre modelado ágil, Scott Ambler y Ron Jeffries [Amb02b] definen un conjuntode principios de modelado4 dirigidos a todos aquellos que usan el modelo de proceso ágil (véaseel capítulo 3), pero que son apropiados para todos los ingenieros de software que efectúan acciones y tareas de modelado:Principio 1. El equipo de software tiene como objetivo principal elaborar software,no crear modelos. Agilidad significa entregar software al cliente de la manera más rápida posible. Los modelos que contribuyan a esto son benéficos, pero deben evitarse aquellos que hagan lento el proceso o que den poca perspectiva.Principio 2. Viajar ligero, no crear más modelos de los necesarios. Todo modeloque se cree debe actualizarse si ocurren cambios. Más importante aún es que todo modelonuevo exige tiempo, que de otra manera se destinaría a la construcción (codificación ypruebas). Entonces, cree sólo aquellos modelos que hagan más fácil y rápido construir elsoftware.Principio 3. Tratar de producir el modelo más sencillo que describa al problema oal software. No construya software en demasía [Amb02b]. Al mantener sencillos los modelos, el software resultante también lo será. El resultado es que se tendrá un software fácilde integrar, de probar y de mantener (para que cambie). Además, los modelos sencillos sonmás fáciles de entender y criticar por parte de los miembros del equipo, lo que da como resultado un formato funcional de retroalimentación que optimiza el resultado final.Principio 4. Construir modelos susceptibles al cambio. Suponga que sus modeloscambiarán, pero vigile que esta suposición no lo haga descuidado. Por ejemplo, como los4 Para fines de este libro, se han abreviado y reescrito los principios mencionados en esta sección.PUNTOCLAVELos modelos de requerimientosrepresentan los requerimientos delcliente. Los modelos del diseño danuna especificación concreta para laconstrucción del software.El objetivo de cualquier modelo escomunicar información. Para lograresto, use un formato consistente.Suponga que usted no estará paraexplicar el modelo. Por eso, elmodelo debe describirse por sí solo.CONSEJO04Pressman(081-100).indd 90 26/1/10 17:31:59CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 91requerimientos se modificarán, hay una tendencia a ignorar los modelos. ¿Por qué? Porquese sabe que de todos modos cambiarán. El problema con esta actitud es que sin un modelorazonablemente completo de los requerimientos, se creará un diseño (modelo de diseño)que de manera invariable carecerá de funciones y características importantes.Principio 5. Ser capaz de enunciar un propósito explícito para cada modelo que secree. Cada vez que cree un modelo, pregúntese por qué lo hace. Si no encuentra una razón sólida para la existencia del modelo, no pierda tiempo en él.Principio 6. Adaptar los modelos que se desarrollan al sistema en cuestión. Tal vezsea necesario adaptar a la aplicación la notación del modelo o las reglas; por ejemplo, unaaplicación de juego de video quizá requiera una técnica de modelado distinta que el software incrustado que controla el motor de un automóvil en tiempo real.Principio 7. Tratar de construir modelos útiles, pero olvidarse de elaborar modelosperfectos. Cuando un ingeniero de software construye modelos de requerimientos y diseño, alcanza un punto de rendimientos decrecientes. Es decir, el esfuerzo requerido paraterminar por completo el modelo y hacerlo internamente consistente deja de beneficiarsepor tener dichas propiedades. ¿Se sugiere que el modelado debe ser pobre o de baja calidad? La respuesta es “no”. Pero el modelado debe hacerse con la mirada puesta en las siguientes etapas de la ingeniería de software. Las iteraciones sin fin para obtener un modelo“perfecto” no cumplen la necesidad de agilidad.Principio 8. No ser dogmático respecto de la sintaxis del modelo. Si se tiene éxitopara comunicar contenido, la representación es secundaria. Aunque cada miembrodel equipo de software debe tratar de usar una notación consistente durante el modelado,la característica más importante del modelo es comunicar información que permita la realización de la siguiente tarea de ingeniería. Si un modelo tiene éxito en hacer esto, es perdonable la sintaxis incorrecta.Principio 9. Si su instinto dice que un modelo no es el correcto a pesar de que sevea bien en el papel, hay razones para estar preocupado. Si usted es un ingeniero desoftware experimentado, confíe en su instinto. El trabajo de software enseña muchas lecciones, algunas en el nivel del inconsciente. Si algo le dice que un modelo de diseño estádestinado a fracasar (aun cuando esto no pueda demostrarse en forma explícita), hay razones para dedicar más tiempo a su estudio o a desarrollar otro distinto.Principio 10. Obtener retroalimentación tan pronto como sea posible. Todo modelodebe ser revisado por los miembros del equipo. El objetivo de estas revisiones es obtenerretroalimentación para utilizarla a fin de corregir los errores de modelado, cambiar las interpretaciones equivocadas y agregar las características o funciones omitidas inadvertidamente.Requerimientos de los principios de modelado. En las últimas tres décadas se han desarrollado numerosos métodos de modelado de requerimientos. Los investigadores han identificado los problemas del análisis de requerimientos y sus causas, y han desarrollado varias notaciones de modelado y los conjuntos heurísticos correspondientes para resolver aquéllos. Cadamétodo de análisis tiene un punto de vista único. Sin embargo, todos están relacionados porciertos principios operacionales:Principio 1. Debe representarse y entenderse el dominio de información de unproblema. El dominio de información incluye los datos que fluyen hacia el sistema (usuarios finales, otros sistemas o dispositivos externos), los datos que fluyen fuera del sistema(por la interfaz de usuario, interfaces de red, reportes, gráficas y otros medios) y los almacenamientos de datos que recaban y organizan objetos persistentes de datos (por ejemplo,aquellos que se conservan en forma permanente).04Pressman(081-100).indd 91 26/1/10 17:31:5992 PARTE DOS MODELADOPrincipio 2. Deben definirse las funciones que realizará el software. Las funcionesdel software dan un beneficio directo a los usuarios finales y también brindan apoyo interno para las características que son visibles para aquéllos. Algunas funciones transforman los datos que fluyen hacia el sistema. En otros casos, las funciones activan algún nivelde control sobre el procesamiento interno del software o sobre los elementos externos delsistema. Las funciones se describen en muchos y distintos niveles de abstracción, que vande un enunciado de propósito general a la descripción detallada de los elementos del procesamiento que deben invocarse.Principio 3. Debe representarse el comportamiento del software (como consecuencia de eventos externos). El comportamiento del software de computadora está determinado por su interacción con el ambiente externo. Las entradas que dan los usuarios finales,el control de los datos efectuado por un sistema externo o la vigilancia de datos reunidosen una red son el motivo por el que el software se comporta en una forma específica.Principio 4. Los modelos que representen información, función y comportamientodeben dividirse de manera que revelen los detalles en forma estratificada(o jerárquica). El modelado de los requerimientos es el primer paso para resolver un problema de ingeniería de software. Eso permite entender mejor el problema y proporcionauna base para la solución (diseño). Los problemas complejos son difíciles de resolver porcompleto. Por esta razón, debe usarse la estrategia de divide y vencerás. Un problemagrande y complejo se divide en subproblemas hasta que cada uno de éstos sea relativamente fácil de entender. Este concepto se llama partición o separación de entidades, y es unaestrategia clave en el modelado de requerimientos.Principio 5. El trabajo de análisis debe avanzar de la información esencial hacia laimplementación en detalle. El modelado de requerimientos comienza con la descripción del problema desde la perspectiva del usuario final. Se describe la “esencia” del problema sin considerar la forma en la que se implementará la solución. Por ejemplo, un juegode video requiere que la jugadora “enseñe” a su protagonista en qué dirección avanzarcuando se mueve hacia un laberinto peligroso. Ésa es la esencia del problema. La implementación detallada (normalmente descrita como parte del modelo del diseño) indica cómose desarrollará la esencia. Para el juego de video, quizá se use una entrada de voz, o se escriba un comando en un teclado, o tal vez un joystick (o mouse) apunte en una dirección específica, o quizá se mueva en el aire un dispositivo sensible al movimiento.Con la aplicación de estos principios, un ingeniero de software aborda el problema en formasistemática. Pero, ¿cómo se aplican estos principios en la práctica? Esta pregunta se responderáen los capítulos 5 a 7.Principios del modelado del diseño. El modelo del diseño del software es análogo a losplanos arquitectónicos de una casa. Se comienza por representar la totalidad de lo que se va aconstruir (por ejemplo, un croquis tridimensional de la casa) que se refina poco a poco para queguíe la construcción de cada detalle (por ejemplo, la distribución de la plomería). De manerasimilar, el modelo del diseño que se crea para el software da varios puntos de vista distintos delsistema.No escasean los métodos para obtener los distintos elementos de un diseño de software.Algunos son activados por datos, lo que hace que sea la estructura de éstos la que determine laarquitectura del programa y los componentes de procesamiento resultantes. Otros están motivados por el patrón, y usan información sobre el dominio del problema (el modelo de requerimientos) para desarrollar estilos de arquitectura y patrones de procesamiento. Otros más estánorientados a objetos, y utilizan objetos del dominio del problema como impulsores de la creación de estructuras de datos y métodos que los manipulan. No obstante la variedad, todos ellosse apegan a principios de diseño que se aplican sin importar el método empleado.Cita:“Vea primero que el diseño essabio y justo: eso comprobado,siga resueltamente; no para unorenunciar a rechazar el propósito de que ha resuelto llevar acabo.”William ShakespearePUNTOCLAVEEl modelado del análisis se centra entres atributos del software: lainformación que se va a procesar, lafunción que se va a entregar y elcomportamiento que va a suceder.Cita:“En cualquier trabajo de diseño,el primer problema del ingeniero es descubrir cuál esrealmente el problema.”Autor desconocido04Pressman(081-100).indd 92 26/1/10 17:32:00CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 93Principio 1. El diseño debe poderse rastrear hasta el modelo de requerimientos. Elmodelo de requerimientos describe el dominio de información del problema, las funcionesvisibles para el usuario, el comportamiento del sistema y un conjunto de clases de requerimientos que agrupa los objetos del negocio con los métodos que les dan servicio. El modelo de diseño traduce esta información en una arquitectura, un conjunto de subsistemasque implementan las funciones principales y un conjunto de componentes que son la realización de las clases de requerimientos. Los elementos del modelo de diseño deben poderrastrearse en el modelo de requerimientos.Principio 2. Siempre tomar en cuenta la arquitectura del sistema que se va aconstruir. La arquitectura del software (véase el capítulo 9) es el esqueleto del sistemaque se va a construir. Afecta interfaces, estructuras de datos, flujo de control y comportamiento del programa, así como la manera en la que se realizarán las pruebas, la susceptibilidad del sistema resultante a recibir mantenimiento y mucho más. Por todas estas razones,el diseño debe comenzar con consideraciones de la arquitectura. Sólo después de establecida ésta deben considerarse los aspectos en el nivel de los componentes.Principio 3. El diseño de los datos es tan importante como el de las funciones deprocesamiento. El diseño de los datos es un elemento esencial del diseño de la arquitectura. La forma en la que los objetos de datos se elaboran dentro del diseño no puede dejarse al azar. Un diseño de datos bien estructurado ayuda a simplificar el flujo del programa, hace más fácil el diseño e implementación de componentes de software y máseficiente el procesamiento conjunto.Principio 4. Las interfaces (tanto internas como externas) deben diseñarse concuidado. La manera en la que los datos fluyen entre los componentes de un sistema tienemucho que ver con la eficiencia del procesamiento, la propagación del error y la simplicidad del diseño. Una interfaz bien diseñada hace que la integración sea más fácil y ayuda aquien la somete a prueba a validar las funciones componentes.Principio 5. El diseño de la interfaz de usuario debe ajustarse a las necesidades delusuario final. Sin embargo, en todo caso debe resaltar la facilidad de uso. La interfaz de usuario es la manifestación visible del software. No importa cuán sofisticadas seansus funciones internas, ni lo incluyentes que sean sus estructuras de datos, ni lo bien diseñada que esté su arquitectura, un mal diseño de la interfaz con frecuencia conduce a lapercepción de que el software es “malo”.Principio 6. El diseño en el nivel de componentes debe tener independenciafuncional. La independencia funcional es una medida de la “mentalidad única” de uncomponente de software. La funcionalidad que entrega un componente debe ser cohesiva,es decir, debe centrarse en una y sólo una función o subfunción.5Principio 7. Los componentes deben estar acoplados con holgura entre sí y con elambiente externo. El acoplamiento se logra de muchos modos: con una interfaz de componente, con mensajería, por medio de datos globales, etc. A medida que se incrementa elnivel de acoplamiento, también aumenta la probabilidad de propagación del error y disminuye la facilidad general de dar mantenimiento al software. Entonces, el acoplamiento decomponentes debe mantenerse tan bajo como sea razonable.Principio 8. Las representaciones del diseño (modelos) deben entenderse confacilidad. El propósito del diseño es comunicar información a los profesionales que generarán el código, a los que probarán el software y a otros que le darán mantenimiento en elfuturo. Si el diseño es difícil de entender, no servirá como medio de comunicación eficaz.Cita:“Las diferencias no son menores; por el contrario, son comolas que había entre Salieri yMozart. Un estudio tras otromuestran que los mejores diseñadores elaboran estructurasmás rápidas, pequeñas, sencillas, claras y producidas conmenos esfuerzo.”Frederick P. BrooksWebRefEn la dirección cs.wwc.edu/~aabyan/Design/, se encuentrancomentarios profundos sobre el procesode diseño, así como un análisis de laestética del diseño.5 En el capítulo 8 hay más análisis de la cohesión.04Pressman(081-100).indd 93 26/1/10 17:32:0094 PARTE DOS MODELADOPrincipio 9. El diseño debe desarrollarse en forma iterativa. El diseñador debe buscar más sencillez en cada iteración. Igual que ocurre con casi todas las actividadescreativas, el diseño ocurre de manera iterativa. Las primeras iteraciones sirven para mejorar el diseño y corregir errores, pero las posteriores deben buscar un diseño tan sencillocomo sea posible.Cuando se aplican en forma apropiada estos principios de diseño, se crea uno que exhibefactores de calidad tanto externos como internos [Mye78]. Los factores de calidad externos sonaquellas propiedades del software fácilmente observables por los usuarios (por ejemplo, velocidad, confiabilidad, corrección y usabilidad). Los factores de calidad internos son de importanciapara los ingenieros de software. Conducen a un diseño de alta calidad desde el punto de vistatécnico. Para obtener factores de calidad internos, el diseñador debe entender los conceptosbásicos del diseño (véase el capítulo 8).4.3.4 Principios de construcciónLa actividad de construcción incluye un conjunto de tareas de codificación y pruebas que llevaa un software operativo listo para entregarse al cliente o usuario final. En el trabajo de ingeniería de software moderna, la codificación puede ser 1) la creación directa de lenguaje de programación en código fuente (por ejemplo, Java), 2) la generación automática de código fuente queusa una representación intermedia parecida al diseño del componente que se va a construir o3) la generación automática de código ejecutable que utiliza un “lenguaje de programación decuarta generación” (por ejemplo, Visual C++).Las pruebas dirigen su atención inicial al componente, y con frecuencia se denomina pruebaunitaria. Otros niveles de pruebas incluyen 1) de integración (realizadas mientras el sistema estáen construcción), 2) de validación, que evalúan si los requerimientos se han satisfecho para todoel sistema (o incremento de software) y 3) de aceptación, que efectúa el cliente en un esfuerzopor utilizar todas las características y funciones requeridas. Los siguientes principios y conceptos son aplicables a la codificación y prueba:Principios de codificación. Los principios que guían el trabajo de codificación se relacionande cerca con el estilo, lenguajes y métodos de programación. Sin embargo, puede enunciarsecierto número de principios fundamentales:Principios de preparación: Antes de escribir una sola línea de código, asegúrese de:• Entender el problema que se trata de resolver.• Comprender los principios y conceptos básicos del diseño.• Elegir un lenguaje de programación que satisfaga las necesidades del software que se vaa elaborar y el ambiente en el que operará.• Seleccionar un ambiente de programación que disponga de herramientas que haganmás fácil su trabajo.• Crear un conjunto de pruebas unitarias que se aplicarán una vez que se haya terminadoel componente a codificar.Principios de programación: Cuando comience a escribir código, asegúrese de:• Restringir sus algoritmos por medio del uso de programación estructurada [Boh00].• Tomar en consideración el uso de programación por parejas.• Seleccionar estructuras de datos que satisfagan las necesidades del diseño.• Entender la arquitectura del software y crear interfaces que son congruentes con ella.• Mantener la lógica condicional tan sencilla como sea posible.Cita:“Durante gran parte de mi vidahe sido un mirón del software, yobservo furtivamente el códigosucio de otras personas. A vecesencuentro una verdadera joya,un programa bien estructuradoescrito en un estilo consistente,libre de errores, desarrollado demodo que cada componente essencillo y organizado, y queestá diseñado de modo que elproducto es fácil de cambiar.”David ParnasEvite desarrollar un programaelegante que resuelva el problemaequivocado. Ponga especial atenciónal primer principio de preparación.CONSEJO04Pressman(081-100).indd 94 26/1/10 17:32:00CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 95• Crear lazos anidados en forma tal que se puedan probar con facilidad.• Seleccionar nombres significativos para las variables y seguir otros estándares localesde codificación.• Escribir código que se documente a sí mismo.• Crear una imagen visual (por ejemplo, líneas con sangría y en blanco) que ayude aentender.Principios de validación: Una vez que haya terminado su primer intento de codificación, asegúrese de:• Realizar el recorrido del código cuando sea apropiado.• Llevar a cabo pruebas unitarias y corregir los errores que se detecten.• Rediseñar el código.Se han escrito más libros sobre programación (codificación) y sobre los principios y conceptosque la guían que sobre cualquier otro tema del proceso de software. Los libros sobre el temaincluyen obras tempranas sobre estilo de programación [Ker78], construcción de software práctico [McC04], perlas de programación [Ben99], el arte de programar [Knu98], temas pragmáticosde programación [Hun99] y muchísimos temas más. El análisis exhaustivo de estos principios yconceptos está más allá del alcance de este libro. Si tiene interés en profundizar, estudie una ovarias de las referencias que se mencionan.Principios de la prueba. En un libro clásico sobre las pruebas de software, Glen Myers[Mye79] enuncia algunas reglas que sirven bien como objetivos de prueba:• La prueba es el proceso que ejecuta un programa con objeto de encontrar un error.• Un buen caso de prueba es el que tiene alta probabilidad de encontrar un error que nose ha detectado hasta el momento.• Una prueba exitosa es la que descubre un error no detectado hasta el momento.Estos objetivos implican un cambio muy grande en el punto de vista de ciertos desarrolladoresde software. Ellos avanzan contra la opinión común de que una prueba exitosa es aquella queno encuentra errores en el software. El objetivo es diseñar pruebas que detecten de manerasistemática diferentes clases de errores, y hacerlo con el mínimo tiempo y esfuerzo.Si las pruebas se efectúan con éxito (de acuerdo con los objetivos ya mencionados), descubrirán errores en el software. Como beneficio secundario, la prueba demuestra que las funcionesde software parecen funcionar de acuerdo con las especificaciones, y que los requerimientos decomportamiento y desempeño aparentemente se cumplen. Además, los datos obtenidos conforme se realiza la prueba dan una buena indicación de la confiabilidad del software y ciertasindicaciones de la calidad de éste como un todo. Pero las pruebas no pueden demostrar lainexistencia de errores y defectos; sólo demuestran que hay errores y defectos. Es importanterecordar esto (que de otro modo parecería muy pesimista) cuando se efectúe una prueba.Davis [Dav95b] sugiere algunos principios para las pruebas,6 que se han adaptado para usarlos en este libro:Principio 1. Todas las pruebas deben poder rastrearse hasta los requerimientos delcliente.7 El objetivo de las pruebas de software es descubrir errores. Entonces, los defecEn un contexto amplio del diseño desoftware, recuerde que se comienza“por lo grande” y se centra en laarquitectura del software, y que setermina “en lo pequeño” y seatiende a los componentes. Para laprueba sólo se invierte el proceso.CONSEJO¿Cuáles son losobjetivos de probar elsoftware??WebRefEn la dirección www.literateprogramming.com/fpstyle.html, hay una ampliavariedad de vínculos a estándares decodificación.6 Aquí sólo se mencionan pocos de los principios de prueba de Davis. Para más información, consulte [Dav95b].7 Este principio se refiere a las pruebas funcionales, por ejemplo, aquellas que se centran en los requerimientos. Laspruebas estructurales (las que se centran en los detalles de arquitectura o lógica) tal vez no aborden directamentelos requerimientos específicos.04Pressman(081-100).indd 95 26/1/10 17:32:0096 PARTE DOS MODELADOtos más severos (desde el punto de vista del cliente) son aquellos que hacen que el programa no cumpla sus requerimientos.Principio 2. Las pruebas deben planearse mucho antes de que den comienzo. Laplaneación de las pruebas (véase el capítulo 17) comienza tan pronto como se termina elmodelo de requerimientos. La definición detallada de casos de prueba principia apenas seha concluido el modelo de diseño. Por tanto, todas las pruebas pueden planearse y diseñarse antes de generar cualquier código.Principio 3. El principio de Pareto se aplica a las pruebas de software. En este contexto, el principio de Pareto implica que 80% de todos los errores no detectados durante laspruebas se relacionan con 20% de todos los componentes de programas. Por supuesto, elproblema es aislar los componentes sospechosos y probarlos a fondo.Principio 4. Las pruebas deben comenzar “en lo pequeño” y avanzar hacia “logrande”. Las primeras pruebas planeadas y ejecutadas por lo general se centran en componentes individuales. Conforme avanzan las pruebas, la atención cambia en un intentopor encontrar errores en grupos integrados de componentes y, en última instancia, en todoel sistema.Principio 5. No son posibles las pruebas exhaustivas. Hasta para un programa de tamaño moderado, el número de permutaciones de las rutas es demasiado grande. Por estarazón, durante una prueba es imposible ejecutar todas las combinaciones de rutas. Sin embargo, es posible cubrir en forma adecuada la lógica del programa y asegurar que se hanprobado todas las condiciones en el nivel de componentes.4.3.5 Principios de despliegueComo se dijo en la parte 1 del libro, la actividad del despliegue incluye tres acciones: entrega,apoyo y retroalimentación. Como la naturaleza de los modelos del proceso del software moderno es evolutiva o incremental, el despliegue ocurre no una vez sino varias, a medida que elsoftware avanza hacia su conclusión. Cada ciclo de entrega pone a disposición de los clientes yusuarios finales un incremento de software operativo que brinda funciones y característicasutilizables. Cada ciclo de apoyo provee documentación y ayuda humana para todas las funciones y características introducidas durante los ciclos de despliegue realizados hasta ese momento. Cada ciclo de retroalimentación da al equipo de software una guía importante que dacomo resultado modificaciones de las funciones, de las características y del enfoque adoptadopara el siguiente incremento.La entrega de un incremento de software representa un punto de referencia importante paracualquier proyecto de software. Cuando el equipo se prepara para entregar un incremento, deben seguirse ciertos principios clave:Principio 1. Deben manejarse las expectativas de los clientes. Con demasiada frecuencia, el cliente espera más de lo que el equipo ha prometido entregar, y la desilusiónllega de inmediato. Esto da como resultado que la retroalimentación no sea productiva yarruine la moral del equipo. En su libro sobre la administración de las expectativas, NaomiKarten [Kar94] afirma que “el punto de inicio de la administración de las expectativas es sermás consciente de lo que se comunica y de la forma en la que esto se hace”. Ella sugiereque el ingeniero de software debe tener cuidado con el envío de mensajes conflictivos alcliente (por ejemplo, prometer más de lo que puede entregarse de manera razonable en elplazo previsto, o entregar más de lo que se prometió en un incremento de software y parael siguiente entregar menos).Principio 2. Debe ensamblarse y probarse el paquete completo que se entregará.Debe ensamblarse en un CD-ROM u otro medio (incluso descargas desde web) todo el software ejecutable, archivos de datos de apoyo, documentos de ayuda y otra información releAsegúrese de que su cliente sabe loque puede esperar antes de que seentregue un incremento de software.De otra manera, puede apostar aque el cliente espera más de lo queusted le dará.CONSEJO04Pressman(081-100).indd 96 26/1/10 17:32:01CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 97vante, para después hacer una prueba beta exhaustiva con usuarios reales. Todos los scriptsde instalación y otras características de operación deben ejecutarse por completo en tantasconfiguraciones diferentes de cómputo como sea posible (por ejemplo, hardware, sistemasoperativos, equipos periféricos, configuraciones de red, etcétera).Principio 3. Antes de entregar el software, debe establecerse un régimen de apoyo.Un usuario final espera respuesta e información exacta cuando surja una pregunta o problema. Si el apoyo es ad hoc, o, peor aún, no existe, el cliente quedará insatisfecho de inmediato. El apoyo debe planearse, los materiales respectivos deben prepararse y los mecanismos apropiados de registro deben establecerse a fin de que el equipo de software realiceuna evaluación categórica de las clases de apoyo solicitado.Principio 4. Se deben proporcionar a los usuarios finales materiales de aprendizajeapropiados. El equipo de software entrega algo más que el software en sí. Deben desarrollarse materiales de capacitación apropiados (si se requirieran); es necesario proveer lineamientos para solución de problemas y, cuando sea necesario, debe publicarse “lo que esdiferente en este incremento de software”.8Principio 5. El software defectuoso debe corregirse primero y después entregarse.Cuando el tiempo apremia, algunas organizaciones de software entregan incrementos debaja calidad con la advertencia de que los errores “se corregirán en la siguiente entrega”.Esto es un error. Hay un adagio en el negocio del software que dice así: “Los clientes olvidarán pronto que entregaste un producto de alta calidad, pero nunca olvidarán los problemas que les causó un producto de mala calidad. El software se los recuerda cada día.”El software entregado brinda beneficios al usuario final, pero también da retroalimentaciónútil para el equipo que lo desarrolló. Cuando el incremento se libere, debe invitarse a los usuarios finales a que comenten acerca de características y funciones, facilidad de uso, confiabilidady cualesquiera otras características. 4.4 RESUMENLa práctica de la ingeniería de software incluye principios, conceptos, métodos y herramientasque los ingenieros de software aplican en todo el proceso de desarrollo. Todo proyecto de ingeniería de software es diferente. No obstante, existe un conjunto de principios generales que seaplican al proceso como un todo y a cada actividad estructural, sin importar cuál sea el proyectoo el producto.Existe un conjunto de principios fundamentales que ayudan en la aplicación de un procesode software significativo y en la ejecución de métodos de ingeniería de software eficaz. En elnivel del proceso, los principios fundamentales establecen un fundamento filosófico que guía alequipo de software cuando avanza por el proceso del software. En el nivel de la práctica, losprincipios fundamentales establecen un conjunto de valores y reglas que sirven como guía alanalizar el diseño de un problema y su solución, al implementar ésta y al someterla a pruebapara, finalmente, desplegar el software en la comunidad del usuario.Los principios de comunicación se centran en la necesidad de reducir el ruido y mejorar elancho de banda durante la conversación entre el desarrollador y el cliente. Ambas partes debencolaborar a fin de lograr la mejor comunicación.Los principios de planeación establecen lineamientos para elaborar el mejor mapa del proceso hacia un sistema o producto terminado. El plan puede diseñarse sólo para un incremento8 Durante la actividad de comunicación, el equipo de software debe determinar los tipos de materiales de ayudaque quiere el usuario.04Pressman(081-100).indd 97 26/1/10 17:32:0198 PARTE DOS MODELADOdel software, o para todo el proyecto. Sin que esto importe, debe definir lo que se hará, quién lohará y cuándo se terminará el trabajo.El modelado incluye tanto el análisis como el diseño, y describe representaciones cada vezmás detalladas del software. El objetivo de los modelos es afirmar el entendimiento del trabajoque se va a hacer y dar una guía técnica a quienes implementarán el software. Los principios demodelado dan fundamento a los métodos y notación que se utilizan para crear representacionesdel software.La construcción incorpora un ciclo de codificación y pruebas en el que se genera códigofuente para cierto componente y es sometido a pruebas. Los principios de codificación definenlas acciones generales que deben tener lugar antes de que se escriba el código, mientras se escribe y una vez terminado. Aunque hay muchos principios para las pruebas, sólo uno predomina:la prueba es el proceso que lleva a ejecutar un programa con objeto de encontrar un error.El despliegue ocurre cuando se presenta al cliente un incremento de software, e incluye laentrega, apoyo y retroalimentación. Los principios clave para la entrega consideran la administración de las expectativas del cliente y darle información de apoyo adecuada sobre el software.El apoyo demanda preparación anticipada. La retroalimentación permite al cliente sugerir cambios que tengan valor para el negocio y que brinden al desarrollador información para el cicloiterativo siguiente de ingeniería de software. PROBLEMAS Y PUNTOS POR EVALUAR4.1. Toda vez que la búsqueda de la calidad reclama recursos y tiempo, ¿es posible ser ágil y centrarse enella?4.2. De los ocho principios fundamentales que guían el proceso (lo que se estudió en la sección 4.2.1), ¿cuálcree que sea el más importante?4.3. Describa con sus propias palabras el concepto de separación de entidades.4.4. Un principio de comunicación importante establece que hay que “prepararse antes de comunicarse”.¿Cómo debe manifestarse esta preparación en los primeros trabajos que se hacen? ¿Qué productos del trabajo son resultado de la preparación temprana?4.5. Haga algunas investigaciones acerca de cómo “facilitar” la actividad de comunicación (use las referencias que se dan u otras distintas) y prepare algunos lineamientos que se centren en la facilitación.4.6. ¿En qué difiere la comunicación ágil de la comunicación tradicional de la ingeniería de software? ¿Enqué se parecen?4.7. ¿Por qué es necesario “avanzar”?4.8. Investigue sobre la “negociación” para la actividad de comunicación y prepare algunos lineamientosque se centren sólo en ella.4.9. Describa lo que significa granularidad en el contexto de la programación de actividades de un proyecto.4.10. ¿Por qué son importantes los modelos en el trabajo de ingeniería de software? ¿Siempre son necesarios? ¿Hay calificadores para la respuesta que se dio sobre esta necesidad?4.11. ¿Cuáles son los tres “dominios” considerados durante el modelado de requerimientos?4.12. Trate de agregar un principio adicional a los que se mencionan en la sección 4.3.4 para la codificación.4.13. ¿Qué es una prueba exitosa?4.14. Diga si está de acuerdo o en desacuerdo con el enunciado siguiente: “Como entregamos incrementosmúltiples al cliente, no debiéramos preocuparnos por la calidad en los primeros incrementos; en las iteraciones posteriores podemos corregir los problemas. Explique su respuesta.4.15. ¿Por qué es importante la retroalimentación para el equipo de software?04Pressman(081-100).indd 98 26/1/10 17:32:01CAPÍTULO 4 PRINCIPIOS QUE GUÍAN LA PRÁCTICA 99 LECTURAS Y FUENTES DE INFORMACIÓN ADICIONALESLa comunicación con el cliente es una actividad de importancia crítica en la ingeniería de software, peropocos de sus practicantes dedican tiempo a leer sobre ella. Withall (Software Requirements Patterns, MicrosoftPress, 2007) presenta varios patrones útiles que analizan problemas en la comunicación. Sutliff (User-CentredRequirements Engineering, Springer, 2002) se centra mucho en los retos relacionados con la comunicación.Los libros de Weigers (Software Requierements, 2a. ed., Microsoft Press, 2003), Pardee (To Satisfy and DelightYour Customer, Dorset House, 1996) y Karten [Kar94] analizan a profundidad los métodos para tener unainteracción eficaz con el cliente. Aunque su libro no se centra en el software, Hooks y Farry (Customer Centered Products, American Management Association, 2000) presentan lineamientos generales útiles para lacomunicación con los clientes. Young (Effective Requirements Practices, Addison-Wesley, 2001) pone el énfasis en un “equipo conjunto” de clientes y desarrolladores que recaben los requerimientos en colaboración.Somerville y Kotonya (Requirements Engineering: Processes and Techniques, Wiley, 1998) analizan el conceptode “provocación” y las técnicas y otros requerimientos de los principios de ingeniería.Los conceptos y principios de la comunicación y planeación son estudiados en muchos libros de administración de proyectos. Entre los más útiles se encuentran los de Bechtold (Essentials of Software ProjectManagement, 2a. ed., Management Concepts, 2007), Wysocki (Effective Project Management: Traditional, Adaptive, Extreme, 4a. ed., Wiley, 2006), Leach (Lean Project Management: Eight Principles for Success, BookSurgePublishing, 2006) Hughes (Software Project Management, McGraw-Hill, 2005) y Stellman y Greene (AppliedSoftware Project Management, O’Reilly Media, Inc., 2005).Davis [Dav95] hizo una compilación excelente de referencias sobre principios de la ingeniería de software. Además, virtualmente todo libro al respecto contiene un análisis útil de los conceptos y principios paraanálisis, diseño y prueba. Entre los más utilizados (además de éste, claro) se encuentran los siguientes:Abran, A., y J. Moore, SWEBOK: Guide to the Software Engineering Body of Knowledge, IEEE, 2002.Christensen, M., y R. Thayer, A Project Manager’s Guide to Software Engineering Best Practices, IEEE-CSPress (Wiley), 2002.Jalote, P., An Integrated Approach to Software Engineering, Springer, 2006.Pfleeger, S., Software Engineering: Theory and Practice, 3a. ed., Prentice-Hall, 2005.Schach, S., Object- Oriented and Classical Software Engineering, McGraw-Hill, 7a. ed., 2006.Sommerville, I., Software Engineering, 8a. ed., Addison-Wesley, 2006Estos libros también presentan análisis detallados sobre los principios de modelado y construcción.Los principios de modelado se estudian en muchos libros dedicados al análisis de requerimientos o diseñode software. Los libros de Lieberman (The Art of Software Modeling, Auerbach, 2007), Rosenberg y Stephens(Use Case Driven Object Modeling with UML: Theory and Practice, Apress, 2007), Roques (UML in Practice, Wiley,2004) y Penker y Eriksson (Business Modeling with UML: Business Patterns at Work, Wiley, 2001) analizan losprincipios y métodos de modelado.Todo ingeniero de software que trate de hacer diseño está obligado a leer el texto de Norman (The Designof Everyday Things, Currency/Doubleday, 1990). Winograd y sus colegas (Bringing Design to Software, Addison-Wesley, 1996) editaron una excelente colección de ensayos sobre aspectos prácticos del diseño de software. Constantine y Lockwood (Software for Use, Addison-Wesley, 1999) presenta los conceptos asociadoscon el “diseño centrado en el usuario”. Tognazzini (Tog on Software Design, Addison-Wesley, 1995) presentauna reflexión filosófica útil sobre la naturaleza del diseño y el efecto que tienen las decisiones sobre la calidady la capacidad del equipo para producir software que agregue mucho valor para su cliente. Stahl y sus colegas (Model-Driven Software Development: Technology, Engineering, Wiley, 2006) estudian los principios deldesarrollo determinado por el modelo.Son cientos los libros que abordan uno o más elementos de la actividad de construcción. Kernighan yPlauger [Ker78] escribieron un texto clásico sobre el estilo de programación, McConell [McC93] presenta lineamientos prácticos para la construcción de software, Bentley [Ben99] sugiere una amplia variedad deperlas de la programación, Knuth [Knu99] escribió una serie clásica de tres volúmenes acerca del artede programar y Hunt [Hun99] sugiere lineamientos pragmáticos para la programación.Myers y sus colegas (The Art of Software Testing, 2a. ed., Wiley, 2004) desarrollaron una revisión importantede su texto clásico y muchos principios importantes para la realización de pruebas. Los libros de Perry (Effective Methods for Software Testing, 3a. ed., Wiley 2006), Whittaker (How to Break Software, Addison-Wesley,2002), Kaner y sus colegas (Lessons Learned in Software Testing, Wiley, 2001) y Marick (The Craft of SoftwareTesting, Prentice-Hall, 1997) presentan por separado conceptos y principios importantes para hacer pruebas,así como muchas guías prácticas.04Pressman(081-100).indd 99 26/1/10 17:32:01100 PARTE DOS MODELADOEn internet existe una amplia variedad de fuentes de información sobre la práctica de ingeniería de software. En el sitio web del libro se encuentra una lista actualizada de referencias en la Red Mundial que sonrelevantes para la ingeniería de software: www.mhe.com/engcs/compsci/pressman/professional/olc/ser.htm04Pressman(081-100).indd 100 26/1/10 17:32:02101CAPÍTULO5 COMPRENSIÓN DELOS REQUERIMIENTOSC ONCEPTOS CLAVEadministración de losrequerimientos . . . . . . . . . . 105casos de uso . . . . . . . . . . . . 113colaboración . . . . . . . . . . . . 107concepción . . . . . . . . . . . . . 102despliegue de la funciónde calidad. . . . . . . . . . . . . . 111elaboración. . . . . . . . . . . . . 117especificación . . . . . . . . . . . 104indagación . . . . . . . . . . . . . 103indagación de losrequerimientos . . . . . . . . . . 108ingeniería derequerimientos . . . . . . . . . . 102modelo del análisis . . . . . . . 117negociación. . . . . . . . . . . . . 121participantes. . . . . . . . . . . . 106patrones de análisis . . . . . . 120productos del trabajo. . . . . . 112puntos de vista. . . . . . . . . . 107validación. . . . . . . . . . . . . . 105validación de losrequerimientos . . . . . . . . . . 122¿Qué es? Antes de comenzar cualquier trabajo técnico es una buena idea aplicar unconjunto de tareas de ingeniería a los requerimientos. Éstas llevarán a la comprensión decuál será el efecto que tendrá el software en el negocio,qué es lo que quiere el cliente y cómo interactuarán losusuarios finales con el software.¿Quién lo hace? Los ingenieros de software (que en elmundo de las tecnologías de información a veces son llamados ingenieros de sistemas o analistas) y todos losdemás participantes del proyecto (gerentes, clientes yusuarios) intervienen en la ingeniería de requerimientos.¿Por qué es importante? Diseñar y construir un elegante programa de cómputo que resuelva el problema equivocado no satisface las necesidades de nadie. Por eso esimportante entender lo que el cliente desea antes decomenzar a diseñar y a construir un sistema basado encomputadora.¿Cuáles son los pasos? La ingeniería de requerimientoscomienza con la concepción, tarea que define el alcance yla naturaleza del problema que se va a resolver. Va seguida de la indagación, labor que ayuda a los participantesa definir lo que se requiere. Después sigue la elaboración,donde se refinan y modifican los requerimientos básicos.Cuando los participantes definen el problema, tiene lugaruna negociación: ¿cuáles son las prioridades, qué es loesencial, cuándo se requiere? Por último, se especifica elproblema de algún modo y luego se revisa o valida paragarantizar que hay coincidencia entre la comprensión queusted tiene del problema y la que tienen los participantes.¿Cuál es el producto final? El objetivo de los requerimientos de ingeniería es proporcionar a todas las partesun entendimiento escrito del problema. Esto se logra pormedio de varios productos del trabajo: escenarios de uso,listas de funciones y de características, modelos de requerimientos o especificaciones.¿Cómo me aseguro de que lo hice bien? Se revisancon los participantes los productos del trabajo de la ingeniería de requerimientos a fin de asegurar que lo que seaprendió es lo que ellos quieren decir en realidad. Aquícabe una advertencia: las cosas cambiarán aun despuésde que todas las partes estén de acuerdo, y seguirán cambiando durante todo el proyecto.U N AMIRADARÁPIDAEntender los requerimientos de un problema es una de las tareas más difíciles que enfrentael ingeniero de software. Cuando se piensa por primera vez, no parece tan difícil desarrollar un entendimiento claro de los requerimientos. Después de todo, ¿acaso no sabe elcliente lo que se necesita? ¿No deberían tener los usuarios finales una buena comprensión delas características y funciones que le darán un beneficio? Sorprendentemente, en muchas instancias la respuesta a estas preguntas es “no”. E incluso si los clientes y los usuarios finalesexplican sus necesidades, éstas cambiarán mientras se desarrolla el proyecto.En el prólogo a un libro escrito por Ralph Young [You01] sobre las prácticas eficaces respectode los requerimientos, escribí lo siguiente:Es la peor de las pesadillas. Un cliente entra a la oficina, toma asiento, lo mira a uno fijamente a losojos y dice: “Sé que cree que entiende lo que digo, pero lo que usted no entiende es que lo que digono es lo que quiero decir.” Invariablemente, esto pasa cuando ya está avanzado el proyecto, despuésde que se han hecho compromisos con los plazos de entrega, que hay reputaciones en juego y muchodinero invertido.Todos los que hemos trabajado en el negocio de los sistemas y del software durante algunos añoshemos vivido la pesadilla descrita, pero pocos hemos aprendido a escapar. Batallamos cuando tratamos de obtener los requerimientos de nuestros clientes. Tenemos problemas para entender la información que obtenemos. Es frecuente que registremos los requerimientos de manera desorganizada yque dediquemos muy poco tiempo a verificar lo que registramos. Dejamos que el cambio nos controleen lugar de establecer mecanismos para controlarlo a él. En pocas palabras, fallamos en establecer unfundamento sólido para el sistema o software. Cada uno de los problemas es difícil. Cuando se combinan, el panorama es atemorizador aun para los gerentes y profesionales más experimentados. Perohay solución.05Pressman(101-125).indd 101 21/1/10 11:00:18102 PARTE DOS MODELADOEs razonable afirmar que las técnicas que se estudiarán en este capítulo no son una “solución” verdadera para los retos que se mencionaron, pero sí proveen de un enfoque sólido paraenfrentarlos. 5.1 I NGENIERÍA DE REQUERIMIENTOSEl diseño y construcción de software de computadora es difícil, creativo y sencillamente divertido. En realidad, elaborar software es tan atractivo que muchos desarrolladores de softwarequieren ir directo a él antes de haber tenido el entendimiento claro de lo que se necesita. Argumentan que las cosas se aclararán a medida que lo elaboren, que los participantes en el proyectopodrán comprender sus necesidades sólo después de estudiar las primeras iteraciones del software, que las cosas cambian tan rápido que cualquier intento de entender los requerimientosen detalle es una pérdida de tiempo, que las utilidades salen de la producción de un programaque funcione y que todo lo demás es secundario. Lo que hace que estos argumentos sean tanseductores es que tienen algunos elementos de verdad.1 Pero todos son erróneos y pueden llevarun proyecto de software al fracaso.El espectro amplio de tareas y técnicas que llevan a entender los requerimientos se denominaingeniería de requerimientos. Desde la perspectiva del proceso del software, la ingeniería de requerimientos es una de las acciones importantes de la ingeniería de software que comienzadurante la actividad de comunicación y continúa en la de modelado. Debe adaptarse a las necesidades del proceso, del proyecto, del producto y de las personas que hacen el trabajo.La ingeniería de requerimientos tiende un puente para el diseño y la construcción. Pero,¿dónde se origina el puente? Podría argumentarse que principia en los pies de los participantesen el proyecto (por ejemplo, gerentes, clientes y usuarios), donde se definen las necesidades delnegocio, se describen los escenarios de uso, se delinean las funciones y características y seidentifican las restricciones del proyecto. Otros tal vez sugieran que empieza con una definiciónmás amplia del sistema, donde el software no es más que un componente del dominio del sistema mayor. Pero sin importar el punto de arranque, el recorrido por el puente lo lleva a unomuy alto sobre el proyecto, lo que le permite examinar el contexto del trabajo de software quedebe realizarse; las necesidades específicas que deben abordar el diseño y la construcción; lasprioridades que guían el orden en el que se efectúa el trabajo, y la información, las funciones ylos comportamientos que tendrán un profundo efecto en el diseño resultante.La ingeniería de requerimientos proporciona el mecanismo apropiado para entender lo quedesea el cliente, analizar las necesidades, evaluar la factibilidad, negociar una solución razonable, especificar la solución sin ambigüedades, validar la especificación y administrar los requerimientos a medida de que se transforman en un sistema funcional [Tha97]. Incluye siete tareasdiferentes: concepción, indagación, elaboración, negociación, especificación, validación y administración. Es importante notar que algunas de estas tareas ocurren en paralelo y que todasse adaptan a las necesidades del proyecto.Concepción. ¿Cómo inicia un proyecto de software? ¿Existe un solo evento que se convierteen el catalizador de un nuevo sistema o producto basado en computadora o la necesidad evoluciona en el tiempo? No hay respuestas definitivas a estas preguntas. En ciertos casos, unaconversación casual es todo lo que se necesita para desencadenar un trabajo grande de ingeniería de software. Pero en general, la mayor parte de proyectos comienzan cuando se identificauna necesidad del negocio o se descubre un nuevo mercado o servicio potencial. Los partici1 Esto es cierto en particular para los proyectos pequeños (menos de un mes) y muy pequeños, que requieren relativamente poco esfuerzo de software sencillo. A medida que el software crece en tamaño y complejidad, estosargumentos comienzan a ser falsos.Cita:“La parte más difícil al construirun sistema de software es decidir qué construir. Ninguna partedel trabajo invalida tanto al sistema resultante si ésta se hacemal. Nada es más difícil decorregir después.”Fred BrooksPUNTOCLAVELa ingeniería de requerimientosestablece una base sólida para eldiseño y la construcción. Sin ésta, elsoftware resultante tiene altaprobabilidad de no satisfacer lasnecesidades del cliente.Cita:“Las semillas de los desastresenormes del software por logeneral se vislumbran en lostres primeros meses del iniciodel proyecto.”Coper JonesEspere hacer un poco de diseño alrecabar los requerimientos, y unpoco de requerimientos durante eltrabajo de diseño.CONSEJO05Pressman(101-125).indd 102 21/1/10 11:00:19CAPÍTULO 5 COMPRENSIÓN DE LOS REQUERIMIENTOS 103pantes de la comunidad del negocio (por ejemplo, los directivos, personal de mercadotecnia,gerentes de producto, etc.) definen un caso de negocios para la idea, tratan de identificar el ritmoy profundidad del mercado, hacen un análisis de gran visión de la factibilidad e identifican unadescripción funcional del alcance del proyecto. Toda esta información está sujeta a cambio, peroes suficiente para desencadenar análisis con la organización de ingeniería de software.2En la concepción del proyecto,3 se establece el entendimiento básico del problema, las personas que quieren una solución, la naturaleza de la solución que se desea, así como la eficaciade la comunicación y colaboración preliminares entre los otros participantes y el equipo desoftware.Indagación. En verdad que parece muy simple: preguntar al cliente, a los usuarios y a otraspersonas cuáles son los objetivos para el sistema o producto, qué es lo que va a lograrse, cómose ajusta el sistema o producto a las necesidades del negocio y, finalmente, cómo va a usarse elsistema o producto en las operaciones cotidianas. Pero no es simple: es muy difícil.Christel y Kang [Cri92] identificaron cierto número de problemas que se encuentran cuandoocurre la indagación:• Problemas de alcance. La frontera de los sistemas está mal definida o los clientes ousuarios finales especifican detalles técnicos innecesarios que confunden, más que clarifican, los objetivos generales del sistema.• Problemas de entendimiento. Los clientes o usuarios no están completamenteseguros de lo que se necesita, comprenden mal las capacidades y limitaciones de suambiente de computación, no entienden todo el dominio del problema, tienenproblemas para comunicar las necesidades al ingeniero de sistemas, omiten informaciónque creen que es “obvia”, especifican requerimientos que están en conflicto con lasnecesidades de otros clientes o usuarios, o solicitan requerimientos ambiguos o que nopueden someterse a prueba.• Problemas de volatilidad. Los requerimientos cambian con el tiempo.Para superar estos problemas, debe enfocarse la obtención de requerimientos en forma organizada.Elaboración. La información obtenida del cliente durante la concepción e indagación se expande y refina durante la elaboración. Esta tarea se centra en desarrollar un modelo refinado delos requerimientos (véanse los capítulos 6 y 7) que identifique distintos aspectos de la funcióndel software, su comportamiento e información.La elaboración está motivada por la creación y mejora de escenarios de usuario que describan cómo interactuará el usuario final (y otros actores) con el sistema. Cada escenario de usuario se enuncia con sintaxis apropiada para extraer clases de análisis, que son entidades deldominio del negocio visibles para el usuario final. Se definen los atributos de cada clase deanálisis y se identifican los servicios4 que requiere cada una de ellas. Se identifican las relacionesy colaboración entre clases, y se producen varios diagramas adicionales.Negociación. No es raro que los clientes y usuarios pidan más de lo que puede lograrse dadolo limitado de los recursos del negocio. También es relativamente común que distintos clientes2 Si va a desarrollarse un sistema basado en computadora, los análisis comienzan en el contexto de un procesode ingeniería de sistemas. Para más detalles de la ingeniería de sistemas, visite el sitio web de esta obra.3 Recuerde que el proceso unificado (véase el capítulo 2) define una “fase de concepción” más amplia que incluyelas fases de concepción, indagación y elaboración, que son estudiadas en dicho capítulo.4 Un servicio manipula los datos agrupados por clase. También se utilizan los términos operación y método. Si noestá familiarizado con conceptos de la orientación a objetos, consulte el apéndice 2, en el que se presenta unaintroducción básica.La elaboración es algo bueno, perohay que saber cuándo detenerse. Laclave es describir el problema enforma que establezca una base firmepara el diseño. Si se trabaja más alláde este punto, se está haciendodiseño.CONSEJO¿Por qué es difícil llegaral entendimiento clarode lo que quiere elcliente??05Pressman(101-125).indd 103 21/1/10 11:00:19104 PARTE DOS MODELADOo usuarios propongan requerimientos conflictivos con el argumento de que su versión es “esencial para nuestras necesidades especiales”.Estos conflictos deben reconciliarse por medio de un proceso de negociación. Se pide a clientes, usuarios y otros participantes que ordenen sus requerimientos según su prioridad y quedespués analicen los conflictos. Con el empleo de un enfoque iterativo que da prioridad a losrequerimientos, se evalúa su costo y riesgo, y se enfrentan los conflictos internos; algunos requerimientos se eliminan, se combinan o se modifican de modo que cada parte logre ciertogrado de satisfacción.Especificación. En el contexto de los sistemas basados en computadora (y software), el término especificación tiene diferentes significados para distintas personas. Una especificaciónpuede ser un documento escrito, un conjunto de modelos gráficos, un modelo matemático formal, un conjunto de escenarios de uso, un prototipo o cualquier combinación de éstos.Algunos sugieren que para una especificación debe desarrollarse y utilizarse una “plantillaestándar” [Som97], con el argumento de que esto conduce a requerimientos presentados enforma consistente y por ello más comprensible. Sin embargo, en ocasiones es necesario serflexible cuando se desarrolla una especificación. Para sistemas grandes, el mejor enfoque puedeser un documento escrito que combine descripciones en un lenguaje natural con modelos gráficos. No obstante, para productos o sistemas pequeños que residan en ambientes bien entendidos, quizá todo lo que se requiera sea escenarios de uso.PUNTOCLAVELa formalidad y el formato de unaespecificación varían con el tamaño ycomplejidad del software que se va aconstruir.Una especificación de requerimientos de software (ERS) esun documento que se crea cuando debe especificarse unadescripción detallada de todos los aspectos del software que se va aelaborar, antes de que el proyecto comience. Es importante notar queuna ERS formal no siempre está en forma escrita. En realidad, haymuchas circunstancias en las que el esfuerzo dedicado a la ERS estaría mejor aprovechado en otras actividades de la ingeniería de software. Sin embargo, se justifica la ERS cuando el software va a serdesarrollado por una tercera parte, cuando la falta de una especificación crearía problemas severos al negocio, si un sistema es complejoen extremo o si se trata de un negocio de importancia crítica.Karl Wiegers [Wie03], de la empresa Process Impact Inc., desarrolló un formato útil (disponible en www.processimpact.com/process_assets/srs_template.doc) que sirve como guía paraaquellos que deben crear una ERS completa. Su contenido normal esel siguiente:Tabla de contenidoRevisión de la historia1. Introducción1.1 Propósito1.2 Convenciones del documento1.3 Audiencia objetivo y sugerencias de lectura1.4 Alcance del proyecto1.5 Referencias2. Descripción general2.1 Perspectiva del producto2.2 Características del producto2.3 Clases y características del usuario2.4 Ambiente de operación2.5 Restricciones de diseño e implementación2.6 Documentación para el usuario2.7 Suposiciones y dependencias3. Características del sistema3.1 Característica 1 del sistema3.2 Característica 2 del sistema (y así sucesivamente)4. Requerimientos de la interfaz externa4.1 Interfaces de usuario4.2 Interfaces del hardware4.3 Interfaces del software4.4 Interfaces de las comunicaciones5. Otros requerimientos no funcionales5.1 Requerimientos de desempeño5.2 Requerimientos de seguridad5.3 Requerimientos de estabilidad5.4 Atributos de calidad del software6. Otros requerimientosApéndice A: GlosarioApéndice B: Modelos de análisisApéndice C: Lista de conceptosPuede obtenerse una descripción detallada de cada ERS si se descarga el formato desde la URL mencionada antes.INFORMACIÓNFormato de especificación de requerimientos de softwareEn una negociación eficaz no debehaber ganador ni perdedor. Amboslados ganan porque un “trato” conel que ambas partes pueden vivir esalgo sólido.CONSEJO05Pressman(101-125).indd 104 21/1/10 11:00:20CAPÍTULO 5 COMPRENSIÓN DE LOS REQUERIMIENTOS 105Validación. La calidad de los productos del trabajo que se generan como consecuencia de laingeniería de los requerimientos se evalúa durante el paso de validación. La validación de losrequerimientos analiza la especificación5 a fin de garantizar que todos ellos han sido enunciados sin ambigüedades; que se detectaron y corrigieron las inconsistencias, las omisiones y loserrores, y que los productos del trabajo se presentan conforme a los estándares establecidos para el proceso, el proyecto y el producto.El mecanismo principal de validación de los requerimientos es la revisión técnica (véase elcapítulo 15). El equipo de revisión que los valida incluye ingenieros de software, clientes, usuarios y otros participantes, que analizan la especificación en busca de errores de contenido o deinterpretación, de aspectos en los que tal vez se requiera hacer aclaraciones, falta de información, inconsistencias (problema notable cuando se hace la ingeniería de productos o sistemasgrandes) y requerimientos en conflicto o irreales (no asequibles).5 Recuerde que la naturaleza de la especificación variará con cada proyecto. En ciertos casos, la “especificación”no es más que un conjunto de escenarios de usuario. En otros, la especificación tal vez sea un documento quecontiene escenarios, modelos y descripciones escritas.6 La administración formal de los requerimientos sólo se practica para proyectos grandes que tienen cientosde requerimientos identificables. Para proyectos pequeños, esta actividad tiene considerablemente menos formalidad.Un aspecto clave durante lavalidación de los requerimientos esla consistencia. Utilice el modelo deanálisis para asegurar que losrequerimientos se han enunciado demanera consistente.CONSEJOLista de verificación para validarrequerimientosCon frecuencia es útil analizar cada requerimiento encomparación con preguntas de verificación. A continuación se presentan algunas:• ¿Los requerimientos están enunciados con claridad? ¿Podrían interpretarse mal?• ¿Está identificada la fuente del requerimiento (por ejemplo, una persona, reglamento o documento)? ¿Se ha estudiado el planteamientofinal del requerimiento en comparación con la fuente original?• ¿El requerimiento está acotado en términos cuantitativos?• ¿Qué otros requerimientos se relacionan con éste? ¿Están comparados con claridad por medio de una matriz de referencia cruzadau otro mecanismo?• ¿El requerimiento viola algunas restricciones del dominio?• ¿Puede someterse a prueba el requerimiento? Si es así, ¿es posibleespecificar las pruebas (en ocasiones se denominan criterios devalidación) para ensayar el requerimiento?• ¿Puede rastrearse el requerimiento hasta cualquier modelo del sistema que se haya creado?• ¿Es posible seguir el requerimiento hasta los objetivos del sistema oproducto?• ¿La especificación está estructurada en forma que lleva a entenderlo con facilidad, con referencias y traducción fáciles a productosdel trabajo más técnicos?• ¿Se ha creado un índice para la especificación?• ¿Están enunciadas con claridad las asociaciones de los requerimientos con las características de rendimiento, comportamiento yoperación? ¿Cuáles requerimientos parecen ser implícitos?INFORMACIÓNAdministración de los requerimientos. Los requerimientos para sistemas basados encomputadora cambian, y el deseo de modificarlos persiste durante toda la vida del sistema. Laadministración de los requerimientos es el conjunto de actividades que ayudan al equipodel proyecto a identificar, controlar y dar seguimiento a los requerimientos y a sus cambiosen cualquier momento del desarrollo del proyecto.6 Muchas de estas actividades son idénticasa las técnicas de administración de la configuración del software (TAS) que se estudian en elcapítulo 22.05Pressman(101-125).indd 105 21/1/10 11:00:20106 PARTE DOS MODELADO 5.2 ESTABLECER LAS BASESEn el caso ideal, los participantes e ingenieros de software trabajan juntos en el mismo equipo.8En esas condiciones, la ingeniería de requerimientos tan sólo consiste en sostener conversaciones significativas con colegas que sean miembros bien conocidos del equipo. Pero es frecuenteque en la realidad esto sea muy diferente.Los clientes o usuarios finales tal vez se encuentren en ciudades o países diferentes, quizásólo tengan una idea vaga de lo que se requiere, puede ser que tengan opiniones en conflictosobre el sistema que se va a elaborar, que posean un conocimiento técnico limitado o que dispongan de poco tiempo para interactuar con el ingeniero que recabará los requerimientos.Ninguna de estas posibilidades es deseable, pero todas son muy comunes y es frecuente verseforzado a trabajar con las restricciones impuestas por esta situación.En las secciones que siguen se estudian las etapas requeridas para establecer las bases quepermiten entender los requerimientos de software a fin de que el proyecto comience en formatal que se mantenga avanzando hacia una solución exitosa.5.2.1 Identificación de los participantesSommerville y Sawyer [Som97] definen participante como “cualquier persona que se beneficieen forma directa o indirecta del sistema en desarrollo”. Ya se identificaron los candidatos habituales: gerentes de operaciones del negocio, gerentes de producto, personal de mercadotecnia,clientes internos y externos, usuarios finales, consultores, ingenieros de producto, ingenieros desoftware e ingenieros de apoyo y mantenimiento, entre otros. Cada participante tiene un puntode vista diferente respecto del sistema, obtiene distintos beneficios cuando éste se desarrollacon éxito y corre distintos riesgos si fracasa el esfuerzo de construcción.7 Las herramientas mencionadas aquí no son obligatorias sino una muestra de las que hay en esta categoría. En lamayoría de casos, los nombres de las herramientas son marcas registradas por sus respectivos desarrolladores.8 Este enfoque es ampliamente recomendable para proyectos que adoptan la filosofía de desarrollo de software ágil.Objetivo: Las herramientas de la ingeniería de los requerimientos ayudan a reunir éstos, a modelarlos, administrarlos y validarlos.Mecánica: La mecánica de las herramientas varía. En general, éstaselaboran varios modelos gráficos (por ejemplo, UML) que ilustran losaspectos de información, función y comportamiento de un sistema.Estos modelos constituyen la base de todas las demás actividades delproceso de software.Herramientas representativas:7En el sitio de Volere Requirements, en www.volere.co.uk/tools.htm, se encuentra una lista razonablemente amplia (y actualizada)de herramientas para la ingeniería de requerimientos. En los capítulos6 y 7 se estudian las herramientas que sirven para modelar aquéllos.Las que se mencionan a continuación se centran en su administración.EasyRM, desarrollada por Cybernetic Intelligence GmbH (www.easy-rm.com), construye un diccionario/glosario especialpara proyectos, que contiene descripciones y atributos detalladosde los requerimientos.Rational RequisitePro, elaborada por Rational Software (www-306.ibm.com/software/awdtools/reqpro/), permite a losusuarios construir una base de datos de requerimientos, representar relaciones entre ellos y organizarlos, indicar su prioridad yrastrearlos.En el sitio de Volere ya mencionado, se encuentran muchas herramientas adicionales para administrar requerimientos, así como enla dirección www.jiludwig.com/Requirements_Management_Tools.htmlHERRAMIENTAS DE SOFTWAREIngeniería de requerimientosPUNTOCLAVEUn participante es cualquier personaque tenga interés directo o que sebeneficie del sistema que se va adesarrollar.05Pressman(101-125).indd 106 21/1/10 11:00:20CAPÍTULO 5 COMPRENSIÓN DE LOS REQUERIMIENTOS 107Durante la concepción, debe hacerse la lista de personas que harán aportes cuando se recaben los requerimientos (véase la sección 5.3). La lista inicial crecerá cuando se haga contacto con los participantes porque a cada uno se le hará la pregunta: “¿A quién más piensa que debeconsultarse?”5.2.2 Reconocer los múltiples puntos de vistaDebido a que existen muchos participantes distintos, los requerimientos del sistema se explorarán desde muchos puntos de vista diferentes. Por ejemplo, el grupo de mercadotecnia se interesa en funciones y características que estimularán el mercado potencial, lo que hará que elnuevo sistema sea fácil de vender. Los gerentes del negocio tienen interés en un conjunto decaracterísticas para que se elabore dentro del presupuesto y que esté listo para ocupar nichosde mercado definidos. Los usuarios finales tal vez quieran características que les resulten familiares y que sean fáciles de aprender y usar. Los ingenieros de software quizá piensen en funciones invisibles para los participantes sin formación técnica, pero que permitan una infraestructura que dé apoyo a funciones y características más vendibles. Los ingenieros de apoyo talvez se centren en la facilidad del software para recibir mantenimiento.Cada uno de estos integrantes (y otros más) aportará información al proceso de ingenieríade los requerimientos. A medida que se recaba información procedente de múltiples puntos devista, los requerimientos que surjan tal vez sean inconsistentes o estén en conflicto uno conotro. Debe clasificarse toda la información de los participantes (incluso los requerimientos inconsistentes y conflictivos) en forma que permita a quienes toman las decisiones escoger parael sistema un conjunto de requerimientos que tenga coherencia interna.5.2.3 Trabajar hacia la colaboraciónSi en un proyecto de software hay involucrados cinco participantes, tal vez se tengan cinco (omás) diferentes opiniones acerca del conjunto apropiado de requerimientos. En los primeroscapítulos se mencionó que, para obtener un sistema exitoso, los clientes (y otros participantes)debían colaborar entre sí (sin pelear por insignificancias) y con los profesionales de la ingenieríade software. Pero, ¿cómo se llega a esta colaboración?El trabajo del ingeniero de requerimientos es identificar las áreas de interés común (por ejemplo, requerimientos en los que todos los participantes estén de acuerdo) y las de conflicto o incongruencia (por ejemplo, requerimientos que desea un participante, pero que están en conflicto con las necesidades de otro). Es la última categoría la que, por supuesto, representa unreto.Cita:“Ponga a tres participantes enun cuarto y pregúnteles quéclase de sistema quieren. Es probable que escuche cuatro o másopiniones diferentes.”AnónimoLa colaboración no significa necesariamente que todos los requerimientos los defina un comité. En muchos casos, los participantes colaboran con la aportación de su punto de vista respecto de los requerimientos, pero un influyente “campeón del proyecto” (por ejemplo, el directorUna manera de resolver requerimientos conflictivos y, almismo tiempo, mejorar la comprensión de la importanciarelativa de todos, es usar un esquema de “votación” con base en puntos de prioridad. Se da a todos los participantes cierto número depuntos de prioridad que pueden “gastarse” en cualquier número derequerimientos. Se presenta una lista de éstos y cada participanteindica la importancia relativa de cada uno (desde su punto de vista)con la asignación de uno o más puntos de prioridad. Los puntos gastados ya no pueden utilizarse otra vez. Cuando un participante agotasus puntos de prioridad, ya no tiene la posibilidad de hacer algo conlos requerimientos. El total de puntos asignados a cada requerimientopor los participantes da una indicación de la importancia general decada requerimiento.INFORMACIÓNUso de “puntos de prioridad”05Pressman(101-125).indd 107 21/1/10 11:00:21108 PARTE DOS MODELADOdel negocio o un tecnólogo experimentado) toma la decisión final sobre los requerimientos quelo integrarán.5.2.4 Hacer las primeras preguntasLas preguntas que se hacen en la concepción del proyecto deben estar “libres del contexto”[Gau89]. El primer conjunto de ellas se centran en el cliente y en otros participantes, en las metas y beneficios generales. Por ejemplo, tal vez se pregunte:• ¿Quién está detrás de la solicitud de este trabajo?• ¿Quién usará la solución?• ¿Cuál será el beneficio económico de una solución exitosa?• ¿Hay otro origen para la solución que se necesita?Estas preguntas ayudan a identificar a todos los participantes con interés en el software que seva a elaborar. Además, las preguntas identifican el beneficio mensurable de una implementación exitosa y las posibles alternativas para el desarrollo de software personalizado.Las preguntas siguientes permiten entender mejor el problema y hacen que el cliente expresesus percepciones respecto de la solución:• ¿Cuál sería una “buena” salida generada por una solución exitosa?• ¿Qué problemas resolvería esta solución?• ¿Puede mostrar (o describir) el ambiente de negocios en el que se usaría la solución?• ¿Hay aspectos especiales del desempeño o restricciones que afecten el modo en el quese enfoque la solución?Las preguntas finales se centran en la eficacia de la actividad de comunicación en sí. Gausey Weinberg [Gau89] las llaman “metapreguntas” y proponen la siguiente lista (abreviada):• ¿Es usted la persona indicada para responder estas preguntas? ¿Sus respuestas son“oficiales”?• ¿Mis preguntas son relevantes para el problema que se tiene?• ¿Estoy haciendo demasiadas preguntas?• ¿Puede otra persona dar información adicional?• ¿Debería yo preguntarle algo más?Estas preguntas (y otras) ayudarán a “romper el hielo” y a iniciar la comunicación, que es esencial para una indagación exitosa. Pero una reunión de preguntas y respuestas no es un enfoqueque haya tenido un éxito apabullante. En realidad, la sesión de preguntas y respuestas sólo debeusarse para el primer encuentro y luego ser reemplazada por un formato de indagación de requerimientos que combine elementos de solución de problemas, negociación y especificación.En la sección 5.3 se presenta un enfoque de este tipo. 5.3 I NDAGACIÓN DE LOS REQUERIMIENTOSLa indagación de los requerimientos (actividad también llamada recabación de los requerimientos) combina elementos de la solución de problemas, elaboración, negociación y especificación.A fin de estimular un enfoque colaborativo y orientado al equipo, los participantes trabajanjuntos para identificar el problema, proponer elementos de la solución, negociar distintas visiones y especificar un conjunto preliminar de requerimientos para la solución [Zah90].9Cita:“Es mejor conocer algunas preguntas que todas lasrespuestas.”James Thurber¿Cuáles preguntasayudarían a tener unentendimientopreliminar delproblema??Cita:“El que hace una pregunta estonto durante cinco minutos; elque no la hace será tonto parasiempre.”Proverbio chino9 En ocasiones se denomina a este enfoque técnica facilitada de especificación de la aplicación (TFEA).05Pressman(101-125).indd 108 21/1/10 11:00:21CAPÍTULO 5 COMPRENSIÓN DE LOS REQUERIMIENTOS 1095.3.1 Recabación de los requerimientos en forma colaborativaSe han propuesto muchos enfoques distintos para recabar los requerimientos en forma colaborativa. Cada uno utiliza un escenario un poco diferente, pero todos son variantes de los siguientes lineamientos básicos:• Tanto ingenieros de software como otros participantes dirigen o intervienen en lasreuniones.• Se establecen reglas para la preparación y participación.• Se sugiere una agenda con suficiente formalidad para cubrir todos los puntos importantes, pero con la suficiente informalidad para que estimule el libre flujo de ideas.• Un “facilitador” (cliente, desarrollador o participante externo) controla la reunión.• Se utiliza un “mecanismo de definición” (que pueden ser hojas de trabajo, tablas sueltas,etiquetas adhesivas, pizarrón electrónico, grupos de conversación o foro virtual).La meta es identificar el problema, proponer elementos de la solución, negociar distintosenfoques y especificar un conjunto preliminar de requerimientos de la solución en una atmósfera que favorezca el logro de la meta. Para entender mejor el flujo de eventos conforme ocurren, se presenta un escenario breve que bosqueja la secuencia de hechos que llevan a la reunión para obtener requerimientos, a lo que sucede durante ésta y a lo que sigue después deella.Durante la concepción (véase la sección 5.2), hay preguntas y respuestas básicas que establecen el alcance del problema y la percepción general de lo que constituye una solución. Fuerade estas reuniones iniciales, el desarrollador y los clientes escriben una o dos páginas de “solicitud de producto”.Se selecciona un lugar, fecha y hora para la reunión, se escoge un facilitador y se invita aasistir a integrantes del equipo de software y de otras organizaciones participantes. Antes de lafecha de la reunión, se distribuye la solicitud de producto a todos los asistentes.Por ejemplo,10 considere un extracto de una solicitud de producto escrita por una persona demercadotecnia involucrada en el proyecto CasaSegura. Esta persona escribe la siguiente narración sobre la función de seguridad en el hogar que va a ser parte de CasaSegura:Nuestras investigaciones indican que el mercado para los sistemas de administración del hogar crecea razón de 40% anual. La primera función de CasaSegura que llevemos al mercado deberá ser la deseguridad del hogar. La mayoría de la gente está familiarizada con “sistemas de alarma”, por lo queésta deberá ser fácil de vender. La función de seguridad del hogar protegería, o reconocería, varias “situaciones” indeseables,como acceso ilegal, incendio y niveles de monóxido de carbono, entre otros. Emplearía sensores inalámbricos para detectar cada situación. Sería programada por el propietario y telefonearía en formaautomática a una agencia de vigilancia cuando detectara una situación como las descritas.En realidad, durante la reunión para recabar los requerimientos, otros contribuirían a estanarración y se dispondría de mucha más información. Pero aun con ésta habría ambigüedad,sería probable que existieran omisiones y ocurrieran errores. Por ahora bastará la “descripciónfuncional” anterior.Mientras se revisa la solicitud del producto antes de la reunión, se pide a cada asistente queelabore una lista de objetos que sean parte del ambiente que rodeará al sistema, los objetos¿Cuáles son loslineamientos básicospara conducir unareunión a fin de recabarlos requerimientos enforma colaborativa??10 Este ejemplo (con extensiones y variantes) se usa para ilustrar métodos importantes de la ingeniería de softwareen muchos de los capítulos siguientes. Como ejercicio, sería provechoso que el lector realizara su propia reuniónpara recabar requerimientos y que desarrollara un conjunto de listas para ella.Cita:“Dedicamos mucho tiempo —lamayor parte de todo el esfuerzodel proyecto— no a implementar o hacer pruebas, sino atratar de decidir qué construir.”Brian LawrenceWebRefLa solicitud conjunta de desarrollo(SCD) es una técnica popular pararecabar requerimientos. En la direcciónwww.carolla.com/wp-jad.htmse encuentra una buena descripciónde ella.Si un sistema o producto servirá amuchos usuarios, asegúrese de quelos requerimientos se obtengan deuna franja representativa de ellos. Sisólo uno define todos losrequerimientos, el riesgo de noaceptación es elevado.CONSEJO05Pressman(101-125).indd 109 21/1/10 11:00:21110 PARTE DOS MODELADOque producirá éste y los que usará para realizar sus funciones. Además, se solicita a cada asistente que haga otra lista de servicios (procesos o funciones) que manipulen o interactúen conlos objetos. Por último, también se desarrollan listas de restricciones (por ejemplo, costo, tamaño, reglas del negocio, etc.) y criterios de desempeño (como velocidad y exactitud). Se informa a los asistentes que no se espera que las listas sean exhaustivas, pero sí que reflejen lapercepción que cada persona tiene del sistema.Entre los objetos descritos por CasaSegura tal vez estén incluidos el panel de control, detectores de humo, sensores en ventanas y puertas, detectores de movimiento, alarma, un evento(activación de un sensor), una pantalla, una computadora, números telefónicos, una llamadatelefónica, etc. La lista de servicios puede incluir configurar el sistema, preparar la alarma, vigilarlos sensores, marcar el teléfono, programar el panel de control y leer la pantalla (observe que losservicios actúan sobre los objetos). En forma similar, cada asistente desarrollará una lista derestricciones (por ejemplo, el sistema debe reconocer cuando los sensores no estén operando,debe ser amistoso con el usuario, debe tener una interfaz directa con una línea telefónica estándar, etc.) y de criterios de desempeño (un evento en un sensor debe reconocerse antes de unsegundo, debe implementarse un esquema de prioridad de eventos, etcétera).Las listas de objetos pueden adherirse a las paredes del cuarto con el empleo de pliegos depapel grandes o con láminas adhesivas, o escribirse en un tablero. Alternativamente, las listaspodrían plasmarse en un boletín electrónico, sitio web interno o en un ambiente de grupo deconversación para revisarlas antes de la reunión. Lo ideal es que cada entrada de las listas puedamanipularse por separado a fin de combinar las listas o modificar las entradas y agregar otras.En esta etapa, están estrictamente prohibidos las críticas y el debate.Una vez que se presentan las listas individuales acerca de un área temática, el grupo crea unalista, eliminando las entradas redundantes o agregando ideas nuevas que surjan durante elanálisis, pero no se elimina ninguna. Después de crear listas combinadas para todas las áreastemáticas, sigue el análisis, coordinado por el facilitador. La lista combinada se acorta, se alargao se modifica su redacción para que refleje de manera apropiada al producto o sistema que seva a desarrollar. El objetivo es llegar a un consenso sobre la lista de objetos, servicios, restricciones y desempeño del sistema que se va a construir.En muchos casos, un objeto o servicio descrito en la lista requerirá mayores explicaciones.Para lograr esto, los participantes desarrollan miniespecificaciones para las entradas en las listas.11 Cada miniespecificación es una elaboración de un objeto o servicio. Por ejemplo, la correspondiente al objeto Panel de control de CasaSegura sería así:El panel de control es una unidad montada en un muro, sus dimensiones aproximadas son de 9 por 5pulgadas. Tiene conectividad inalámbrica con los sensores y con una PC. La interacción con el usuariotiene lugar por medio de un tablero que contiene 12 teclas. Una pantalla de cristal líquido de 3 por 3pulgadas brinda retroalimentación al usuario. El software hace anuncios interactivos, como eco yfunciones similares.Las miniespecificaciones se presentan a todos los participantes para que sean analizadas. Sehacen adiciones, eliminaciones y otras modificaciones. En ciertos casos, el desarrollo de lasminiespecificaciones descubrirá nuevos objetos, servicios o restricciones, o requerimientos dedesempeño que se agregarán a las listas originales. Durante todos los análisis, el equipo debeposponer los aspectos que no puedan resolverse en la reunión. Se conserva una lista de aspectospara volver después a dichas ideas.Cita:“Los hechos no dejan de existirporque se les ignore.”Aldous HuxleyEvite el impulso de desechar algunaidea de un cliente con expresionescomo “demasiado costosa” o“impráctica”. La intención aquí esnegociar una lista aceptable paratodos. Para lograrlo, debe tenerse lamente abierta.CONSEJO11 En vez de crear una miniespecificación, muchos equipos de software eligen desarrollar escenarios del usuariollamados casos de uso. Éstos se estudian en detalle en la sección 5.4 y en el capítulo 6.05Pressman(101-125).indd 110 21/1/10 11:00:22CAPÍTULO 5 COMPRENSIÓN DE LOS REQUERIMIENTOS 1115.3.2 Despliegue de la función de calidadEl despliegue de la función de calidad (DFC) es una técnica de administración de la calidad quetraduce las necesidades del cliente en requerimientos técnicos para el software. El DFC “se concentra en maximizar la satisfacción del cliente a partir del proceso de ingeniería del software”[Zul92]. Para lograr esto, el DFC pone el énfasis en entender lo que resulta valioso para el clientey luego despliega dichos valores en todo el proceso de ingeniería. El DFC identifica tres tipos derequerimientos [Zul92]:Requerimientos normales. Objetivos y metas que se establecen para un producto o sistema durante las reuniones con el cliente. Si estos requerimientos están presentes, elcliente queda satisfecho. Ejemplos de requerimientos normales son los tipos de gráficos pedidos para aparecer en la pantalla, funciones específicas del sistema y niveles de rendimiento definidos.Requerimientos esperados. Están implícitos en el producto o sistema y quizá sean tanimportantes que el cliente no los mencione de manera explícita. Su ausencia causará mucha insatisfacción. Algunos ejemplos de requerimientos esperados son: fácil interacciónhumano/máquina, operación general correcta y confiable, y facilidad para instalar el software.Requerimientos emocionantes. Estas características van más allá de las expectativasdel cliente y son muy satisfactorias si están presentes. Por ejemplo, el software para unnuevo teléfono móvil viene con características estándar, pero si incluye capacidades inesperadas (como pantalla sensible al tacto, correo de voz visual, etc.) agrada a todos losusuarios del producto.Aunque los conceptos del DFC son aplicables en todo el proceso del software [Par96a], hay técnicas específicas de aquél que pueden aplicarse a la actividad de indagación de los requerimientos. El DFC utiliza entrevistas con los clientes, observación, encuestas y estudio de datos históricos (por ejemplo, reportes de problemas) como materia prima para la actividad de recabaciónLa escena: Sala de juntas. Está en marcha la primera reunión para recabar los requerimientos.Participantes: Jamie Lazar, integrante del equipo de software;Vinod Raman, miembro del equipo de software; Ed Robbins, miembro del equipo de software; Doug Miller, gerente de ingeniería desoftware; tres trabajadores de mercadotecnia; un representante deingeniería del producto, y un facilitador.La conversación:Facilitador (apunta en un pizarrón): De modo que ésa es lalista actual de objetos y servicios para la función de seguridad delhogar.Persona de mercadotecnia: Eso la cubre, desde nuestro puntode vista.Vinod: ¿No dijo alguien que quería que toda la funcionalidad deCasaSegura fuera accesible desde internet? Eso incluiría la funciónde seguridad, ¿o no?Persona de mercadotecnia: Sí, así es… tendremos que añadiresa funcionalidad y los objetos apropiados.Facilitador: ¿Agrega eso algunas restricciones?Jamie: Sí, tanto técnicas como legales.Representante del producto: ¿Qué significa eso?Jamie: Nos tendríamos que asegurar de que un extraño no puedaingresar al sistema, desactivarlo y robar en el lugar o hacer algopeor. Mucha responsabilidad sobre nosotros.Doug: Muy cierto.Mercadotecnia: Pero lo necesitamos así… sólo asegúrense deimpedir que ingrese un extraño.Ed: Eso es más fácil de decir que de hacer.Facilitador (interrumpe): No quiero que debatamos esto ahora.Anotémoslo como un aspecto y continuemos.(Doug, que es el secretario de la reunión, toma debida nota.)Facilitador: Tengo la sensación de que hay más por consideraraquí.(El grupo dedica los siguientes 20 minutos a mejorar y aumentar losdetalles de la función de seguridad del hogar.)CASASEGURAConducción de una reunión para recabar los requerimientosPUNTOCLAVEEl DFC define los requerimientos deforma que maximicen la satisfaccióndel cliente.Todos desean implementar muchosrequerimientos emocionantes, perohay que tener cuidado. Así es comoempiezan a “quedar lisiados losrequerimientos”. Pero encontrapartida, los requerimientosemocionantes llevan a un avanceenorme del producto…CONSEJOWebRefEn la dirección www.qfdi.org seencuentra información útil sobre elDFC.05Pressman(101-125).indd 111 21/1/10 11:00:22112 PARTE DOS MODELADOde los requerimientos. Después, estos datos se llevan a una tabla de requerimientos —llamadatabla de la voz del cliente— que se revisa con el cliente y con otros participantes. Luego se emplean varios diagramas, matrices y métodos de evaluación para extraer los requerimientos esperados y tratar de percibir requerimientos emocionantes [Aka04].5.3.3 Escenarios de usoA medida que se reúnen los requerimientos, comienza a materializarse la visión general defunciones y características del sistema. Sin embargo, es difícil avanzar hacia actividades mástécnicas de la ingeniería de software hasta no entender cómo emplearán los usuarios finalesdichas funciones y características. Para lograr esto, los desarrolladores y usuarios crean unconjunto de escenarios que identifican la naturaleza de los usos para el sistema que se va aconstruir. Los escenarios, que a menudo se llaman casos de uso [Jac92], proporcionan la descripción de la manera en la que se utilizará el sistema. Los casos de uso se estudian con másdetalle en la sección 5.4.La escena: Una sala de juntas, donde continúa laprimera reunión para recabar los requerimientos.Participantes: Jamie Lazar, integrante del equipo de software;Vinod Raman, miembro del equipo de software; Ed Robbins, miembro del equipo de software; Doug Miller, gerente de ingeniería desoftware; tres personas de mercadotecnia; un representante de ingeniería del producto, y un facilitador.La conversación:Facilitador: Hemos estado hablando sobre la seguridad para elacceso a la funcionalidad de CasaSegura si ha de ser posible elingreso por internet. Me gustaría probar algo. Desarrollemos unescenario de uso para entrar a la función de seguridad.Jamie: ¿Cómo?Facilitador: Podríamos hacerlo de dos maneras, pero de momentomantengamos las cosas informales. Díganos (señala a una personade mercadotecnia), ¿cómo visualiza el acceso al sistema?Persona de mercadotecnia: Um… bueno, es la clase de cosaque haría si estuviera fuera de casa y tuviera que dejar entrar aalguien a ella —por ejemplo, una trabajadora doméstica o un técnico de reparaciones— que no tuviera el código de seguridad.Facilitador (sonríe): Ésa es la razón por la que lo hace… dígame, ¿cómo lo haría en realidad?Persona de mercadotecnia: Bueno… lo primero que necesitaría sería una PC. Entraría a un sitio web que mantendríamos paratodos los usuarios de CasaSegura. Daría mi identificación de usuarioy…Vinod (interrumpe): La página web tendría que ser segura,encriptada, para garantizar que estuviéramos seguros y…Facilitador (interrumpe): Ésa es buena información, Vinod,pero es técnica. Centrémonos en cómo emplearía el usuario finalesta capacidad, ¿está bien?Vinod: No hay problema.Persona de mercadotecnia: Decía que entraría a un sitio weby daría mi identificación de usuario y dos niveles de clave.Jamie: ¿Qué pasa si olvido mi clave?Facilitador (interrumpe): Buena observación, Jamie, pero noentraremos a ella por ahora. Lo anotaremos y la llamaremos unaexcepción. Estoy seguro de que habrá otras.Persona de mercadotecnia: Después de que introdujera lasclaves, aparecería una pantalla que representaría todas las funciones de CasaSegura. Seleccionaría la función de seguridad del hogar.El sistema pediría que verificara quién soy, pidiendo mi dirección onúmero telefónico o algo así. Entonces aparecería un dibujo delpanel de control del sistema de seguridad y la lista de funciones quepuede realizar —activar el sistema, desactivar el sistema o desactivar uno o más sensores—. Supongo que también me permitiríareconfigurar las zonas de seguridad y otras cosas como ésa, pero noestoy seguro.(Mientras la persona de mercadotecnia habla, Doug toma muchasnotas; esto forma la base para el primer escenario informal de uso.Alternativamente, hubiera podido pedirse a la persona de mercadotecnia que escribiera el escenario, pero esto se hubiera hecho fuerade la reunión.)CASASEGURADesarrollo de un escenario preliminar de uso5.3.4 Indagación de los productos del trabajoLos productos del trabajo generados como consecuencia de la indagación de los requerimientosvariarán en función del tamaño del sistema o producto que se va a construir. Para la mayoría desistemas, los productos del trabajo incluyen los siguientes:05Pressman(101-125).indd 112 21/1/10 11:00:22CAPÍTULO 5 COMPRENSIÓN DE LOS REQUERIMIENTOS 113• Un enunciado de la necesidad y su factibilidad.• Un enunciado acotado del alcance del sistema o producto.• Una lista de clientes, usuarios y otros participantes que intervienen en la indagación delos requerimientos.• Una descripción del ambiente técnico del sistema.• Una lista de requerimientos (de preferencia organizados por función) y las restriccionesdel dominio que se aplican a cada uno.• Un conjunto de escenarios de uso que dan perspectiva al uso del sistema o producto endiferentes condiciones de operación.• Cualesquiera prototipos desarrollados para definir requerimientos.Cada uno de estos productos del trabajo es revisado por todas las personas que participan en laindagación de los requerimientos. 5.4 DESARROLLO DE CASOS DE USOEn un libro que analiza cómo escribir casos de uso eficaces, Alistair Cockburn [Coc01b] afirmaque “un caso de uso capta un contrato […] [que] describe el comportamiento del sistema endistintas condiciones en las que el sistema responde a una petición de alguno de sus participantes […]”. En esencia, un caso de uso narra una historia estilizada sobre cómo interactúa unusuario final (que tiene cierto número de roles posibles) con el sistema en circunstancias específicas. La historia puede ser un texto narrativo, un lineamiento de tareas o interacciones, unadescripción basada en un formato o una representación diagramática. Sin importar su forma,un caso de uso ilustra el software o sistema desde el punto de vista del usuario final.El primer paso para escribir un caso de uso es definir un conjunto de “actores” que estaráninvolucrados en la historia. Los actores son las distintas personas (o dispositivos) que usan elsistema o producto en el contexto de la función y comportamiento que va a describirse. Losactores representan los papeles que desempeñan las personas (o dispositivos) cuando opera elsistema. Con una definición más formal, un actor es cualquier cosa que se comunique conel sistema o producto y que sea externo a éste. Todo actor tiene uno o más objetivos cuandoutiliza el sistema.Es importante notar que un actor y un usuario final no necesariamente son lo mismo.Un usuario normal puede tener varios papeles diferentes cuando usa el sistema, mientrasque un actor representa una clase de entidades externas (gente, con frecuencia pero nosiempre) que sólo tiene un papel en el contexto del caso de uso. Por ejemplo, considere al operador de una máquina (un usuario) que interactúa con la computadora de control de una celdade manufactura que contiene varios robots y máquinas de control numérico. Después de unarevisión cuidadosa de los requerimientos, el software para la computadora de control requierecuatro diferentes modos (papeles) para la interacción: modo de programación, modo de prueba,modo de vigilancia y modo de solución de problemas. Por tanto, es posible definir cuatro actores: programador, probador, vigilante y solucionador de problemas. En ciertos casos, el operador de la máquina desempeñará todos los papeles. En otros, distintas personas tendrán el papelde cada actor.Debido a que la indagación de los requerimientos es una actividad evolutiva, no todos losactores son identificados en la primera iteración. En ésta es posible identificar a los actoresprincipales [Jac92], y a los secundarios cuando se sabe más del sistema. Los actores principales interactúan para lograr la función requerida del sistema y obtienen el beneficio previsto deéste. Trabajan con el software en forma directa y con frecuencia. Los actores secundarios danapoyo al sistema, de modo que los primarios puedan hacer su trabajo.¿Qué información seproduce como consecuencia de recabar losrequerimientos??PUNTOCLAVELos casos de uso se definen desde elpunto de vista de un actor. Un actores un papel que desempeñan laspersonas (usuarios) o los dispositivoscuando interactúan con el software.WebRefUn artículo excelente sobre casos deuso puede descargarse desde ladirección www.ibm.com/developerworks/webservices/library/codesign7.html05Pressman(101-125).indd 113 21/1/10 11:00:23114 PARTE DOS MODELADOUna vez identificados los actores, es posible desarrollar casos de uso. Jacobson [Jac92] sugiere varias preguntas12 que debe responder un caso de uso:• ¿Quién es el actor principal y quién(es) el(los) secundario(s)?• ¿Cuáles son los objetivos de los actores?• ¿Qué precondiciones deben existir antes de comenzar la historia?• ¿Qué tareas o funciones principales son realizadas por el actor?• ¿Qué excepciones deben considerarse al describir la historia?• ¿Cuáles variaciones son posibles en la interacción del actor?• ¿Qué información del sistema adquiere, produce o cambia el actor?• ¿Tendrá que informar el actor al sistema acerca de cambios en el ambiente externo?• ¿Qué información desea obtener el actor del sistema?• ¿Quiere el actor ser informado sobre cambios inesperados?En relación con los requerimientos básicos de CasaSegura, se definen cuatro actores: propietario de la casa (usuario), gerente de arranque (tal vez la misma persona que el propietario de la casa, pero en un papel diferente), sensores (dispositivos adjuntos al sistema) ysubsistema de vigilancia y respuesta (estación central que vigila la función de seguridad dela casa de CasaSegura). Para fines de este ejemplo, consideraremos sólo al actor llamado propietario de la casa. Éste interactúa con la función de seguridad de la casa en varias formasdistintas con el empleo del panel de control de la alarma o con una PC:• Introduce una clave que permita todas las demás interacciones.• Pregunta sobre el estado de una zona de seguridad.• Interroga acerca del estado de un sensor.• En una emergencia, oprime el botón de pánico.• Activa o desactiva el sistema de seguridad.Considerando la situación en la que el propietario de la casa usa el panel de control, a continuación se plantea el caso de uso básico para la activación del sistema:131. El propietario observa el panel de control de CasaSegura (véase la figura 5.1) para determinar si elsistema está listo para recibir una entrada. Si el sistema no está listo, se muestra el mensaje no estálisto en la pantalla de cristal líquido y el propietario debe cerrar físicamente ventanas o puertas demodo que desaparezca dicho mensaje [el mensaje no está listo implica que un sensor está abierto;por ejemplo, que una puerta o ventana está abierta].2. El propietario usa el teclado para introducir una clave de cuatro dígitos. La clave se compara conla que guarda el sistema como válida. Si la clave es incorrecta, el panel de control emitirá un sonidouna vez y se reiniciará para recibir una entrada adicional. Si la clave es correcta, el panel de controlespera otras acciones.3. El propietario selecciona y teclea permanecer o fuera (véase la figura 5.1) para activar el sistema. Laentrada permanecer activa sólo sensores perimetrales (se desactivan los sensores de detección demovimiento interior). La entrada fuera activa todos los sensores.4. Cuando ocurre una activación, el propietario observa una luz roja de alarma.12 Las preguntas de Jacobson se han ampliado para que den una visión más completa del contenido del caso deuso.13 Observe que este caso de uso difiere de la situación en la que se accede al sistema a través de internet. En estecaso, la interacción es por medio del panel de control y no con la interfaz de usuario gráfica (GUI) que se dacuando se emplea una PC.¿Qué se necesita sabera fin de desarrollar uncaso de uso eficaz??05Pressman(101-125).indd 114 21/1/10 11:00:23CAPÍTULO 5 COMPRENSIÓN DE LOS REQUERIMIENTOS 115El caso de uso básico presenta una historia de alto nivel que describe la interacción entre elactor y el sistema.En muchas circunstancias, los casos de uso son más elaborados a fin de que brinden muchosmás detalles sobre la interacción. Por ejemplo, Cockburn [Coc01b] sugiere el formato siguientepara hacer descripciones detalladas de casos de uso:Caso de uso: IniciarVigilanciaActor principal: Propietario.Objetivo en contexto: Preparar el sistema para que vigile los sensores cuando el propietario salgade la casa o permanezca dentro.Precondiciones: El sistema se ha programado para recibir una clave y reconocer distintossensores.Disparador: El propietario decide “preparar” el sistema, por ejemplo, para que enciendalas funciones de alarma.Escenario:1. Propietario: observa el panel de control2. Propietario: introduce una clave3. Propietario: selecciona “permanecer” o “fuera”4. Propietario: observa una luz roja de alarma que indica que CasaSegura ha sido activada.Excepciones:1. El panel de control no está listo: el propietario verifica todos los sensores para determinar cuálesestán abiertos; los cierra.2. La clave es incorrecta (el panel de control suena una vez): el propietario introduce la clave correcta.3. La clave no es reconocida: debe contactarse el subsistema de vigilancia y respuesta para reprogramar la clave.4. Se elige permanecer: el panel de control suena dos veces y se enciende un letrero luminoso que dicepermanecer; se activan los sensores del perímetro.5. Se selecciona fuera: el panel de control suena tres veces y se enciende un letrero luminoso que dicefuera; se activan todos los sensores.123456789* 0apagarCASASEGURA fuera permanecermax probar desvíoinstantáneo código repicarlisto# activada energíaalarma decomprobaciónde incendiofuerapermanecerinstantáneodesvíono está listopánicoFIGURA 5.1Panel de controlde CasaSeguraEs frecuente que los casos de uso seescriban de manera informal. Sinembargo, utilice el formato que sepresenta aquí para asegurar que seincluyen todos los aspectos clave.CONSEJO05Pressman(101-125).indd 115 21/1/10 11:00:23116 PARTE DOS MODELADOPrioridad: Esencial, debe implementarseCuándo estará disponible: En el primer incrementoFrecuencia de uso: Muchas veces por díaCanal para el actor: A través de la interfaz del panel de controlActores secundarios: Técnico de apoyo, sensoresCanales para los actores secundarios: Técnico de apoyo: línea telefónica Sensores: interfaces cableadas y frecuencia de radioAspectos pendientes:1. ¿Debe haber una forma de activar el sistema sin usar clave o con una clave abreviada?2. ¿El panel de control debe mostrar mensajes de texto adicionales?3. ¿De cuánto tiempo dispone el propietario para introducir la clave a partir del momento en el que seoprime la primera tecla?4. ¿Hay una forma de desactivar el sistema antes de que se active en realidad?Los casos de uso para otras interacciones de propietario se desarrollarían en una forma similar. Es importante revisar con cuidado cada caso de uso. Si algún elemento de la interacción esambiguo, es probable que la revisión del caso de uso lo detecte.14 En el apéndice 1 se presenta un breve método de aprendizaje de UML para aquellos lectores que no estén familiarizados con dicha notación.La escena: Sala de juntas, continúa la reuniónpara recabar los requerimientos.Participantes: Jamie Lazar, miembro del equipo de software;Vinod Roman, integrante del equipo de software; Ed Robbins, integrante del equipo de software; Doug Miller, gerente de ingeniería desoftware; tres miembros de mercadotecnia; un representante de ingeniería del producto; un facilitador.La conversación:Facilitador: Hemos pasado un buen tiempo hablando de la función de seguridad del hogar de CasaSegura. Durante el receso hiceun diagrama de caso de uso para resumir los escenarios importantesque forman parte de esta función. Veámoslo.(Todos los asistentes observan la figura 5.2.)Jamie: Estoy aprendiendo la notación UML.14 Veo que la función deseguridad del hogar está representada por el rectángulo grande conóvalos en su interior, ¿verdad? ¿Y los óvalos representan los casos deuso que hemos escrito?Facilitador: Sí. Y las figuras pegadas representan a los actores—personas o cosas que interactúan con el sistema según los describeel caso de uso…—; ¡ah! usé el cuadrado para representar un actorque no es persona… en este caso, sensores.Doug: ¿Es válido eso en UML?Facilitador: La legalidad no es lo importante. El objetivo es comunicar información. Veo que usar una figura humana para representar un equipo sería erróneo. Así que adapté las cosas un poco. Nopienso que genere problemas.Vinod: Está bien, entonces tenemos narraciones de casos de usopara cada óvalo. ¿Necesitamos desarrollarlas con base en los formatos sobre los que he leído?Facilitador: Es probable, pero eso puede esperar hasta que hayamos considerado otras funciones de CasaSegura.Persona de mercadotecnia: Esperen, he estado observandoeste diagrama y de pronto me doy cuenta de que hemos olvidadoalgo.Facilitador: ¿De verdad? Dime, ¿qué hemos olvidado?(La reunión continúa.)CASASEGURADesarrollo de un diagrama de caso de uso de alto nivel05Pressman(101-125).indd 116 21/1/10 11:00:24CAPÍTULO 5 COMPRENSIÓN DE LOS REQUERIMIENTOS 117 5.5 ELABORACIÓN DEL MODELO DE LOS REQUERIMIENTOS 16El objetivo del modelo del análisis es describir los dominios de información, función y comportamiento que se requieren para un sistema basado en computadora. El modelo cambia en formadinámica a medida que se aprende más sobre el sistema por construir, y otros participantescomprenden más lo que en realidad requieren. Por esa razón, el modelo del análisis es una fotografía de los requerimientos en cualquier momento dado. Es de esperar que cambie.A medida que evoluciona el modelo de requerimientos, ciertos elementos se vuelven relativamente estables, lo que da un fundamento sólido para diseñar las tareas que sigan. Sin embargo, otros elementos del modelo son más volátiles, lo que indica que los participantes todavíano entienden bien los requerimientos para el sistema. En los capítulos 6 y 7 se presentan enPropietarioAdministradordel sistemaSistemaque activa odesactivaRespondea un eventode alarmaAccedeal sistemapor internetEncuentrauna condiciónde errorReconfigurasensores ycaracterísticasdel sistemarelacionadasSensoresFIGURA 5.2Diagrama decaso de uso deUML para lafunción deseguridad delhogar deCasaSegura15 Las herramientas mencionadas aquí no son obligatorias, sino una muestra de las que hay en esta categoría. En lamayoría de casos, los nombres de las herramientas son marcas registradas por sus respectivos desarrolladores.16 En este libro se usan como sinónimos las expresiones modelar el análisis y modelar los requerimientos. Ambos serefieren a representaciones de los dominios de la información, funcional y de comportamiento que describen losrequerimientos del problema.Desarrollo de un caso de usoObjetivo: Ayudar a desarrollar casos de uso proporcionando formatos y mecanismos automatizados para evaluar la claridad y consistencia.Mecánica: La mecánica de las herramientas varía. En general, lasherramientas para casos de uso dan formatos con espacios en blancopara ser llenados y crear así casos eficaces. La mayor parte de la funcionalidad de los casos de uso está incrustada en un conjunto másamplio de funciones de ingeniería de los requerimientos.Herramientas representativas15La gran mayoría de herramientas de análisis del modelado basadasen UML dan apoyo tanto de texto como gráfico para el desarrollo ymodelado de casos de uso.Objects by Design(www.objectsbydesign.com/tools/umltools_byCompany.html) proporciona vínculos exhaustivos con herramientas de estetipo.HERRAMIENTAS DE SOFTWARE05Pressman(101-125).indd 117 21/1/10 11:00:24118 PARTE DOS MODELADOdetalle el modelo del análisis y los métodos que se usan para construirlo. En las secciones siguientes se da un panorama breve.5.5.1 Elementos del modelo de requerimientosHay muchas formas diferentes de concebir los requerimientos para un sistema basado encomputadora. Algunos profesionales del software afirman que es mejor seleccionar un modo derepresentación (por ejemplo, el caso de uso) y aplicarlo hasta excluir a todos los demás. Otrospiensan que es más benéfico usar cierto número de modos de representación distintos parailustrar el modelo de requerimientos. Los modos diferentes de representación fuerzan a considerar los requerimientos desde distintos puntos de vista, enfoque que tiene una probabilidadmayor de detectar omisiones, inconsistencia y ambigüedades.Los elementos específicos del modelo de requerimientos están determinados por el métodode análisis de modelado (véanse los capítulos 6 y 7) que se use. No obstante, la mayoría de modelos tiene en común un conjunto de elementos generales.Elementos basados en el escenario. El sistema se describe desde el punto de vista delusuario con el empleo de un enfoque basado en el escenario. Por ejemplo, los casos de usobásico (véase la sección 5.4) y sus diagramas correspondientes de casos de uso (véase la figura5.2) evolucionan hacia otros más elaborados que se basan en formatos. Los elementos del modelo de requerimientos basados en el escenario con frecuencia son la primera parte del modeloen desarrollo. Como tales, sirven como entrada para la creación de otros elementos de modelado. La figura 5.3 ilustra un diagrama de actividades UML17 para indagar los requerimientos yrepresentarlos con el empleo de casos de uso. Se aprecian tres niveles de elaboración que culminan en una representación basada en el escenario.Elementos basados en clases. Cada escenario de uso implica un conjunto de objetos quese manipulan cuando un actor interactúa con el sistema. Estos objetos se clasifican en clases:conjunto de objetos que tienen atributos similares y comportamientos comunes. Por ejemplo,para ilustrar la clase Sensor de la función de seguridad de Casa Segura (véase la figura 5.4),puede utilizarse un diagrama de clase UML. Observe que el diagrama enlista los atributos de lossensores (por ejemplo, nombre, tipo, etc.) y las operaciones (por ejemplo, identificar y permitir)que se aplican para modificarlos. Además de los diagramas de clase, otros elementos de modelado del análisis ilustran la manera en la que las clases colaboran una con otra y las relacionese interacciones entre ellas. Esto se analiza con más detalle en el capítulo 7.Elementos de comportamiento. El comportamiento de un sistema basado en computadoratiene un efecto profundo en el diseño que se elija y en el enfoque de implementación que seaplique. Por tanto, el modelo de requerimientos debe proveer elementos de modelado que ilustren el comportamiento.El diagrama de estado es un método de representación del comportamiento de un sistema queilustra sus estados y los eventos que ocasionan que el sistema cambie de estado. Un estado escualquier modo de comportamiento observable desde el exterior. Además, el diagrama de estado indica acciones (como la activación de un proceso, por ejemplo) tomadas como consecuencia de un evento en particular.Para ilustrar el uso de un diagrama de estado, considere el software incrustado dentro delpanel de control de CasaSegura que es responsable de leer las entradas que hace el usuario. Enla figura 5.5 se presenta un diagrama de estado UML simplificado.Además de las representaciones de comportamiento del sistema como un todo, también esposible modelar clases individuales. Sobre esto se presentan más análisis en el capítulo 7.17 En el apéndice 1 se presenta un instructivo breve sobre UML, para aquellos lectores que no estén familiarizadoscon dicha notación.Siempre es buena idea involucrar alos participantes. Una de las mejoresformas de lograrlo es hacer que cadauno escriba casos de uso que narrenel modo en el que se utilizará elsoftware.CONSEJOUna forma de aislar las clases esbuscar sustantivos descriptivos en uncaso de usuario expresado con texto.Al menos algunos de ellos seráncandidatos cercanos. Sobre esto sehabla más en el capítulo 8.CONSEJOPUNTOCLAVEUn estado es un modo decomportamiento observable desde el
